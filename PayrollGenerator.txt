    /**************************************************
     * PAYROLL GENERATOR v9.4 (CRITICAL CALCULATION & HEADER FIX)
     * ----------------------------------------------
     * - CRITICAL FIX: Resolved bug causing bloated Gross Pay and duplicate
     * headers by ensuring only actual pay components are used in calculations.
     * - FIX: Corrected a date-parsing error that caused incorrect proration
     * of Basic Pay for full pay periods.
     * - FIX: Resolved a "mHeaders.indexOf is not a function" error.
     **************************************************/

    function ping() { return 'pong'; }

// BIR 13th-month + other benefits exemption cap (per year)
const OTHER_BENEFITS_EXEMPT_YTD = 90000;

/**
 * DEBUG: Log 13th-month / other-benefits annualization.
 * Writes into hidden sheet "_DEBUG_TAX".
 *
 * Columns:
 * - Non-taxable vs taxable 13th/other benefits this run
 * - YTD other benefits before this run
 * - Projected annual income used for annual brackets
 * - Annual rate used for 13th/other benefits
 * - WTax split: regular vs 13th vs total for the cutoff
 */
function debugTaxAnnualizationRow(info) {
  try {
    if (!info) {
      Logger.log('DEBUG_TAX: no info payload passed to debugTaxAnnualizationRow');
      return;
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheetName = '_DEBUG_TAX';
    let sh = ss.getSheetByName(sheetName);

    if (!sh) {
      sh = ss.insertSheet(sheetName);
      sh.appendRow([
        'Timestamp',
        'Period',
        'Part',
        'Employee ID',
        'Pay Frequency',
        'Run Type', // SEMI / MONTHLY / SPECIAL

        'YTD Other Benefits (before)',
        'This Run â€“ Other Benefits (total)',
        'This Run â€“ Other Benefits (non-taxable)',
        'This Run â€“ Other Benefits (taxable)',
        'Exemption Cap',
        'Remaining Exempt Before Run',

        'Taxable Income For Period',
        'Projected Annual Taxable (incl this run)',
        'Annual Rate Used (for 13th)',
        'WTax â€“ Regular Portion',
        'WTax â€“ 13th Portion',
        'WTax â€“ Total For Period'
      ]);
      sh.hideSheet();
    }

    sh.appendRow([
      new Date(),
      info.periodLabel || '',
      info.partLabel || '',
      info.empId || '',
      info.payFrequency || '',
      info.runType || '',

      info.ytdOtherBefore != null ? info.ytdOtherBefore : '',
      info.otherBenefitsThisRun != null ? info.otherBenefitsThisRun : '',
      info.nonTaxableOtherBenefits != null ? info.nonTaxableOtherBenefits : '',
      info.taxableOtherBenefits != null ? info.taxableOtherBenefits : '',
      info.cap != null ? info.cap : '',
      info.remainingExemptBeforeRun != null ? info.remainingExemptBeforeRun : '',

      info.taxableIncomeForPeriod != null ? info.taxableIncomeForPeriod : '',
      info.projectedAnnual != null ? info.projectedAnnual : '',
      info.annualRate != null ? info.annualRate : '',
      info.wtaxRegular != null ? info.wtaxRegular : '',
      info.wtax13th != null ? info.wtax13th : '',
      info.wtaxTotal != null ? info.wtaxTotal : ''
    ]);

    if (!sh.isSheetHidden()) {
      sh.hideSheet();
    }
  } catch (err) {
    Logger.log('DEBUG_TAX error: ' + err);
  }
}
// Normalize headers so "A\n(B)" matches "A (B)"
const _normHdr_ = (s) =>
  String(s || '')
    .replace(/\s+/g, ' ')      // collapses spaces, tabs, newlines
    .trim()
    .toUpperCase();


/**
 * DEBUG: Log how "Projected Annual Taxable (incl this run)" is computed.
 * Writes into a hidden sheet named "_DEBUG_WTAX_ANNUAL".
 *
 * Expected info payload (object):
 *   empId
 *   empName
 *   frequency              // 'M', 'SM', 'BW', 'W', etc.
 *   periodLabel            // e.g. '2025-03A', 'Mar 1â€“15'
 *
 *   taxableRegularYtdBeforeRun   // YTD regular taxable BEFORE this run
 *   taxableRegularThisRun        // regular taxable this cutoff (no 13th/other)
 *   taxable13thThisRun           // taxable portion of 13th/other in this run
 *   remainingCutoffs             // number of remaining cutoffs after this run
 *
 *   annualProjectedRegular       // your computed projected annual REGULAR
 *   annualProjectedTotal         // your "Projected Annual Taxable (incl this run)"
 *                                // (a.k.a. Projected Annual Taxable incl 13th)
 */
function _debugAnnualProjection_(info) {
  try {
    if (!info) {
      Logger.log('DEBUG_WTAX_ANNUAL: no info payload passed');
      return;
    }

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const SHEET_NAME = '_DEBUG_WTAX_ANNUAL';
    let sh = ss.getSheetByName(SHEET_NAME);

    // Create + initialize the sheet the first time
    if (!sh) {
      sh = ss.insertSheet(SHEET_NAME);
      sh.hideSheet();
      sh.appendRow([
        'Timestamp',
        'Employee ID',
        'Employee Name',
        'Frequency',
        'Period Label',

        // Components of regular projection
        'YTD Regular (before run)',
        'Regular This Run',
        'Remaining Cutoffs (incl current)',
        'Projected Regular For Remaining Cutoffs (future only)',

        // Regular + 13th summary
        'Projected Annual Regular (input)',
        'Taxable 13th This Run',

        // Total (what your tax helper uses)
        'Projected Annual Taxable incl this run (input)',
        'Projected Annual Taxable incl this run (recalc)',
        'Diff: Input - Recalc'
      ]);
    }

    const remainingCutoffsIncl = Math.max(Number(info.remainingCutoffs || 0), 0);

    const ytdReg  = Number(info.taxableRegularYtdBeforeRun || 0);
    const regThis = Number(info.taxableRegularThisRun || 0);
    const tax13th = Number(info.taxable13thThisRun || 0);

    // ðŸ”‘ With "remainingCutoffs" now defined as INCLUDING this run:
    // total projected regular = YTD + regThis * remainingCutoffsIncl
    //
    // So FUTURE periods (after this run) = remainingCutoffsIncl - 1
    const projRegularRemaining =
      regThis * Math.max(remainingCutoffsIncl - 1, 0);

    const projAnnualRegularInput =
      Number(info.annualProjectedRegular || 0);

    const projAnnualTotalInput =
      Number(info.annualProjectedTotal ||
             info.annualProjectedTaxableIncl13th || 0);

    // Rebuild "Projected Annual Taxable incl this run" from the pieces:
    //   YTD regular
    // + current regular
    // + future regular (remainingCutoffsIncl - 1 periods)
    // + taxable 13th / other benefits this run
    const projAnnualTotalRecalc =
      ytdReg +
      regThis +
      projRegularRemaining +
      tax13th;

    const diffTotal = projAnnualTotalInput - projAnnualTotalRecalc;

    sh.appendRow([
      new Date(),
      info.empId || '',
      info.empName || '',
      info.frequency || '',
      info.periodLabel || '',

      ytdReg,
      regThis,
      remainingCutoffsIncl,
      projRegularRemaining,

      projAnnualRegularInput,
      tax13th,

      projAnnualTotalInput,
      projAnnualTotalRecalc,
      diffTotal
    ]);
  } catch (err) {
    Logger.log('DEBUG_WTAX_ANNUAL error: ' + err);
  }
}


/**
 * DEBUG: Log withholding-tax computation for semi-monthly A/B.
 * RESTORED simple layout:
 * Timestamp | Period | Part | Employee ID | Pay Frequency | Mode |
 * Taxable A (hist) | WHT A (hist) | Taxable B (this run) |
 * Taxable Full Month (A+B) | Monthly Tax (A+B) |
 * Fallback A (semi) | "Already" subtracted | Computed Tax this cutoff
 */
function _debugWithholdingTaxRow_(info) {
  try {
    if (!info) {
      Logger.log('DEBUG_WTAX: no info payload passed');
      return;
    }

    var ss = SpreadsheetApp.getActiveSpreadsheet();
    var SHEET_NAME = '_DEBUG_WTAX';
    var sh = ss.getSheetByName(SHEET_NAME);

    // First-time setup: create + initialize sheet
    if (!sh) {
      sh = ss.insertSheet(SHEET_NAME);
      sh.appendRow([
        'Timestamp',
        'Period',
        'Part',
        'Employee ID',
        'Pay Frequency',
        'Mode',
        'Taxable A (hist)',
        'WHT A (hist)',
        'Taxable B (this run)',
        'Taxable Full Month (A+B)',
        'Monthly Tax (A+B)',
        'Fallback A (semi)',
        '"Already" subtracted',
        'Computed Tax this cutoff'
      ]);
      sh.hideSheet();
    }

    sh.appendRow([
      new Date(),
      info.periodLabel || '',
      info.partLabel || '',
      info.empId || '',
      info.payFrequency || '',
      info.mode || '',
      info.taxableA != null ? info.taxableA : '',
      info.taxAWithheld != null ? info.taxAWithheld : '',
      info.taxableB != null ? info.taxableB : '',
      info.taxableForMonth != null ? info.taxableForMonth : '',
      info.taxMonth != null ? info.taxMonth : '',
      info.fallbackA != null ? info.fallbackA : '',
      info.already != null ? info.already : '',
      info.tax != null ? info.tax : ''
    ]);
  } catch (err) {
    Logger.log('DEBUG_WTAX error: ' + err);
  }
}



  function loadPayrollMenu(e) {
  var ui = SpreadsheetApp.getUi();

  // Group: Run
  var runMenu = ui.createMenu('ðŸ§® Run')
  .addItem('Generate Payroll Computation', 'showPayrollDialog')
  .addItem('Post / Unpost Payroll History', 'showPostHistoryDialog');


  // Group: YTD & Annualization
  var ytdMenu = ui.createMenu('ðŸ”„ YTD & Annualization')
    .addItem('Pre-annualization', 'showPreAnnualizationDialog')
    .addItem('Final Annualization', 'showFinalAnnualizationDialog')
    .addItem('BIR 2316 and BIR 1604-C Alphalist', 'showBir2316Dialog');
  // Group: Outputs
  var outputsMenu = ui.createMenu('ðŸ§¾ Outputs')
    .addItem('Generate Payslips', 'showPayslipDialog')
    .addItem('Generate Payroll Entries', 'showPayrollPostingDialog')
    .addItem('Statutory Reports', 'showStatutoryReportsDialog')
    .addItem('BIR 1601-C', 'showBir1601CDialog')

    

  // Main menu
  ui.createMenu('Payroll')
    .addSubMenu(runMenu)
    .addSubMenu(ytdMenu)
    .addSubMenu(outputsMenu)
    .addSeparator()
    .addItem('âš™ Settings Center', 'showSettingsCenter') // not a submenu (only 1 item)
    .addItem('â„¹ï¸ About / License', 'showAboutLicenseDialog')
    .addItem('ðŸ’¬ Send Feedback', 'showFeedbackDialog')
    .addToUi();
}

  
    function onEdit(e) {
      if (!e || !e.range) return;
      const sh = e.range.getSheet();
      if (sh.getName() !== 'EMPLOYEE_MODE_OVERRIDES') return;
      const row = e.range.getRow();
      const col = e.range.getColumn();
      if (col === 1 && row > 1) { // Column A (Employee Name)
        const name = e.range.getValue();
        if (name) {
          const id = _getIdFromNameInCache_(name);
          if (id) sh.getRange(row, 2).setValue(id);
        } else {
          sh.getRange(row, 2).clearContent();
        }
      }
    }

    function showPayrollDialog() {
      const html = HtmlService.createTemplateFromFile('PayrollPrompt')
      .evaluate()
        .setWidth(420)
        .setHeight(460);
      SpreadsheetApp.getUi().showModalDialog(html, ' ');
    }

    function openSettings_() {
      const html = HtmlService.createTemplateFromFile('PayrollSettingsDialog')
        .evaluate()
        .setWidth(520)
        .setHeight(640);
      SpreadsheetApp.getUi().showModalDialog(html, 'Payroll Settings');
    }

function _clientSettingsProps_() {
  // Per-spreadsheet (per client file)
  return PropertiesService.getDocumentProperties();
}

function _extractFileId_(s) {
  const m = String(s || '').match(/[-\w]{25,}/);
  return m ? m[0] : '';
}

function saveSettings(form) {
  const props = _clientSettingsProps_();
  const f = form || {};

  const hasOwn = (k) => Object.prototype.hasOwnProperty.call(f, k);

  // Returns { provided: boolean, value: any }
  function pick(keys) {
    for (const k of keys) {
      if (hasOwn(k)) return { provided: true, value: f[k] };
    }
    return { provided: false, value: undefined };
  }

  function setIfProvided(propKey, picked, transformFn) {
    if (!picked.provided) return;
    const v = transformFn ? transformFn(picked.value) : picked.value;
    props.setProperty(propKey, String(v == null ? '' : v).trim());
  }

  // =========================
  // A) PAYROLL URL SETTINGS
  // Update only if the specific keys were provided
  // =========================
  const pSource = pick(['SOURCE_SS_ID', 'masterIdOrUrl', 'masterUrl']);
  if (pSource.provided) {
    const raw = String(pSource.value == null ? '' : pSource.value).trim();
    props.setProperty('SOURCE_SS_ID', _extractFileId_(raw));
    props.setProperty('SOURCE_SS_RAW', raw);
  }

  const pInputs = pick(['INPUTS_SS_ID', 'inputsIdOrUrl', 'inputsUrl']);
  if (pInputs.provided) {
    const raw = String(pInputs.value == null ? '' : pInputs.value).trim();
    props.setProperty('INPUTS_SS_ID', _extractFileId_(raw));
    props.setProperty('INPUTS_SS_RAW', raw);
  }

  const pMasterSheet = pick(['MASTER_SHEET_NAME', 'masterSheetName', 'masterSheet']);
  if (pMasterSheet.provided) {
    const raw = String(pMasterSheet.value == null ? '' : pMasterSheet.value).trim();
    props.setProperty('MASTER_SHEET_NAME', raw || 'Masterfile Import');
  }

  // =========================
  // B) COMPANY DETAILS
  // Update only if the specific keys were provided
  // =========================
  setIfProvided('COMPANY_TIN', pick(['COMPANY_TIN', 'companyTin']));
  setIfProvided('COMPANY_REGISTERED_NAME', pick(['COMPANY_REGISTERED_NAME', 'companyRegisteredName']));
  setIfProvided('COMPANY_REGISTERED_ADDRESS1', pick(['COMPANY_REGISTERED_ADDRESS1', 'companyAddress1']));
  setIfProvided('COMPANY_REGISTERED_ADDRESS2', pick(['COMPANY_REGISTERED_ADDRESS2', 'companyAddress2']));
  setIfProvided('COMPANY_ZIP_CODE', pick(['COMPANY_ZIP_CODE', 'companyZip']));
  setIfProvided('COMPANY_AUTHORIZED_REP', pick(['COMPANY_AUTHORIZED_REP', 'companyAuthRep']));

    // =========================
  // C) ACCOUNTING INTEGRATION
  // Update only if keys were provided
  // =========================
  setIfProvided('ACC_PROVIDER', pick(['ACC_PROVIDER', 'accProvider']));

  // Xero
  setIfProvided('XERO_TENANT_ID', pick(['XERO_TENANT_ID', 'xeroTenantId']));
  setIfProvided('XERO_ACCESS_TOKEN', pick(['XERO_ACCESS_TOKEN', 'xeroAccessToken']));

  // Odoo
  setIfProvided('ODOO_BASE_URL', pick(['ODOO_BASE_URL', 'odooBaseUrl']));
  setIfProvided('ODOO_DB', pick(['ODOO_DB', 'odooDb']));
  setIfProvided('ODOO_USERNAME', pick(['ODOO_USERNAME', 'odooUsername']));
  setIfProvided('ODOO_API_KEY', pick(['ODOO_API_KEY', 'odooApiKey']));


  SpreadsheetApp.getActive().toast('âœ… Settings saved.', 'Settings', 4);
  return true;
}



function loadSettings() {
  const defaults = getDefaultSettings_();
  const propsObj = _clientSettingsProps_().getProperties();

  // Merge to a FLAT object (what your HTML expects)
  const out = Object.assign({}, defaults, propsObj);

  // Show URL (raw) in the UI if available, otherwise fall back to ID
  out.SOURCE_SS_ID = (propsObj.SOURCE_SS_RAW || propsObj.SOURCE_SS_ID || defaults.SOURCE_SS_ID || '').trim();
  out.INPUTS_SS_ID = (propsObj.INPUTS_SS_RAW || propsObj.INPUTS_SS_ID || defaults.INPUTS_SS_ID || '').trim();

  // Ensure default master sheet name still shows if not set
  out.MASTER_SHEET_NAME = (propsObj.MASTER_SHEET_NAME || defaults.MASTER_SHEET_NAME || 'Masterfile Import').trim();

  // =========================
  // Company Details (explicit, always return strings)
  // =========================
  out.COMPANY_TIN =
    (propsObj.COMPANY_TIN || defaults.COMPANY_TIN || '').trim();

  out.COMPANY_REGISTERED_NAME =
    (propsObj.COMPANY_REGISTERED_NAME || defaults.COMPANY_REGISTERED_NAME || '').trim();

  out.COMPANY_REGISTERED_ADDRESS1 =
    (propsObj.COMPANY_REGISTERED_ADDRESS1 || defaults.COMPANY_REGISTERED_ADDRESS1 || '').trim();

  out.COMPANY_REGISTERED_ADDRESS2 =
    (propsObj.COMPANY_REGISTERED_ADDRESS2 || defaults.COMPANY_REGISTERED_ADDRESS2 || '').trim();

  out.COMPANY_ZIP_CODE =
    (propsObj.COMPANY_ZIP_CODE || defaults.COMPANY_ZIP_CODE || '').trim();

  out.COMPANY_AUTHORIZED_REP =
    (propsObj.COMPANY_AUTHORIZED_REP || defaults.COMPANY_AUTHORIZED_REP || '').trim();

  return out;
}



function resetSettingsToDefaults() {
  const props = _clientSettingsProps_();
  const defaults = getDefaultSettings_();
  props.setProperties(defaults, true);
  return defaults;
}


    function testConnections(form) {
  const results = {};

  // ðŸ”¹ MASTERFILE
  try {
    if (form.SOURCE_SS_ID) {
      const masterId = parseFileId_(form.SOURCE_SS_ID);
      const mf = SpreadsheetApp.openById(masterId);
      const mfName = mf.getName();
      results.masterfile = `âœ… Masterfile found: "${mfName}"`;
    } else {
      results.masterfile = 'âš ï¸ No Masterfile ID provided.';
    }
  } catch (err) {
    Logger.log('Masterfile connection error: ' + err.message);
    results.masterfile = `âŒ Error opening masterfile: ${err.message}`;
  }

  // ðŸ”¹ ADJUSTMENT FILE
  try {
    if (form.INPUTS_SS_ID) {
      const adjId = parseFileId_(form.INPUTS_SS_ID);
      const adj = SpreadsheetApp.openById(adjId);
      const adjName = adj.getName();
      results.adjustments = `âœ… Adjustments file found: "${adjName}"`;
    } else {
      results.adjustments = 'âš ï¸ No Adjustments file ID provided.';
    }
  } catch (err) {
    Logger.log('Adjustments connection error: ' + err.message);
    results.adjustments = `âŒ Error opening adjustments file: ${err.message}`;
  }

  Logger.log('Connection test results: ' + JSON.stringify(results));
  return results;
}


    function parseFileId_(s) {
      const str = String(s || '').trim();
      const m = str.match(/[-\w]{25,}/);
      return m ? m[0] : str;
    }

function _eqCI_(a, b) {
  return String(a || '').trim().toLowerCase() === String(b || '').trim().toLowerCase();
}


    function getDefaultSettings_() {
      return {
        SOURCE_SS_ID: '',
        INPUTS_SS_ID: '',
        MASTER_SHEET_NAME: 'Masterfile Import',
        WORKING_DAYS_PER_YEAR: '261',
        PH_RATE: '0.05',
        PH_MIN_BASE: '10000',
        PH_MAX_BASE: '100000',
        PAGIBIG_EE_RATE: '0.02',
        PAGIBIG_ER_RATE: '0.02',
        PAGIBIG_MAX_BASE: '10000',

        // company defaults
    COMPANY_TIN: '',
    COMPANY_REGISTERED_NAME: '',
    COMPANY_REGISTERED_ADDRESS1: '',
    COMPANY_REGISTERED_ADDRESS2: '',
    COMPANY_ZIP_CODE: '',
    COMPANY_AUTHORIZED_REP: '',

            // =========================
        // Accounting Integration
        // =========================
        ACC_PROVIDER: '', // '', 'XERO', 'ODOO'

        // Xero (paste token-based for now)
        XERO_TENANT_ID: '',
        XERO_ACCESS_TOKEN: '',

        // Odoo (JSON-RPC)
        ODOO_BASE_URL: '',   // e.g. https://yourcompany.odoo.com
        ODOO_DB: '',
        ODOO_USERNAME: '',
        ODOO_API_KEY: ''     // or password

      };
    }






    /* =======================================================
    * 2) ENTRYPOINT (called by HTML): runPayrollWithDetails()
    * ======================================================= */
    function runPayrollWithDetails(form) {
  const ok = _safeRun_(() => {
    const code = String(form && form.payrollCode || '').trim().toUpperCase();

    if (code === 'SPECIAL') {
      // SPECIAL â†’ dedicated path (Inputs-only)
      return _runPayrollSpecial_(form);
    }

    if (code === 'MONTHLY') {
      // MONTHLY â†’ full-month runner
      return _runPayrollMonthly_(form);
    }

    // Default: SEMI (A/B) handled by core
    return _runPayrollCore_(form);
  });
  return ok;
}


    /* ====================================
    * 3) CORE GENERATION FLOW (top-level)
    * ==================================== */
    function _runPayrollCore_(form) {
      if (!form || !form.payrollCode || !form.startDate || !form.endDate)
        throw new Error('Incomplete payroll details from dialog.');

        // âœ… NEW: normalize boolean flags from the dialog
      const computeContrib = form.computeContrib === true || String(form.computeContrib).toLowerCase() === 'true';
      const computeTax     = form.computeTax === true     || String(form.computeTax).toLowerCase() === 'true';

      // ---- Payroll Context ----
      
        // Context
  const rangeStart = new Date(form.startDate);
  const rangeEnd   = new Date(form.endDate);

  // ðŸ” Always anchor the payroll month on the TO date (rangeEnd)
// This fixes cross-month periods like Oct 26â€“Nov 10 â†’ November payroll.
// ðŸ” Payroll month anchor
// Default: TO date (rangeEnd)
// BUT: if SEMI-B crosses month boundary (e.g. Jan 20â€“Feb 4), anchor to FROM date so it stays in January.
const partLabel = String(form.payrollCode || 'A').trim().toUpperCase(); // 'A' or 'B'

const crossesMonth =
  rangeStart.getFullYear() !== rangeEnd.getFullYear() ||
  rangeStart.getMonth() !== rangeEnd.getMonth();

const anchorDate = (partLabel === 'B' && crossesMonth)
  ? rangeStart
  : rangeEnd;

const tz         = Session.getScriptTimeZone();

const year      = anchorDate.getFullYear();
const month     = anchorDate.getMonth() + 1;


// âœ… Month key ONLY for history lookups
const periodKey = `${year}-${String(month).padStart(2, '0')}`;

// âœ… Label written into the Period column in the computation sheet
const periodLabel = `${periodKey}-${partLabel}`;

const payrollMonth = Utilities.formatDate(anchorDate, tz, 'MMMM yyyy');




        // SPECIAL should never go through core â€” use _runPayrollSpecial_ instead
  if (partLabel === 'SPECIAL') {
    throw new Error('SPECIAL runs are handled by the SPECIAL option (runPayrollSpecial). Please re-run using the SPECIAL button.');
  }


      const activeSS = SpreadsheetApp.getActiveSpreadsheet();
      const cfg = _readSettings_();

      _progress(0, "Phase 1/4: Loading settings & source data...", "--");

      // ==== Frequency flags (global for this run) ====
const payfreqStr = String(cfg.PAY_FREQUENCY || '').toLowerCase();
// Force SEMI for this core runner
const IS_SEMI = true;
const IS_MONTHLY = false;


      const { sourceSS, inputsSS } = _openLinkedFiles_(cfg, activeSS);

      // ðŸ§© Load component classification map
      const componentMap = (() => {
        try {
          const map = _buildComponentMap_(cfg);
          Logger.log(`Component map loaded: ${Object.keys(map).length} components`);
          return map;
        } catch (e) {
          Logger.log(`âš ï¸ Component map unavailable: ${e.message}`);
          return {};
        }
      })();

      // =====================
    // =====================
    // ðŸ§© ENTITY + PAYROLL GROUP FILTERING (Aligned with HTML)
    // =====================
    // =====================
// ENTITY + PAYROLL GROUP FILTERING (robust)
// =====================
const entityVal = String(form.entity || '').trim().toUpperCase();

// 1) Normalize payrollGroups from the dialog (handles array OR string)
const normalizeGroups = (g) => {
  if (Array.isArray(g)) return g;
  // Accept "A,B", "A | B", "A;B", newlines, extra spaces
  return String(g || '')
    .split(/[\n,;|]/g)
    .map(s => s.trim())
    .filter(Boolean);
};

const rawGroupList = normalizeGroups(form.payrollGroups || []);
let selectedGroups = new Set(
  rawGroupList.map(g => String(g).trim().toUpperCase())
);

Logger.log(`ðŸ”Ž payrollGroups typeof=${typeof form.payrollGroups} value=${JSON.stringify(form.payrollGroups)}`);
Logger.log(`ðŸ”Ž normalized groups=${JSON.stringify(rawGroupList)}`);


// If both specifics and ALL are present, honor specifics only
if (selectedGroups.size > 1 && selectedGroups.has('ALL')) {
  selectedGroups.delete('ALL');
}

const isAllGroups = selectedGroups.size === 0; // empty = ALL

// --- Pull master rows
const master = _mustGetSheet_(sourceSS, cfg.MASTER_SHEET_NAME);
const allRows = master.getDataRange().getValues();
if (allRows.length < 2) throw new Error(`No data found in ${cfg.MASTER_SHEET_NAME}.`);

// --- Header indexes (robust)
// --- Header indexes (robust, now using TRACKING CATEGORY 1 instead of ENTITY)
const rawHeaders = allRows[0].map(h => String(h || '').trim());

// --- Resolve dynamic tracking columns (dimension 1 & 2)
// For Masterfile, _resolveTrackingColumns_ will map columns D/E as dim1/dim2.
const {
  dim1Idx: entityIdx,
  dim1Label: tc1Label,
  dim2Label: tc2Label
} = _resolveTrackingColumns_(rawHeaders);

let groupIdx = _findHeaderFuzzy_(rawHeaders, [
  'Payroll Group',
  'PAYROLL GROUP',
  'Group',
  'Group Name'
]);

if (entityIdx === -1) {
  throw new Error('Missing Tracking/Entity column in Masterfile Import (dimension 1).');
}
if (groupIdx === -1) {
  throw new Error('Missing "Payroll Group" column in Masterfile Import.');
}



// --- Filter rows
const filteredRows = [allRows[0], ...allRows.slice(1).filter(r => {
  const ent = String(r[entityIdx] || '').trim().toUpperCase();
  const grp = String(r[groupIdx]  || '').trim().toUpperCase();

  // Entity rule: ALL ENTITIES means no restriction
  const entMatch = !entityVal || entityVal === 'ALL' || ent === entityVal;

  // Group rule
  if (isAllGroups) return entMatch;           // no group restriction
  if (!grp) return false;                     // blanks never pass when specifics are chosen
  return entMatch && selectedGroups.has(grp); // exact match only
})];

if (filteredRows.length <= 1) {
  const sel = isAllGroups ? 'ALL' : [...selectedGroups].join(', ');
  throw new Error(`No employees found for Entity "${entityVal || 'ALL'}" and selected groups: ${sel}`);
}

Logger.log(`âœ… Filtered ${filteredRows.length - 1} employees | Entity=${entityVal || 'ALL'} | Groups=${
  isAllGroups ? 'ALL' : [...selectedGroups].join(', ')
}`);

const mVals = filteredRows;
const mHeaders = mVals[0].map(s => String(s || '').trim());
const rows = mVals.slice(1);

      const bir      = _loadBirTable_(_mustGetSheet_(activeSS, 'BIR_TABLE'));
      const sssTable = _loadSssTable_(_mustGetSheet_(activeSS, 'SSS_TABLE'));
            const out      = activeSS.getSheetByName('Payroll computation') || activeSS.insertSheet('Payroll computation');
      const inputsSheet = inputsSS ? (inputsSS.getSheetByName('Inputs') || inputsSS.getSheetByName('Adjustments')) : null;

// Load unified Inputs if present
let baseAdjustments = _loadInputsWithin_(inputsSheet);

// âœ… Always also read Absences_Tardiness directly (and force Basic Pay Related)
// This guarantees ABSENCE/TARDINESS are treated as Basic Pay Related even if Inputs is stale.
const absTardDirect = _loadAbsencesTardinessDirect_(inputsSS);

// Merge (same keying behavior as _loadInputsWithin_: empId + name case-insensitive)
const mergeMap = new Map();
baseAdjustments.forEach(a => mergeMap.set(`${a.empId}||${String(a.name).toLowerCase()}`, a));

absTardDirect.forEach(a => {
  const k = `${a.empId}||${String(a.name).toLowerCase()}`;
  const prev = mergeMap.get(k);

  if (prev) {
    // âœ… Prevent double-counting:
    // Absence/Tardiness may already exist in baseAdjustments (from Inputs/Adjustments loader),
    // so DO NOT add again. Only enforce category.
    prev.cat = 'Basic Pay Related';
    return;
  }

  // Not present yet â†’ add it (and enforce category)
  a.cat = 'Basic Pay Related';
  mergeMap.set(k, a);
});

baseAdjustments = Array.from(mergeMap.values());


const attendanceSheet = inputsSS ? inputsSS.getSheetByName('Attendance') : null;
const attendanceDaysMap = _loadAttendanceDaysMap_(attendanceSheet);


      // History for prior-taken protection
      const hist      = _ensureHistorySheet_();
const takenMap  = _loadTakenThisMonth_(hist, periodKey);
const takenByPt = _loadTakenThisMonthByPart_(hist, periodKey);
const takenByPtSigned = _loadTakenThisMonthByPartSigned_(hist, periodKey); // âœ… NEW (signed for base rebuild only)


      // ðŸ”¹ YTD 13th month & other benefits (per employee, per calendar year)
const anchorYear = anchorDate.getFullYear();
const ytdOtherBenefitsMap = _loadYtdOtherBenefitsMap_(hist, anchorYear, componentMap);
const ytdTaxableIncomeMap  = _loadYtdTaxableIncomeMap_(hist, anchorYear);


      // ðŸ”¹ One-off adjustments from Inputs/Adjustment file
      
const payBasisMap = (() => {
  const map = new Map();
  const idxEmp = _findHeaderFuzzy_(mHeaders, ['Employee ID','Emp ID']);
  const idxPB  = _findHeaderFuzzy_(mHeaders, ['Pay Basis','PAY BASIS']);
  rows.forEach(r => {
    const eid = idxEmp > -1 ? String(r[idxEmp] || '').trim() : '';
    if (!eid) return;
    const pb = idxPB > -1 ? String(r[idxPB] || '').trim().toUpperCase() : '';
    map.set(eid, pb || 'MONTHLY');
  });
  return map;
})();


      // ðŸ”¹ Recurring Adjustments from Masterfile (sheet: "Recurring Adjustments")
      // - Respects SPLIT / 1ST / 2ND for semi-monthly A/B
      // - Ignores Mode for monthly
      // - Blocks SPECIAL inside the helper
      const recurringAdjustments = _loadRecurringAdjustments_(sourceSS, {
  rangeStart,
  rangeEnd,
  partLabel,
  periodKey,
  hist,
  payBasisMap,
  attendanceDaysMap
});


      // âœ… Combined adjustments used in computation
      const adjustments = [...baseAdjustments, ...recurringAdjustments];



        
      // --- Case-insensitive header index ---
      const headerIndex = {};
      mHeaders.forEach((h, i) => headerIndex[h.trim().toUpperCase()] = i);

            const U_TC1 = tc1Label.toUpperCase();
const U_TC2 = tc2Label.toUpperCase();

// Normalize headers so "A\n(B)" matches "A (B)"
const _normHdr_ = (s) => String(s || '').replace(/\s+/g, ' ').trim().toUpperCase();


const infoBlock = new Set([
  'EMPLOYEE ID','EMPLOYEE NAME','STATUS','CONTRACT TYPE','DATE HIRED','DATE SEPARATED',
  'WORKING DAYS PER YEAR','PAY BASIS','PAYROLL GROUP',
  'NO.','HR','HRSTATUS','SOFTWARE','SERVICES OFFERED',
  'LAST NAME','FIRST NAME','MIDDLE NAME','POSITION / JOB TITLE',
  'START DATE','TODAY','TENURE','COMPANY EMAIL','ADDRESS','BIRTHDAY',
  'AGE','GENDER','CIVIL STATUS','CONTACT NO.','PWD','PERSONAL EMAIL',
  'CONTACT PERSON IN CASE OF EMERGENCY','RELATION','TIN','SSS','PAG-IBIG','PHILHEALTH','HMO','HMO CARD NO.',
  'POLICY INSURANCE NO.','JOB OFFER','EMPLOYMENT CONTRACT','NBI CLEARANCE','2X2 PIC','ITR/2316','TIN ID',
  'SSS FORM E-1','PHILHEALTH ID','HDMF/PAGIBIG ID','COE','MEDICAL RESULT','BIRTH CERT','TOR/DIPLOMA','MARRIAGE CERT',
  "CHILDREN'S BIRTH CERT",'MONTH YEAR START (FOR CSM TRACKER)','INTERNAL/EXTERNAL (FOR CSM TRACKER)',
  'WITHHOLDING TAX (FOR CONSULTANTS)',
  'APPLIED FOR RETIREMENT', 'BANK ACCOUNT NUMBER','BANK NAME','BANK ACCOUNT NAME','DISBURSING BANK','SEPARATION DATE','REGULARIZATION DATE',
  U_TC1, U_TC2
].map(_normHdr_));



// Keep these as pure text (dimensions), not pay components
const keepText = new Set([U_TC1,'PAYROLL GROUP',U_TC2].map(_normHdr_));


// ======== HEADER ORDER (fixed) ========
// 1) Identity then period
const preCols = [
  'Employee ID','Employee Name',
  tc1Label,'Payroll Group',tc2Label,
  'Period','From','To','Crediting Date','Payroll Month'
];



      // 2) Base earnings first
      const baseEarningCols = [
        'BASIC PAY','NON-TAXABLE ALLOWANCE','DEMINIMIS ALLOWANCE','MONTHLY TAXABLE ALLOWANCE',
        'ALLOWANCE','REGULAR OT PAY','NIGHT DIFFERENTIAL','HOLIDAY PAY','REST DAY PAY','ABSENCES','LATES'
      ];
      // keep only columns that actually exist in the Masterfile header row
// keep only columns that actually exist in the Masterfile header row
const presentMasterCols = new Set(mHeaders.map(h => String(h).trim()));

// âœ… Track presence and drop the computed column from consideration entirely
const HAS_BASIC = presentMasterCols.has('BASIC PAY');
const HAS_COMP  = presentMasterCols.has('COMPUTED BASIC PAY');
if (HAS_COMP) presentMasterCols.delete('COMPUTED BASIC PAY');

const filteredBaseEarningCols = baseEarningCols.filter(h => presentMasterCols.has(h));

// âœ… If only "Computed Basic Pay" existed, still expose a single "BASIC PAY" column
if (!HAS_BASIC && HAS_COMP && !filteredBaseEarningCols.includes('BASIC PAY')) {
  filteredBaseEarningCols.unshift('BASIC PAY');
}


// --- Categorize Masterfile dynamic columns by component map
const masterDynamicColsEarnings = [];   // MF extra earnings (OT, bonus, etc.)
const masterDynamicDeductionCols = [];  // MF deductions (loans/HMO/etc.)
const masterDynamicAdditionCols  = [];  // MF net-only additions

const isInfo = (h) => infoBlock.has(String(h || '').trim().toUpperCase());

Object.values(componentMap)
  .map(r => r?.name).filter(Boolean)
  .forEach(col => {
    const key = String(col).trim();
  const up = _normHdr_(key);
  if (infoBlock.has(up) || keepText.has(up)) return;



    // â›” never include the computed column as its own header
    if (/^COMPUTED\s*BASIC\s*PAY$/i.test(key)) return;

    if (!presentMasterCols.has(key)) return;

    // skip system totals
    if (/^(GROSS PAY|TAXABLE INCOME|WITHHOLDING TAX|SSS (EE|ER|EC)|PHILHEALTH (EE|ER)|PAG-IBIG (EE|ER))$/i.test(key)) return;

    const cat = (_classifyComponent_(key, componentMap) || '').toLowerCase();

    if (cat === 'deduction' || /LOAN|DEDUCTION|DEDUK|CALAMITY|CHARGE|ADVANCE|HMO|RECOVERY/i.test(key)) {
      masterDynamicDeductionCols.push(key);
    } else if (cat === 'addition' || /NET[-\s]*ONLY|NET\s*ADD/i.test(key)) {
      masterDynamicAdditionCols.push(key);
    } else {
      // earnings-like: OT/bonus/allowances/etc.
      if (!baseEarningCols.includes(key)) masterDynamicColsEarnings.push(key);
    }
  });




      // 3) Adjustments â†’ earnings bucket by category (filled later)
      const addlEarningCols = [];   // from adjustments where cat âˆˆ {Basic Pay Related, Taxable Earning, Non-Taxable Earning}

      // 4) Core compute (pre-deduction)
      const coreCols = ['Gross Pay','SSS EE MC','SSS EE MPF','PhilHealth EE','Pag-IBIG EE','Taxable Income','Withholding Tax'];

      // 5) Deductions just before Net Pay
      const fixedDeductionHeaders = ['SSS LOAN','SSS CALAMITY LOAN','HDMF LOAN','HDMF CALAMITY LOAN','HMO DEDUCTION','OTHER DEDUCTIONS'];
      const dynamicAdditionCols = [];
      const dynamicDeductionCols = []; // from adjustments where cat = Deduction

      // 6) Final totals
      const postCols = ['Net Pay','SSS ER MC','SSS ER MPF','SSS EC','PhilHealth ER','Pag-IBIG ER'];

      // Build unique header in that order
      const seen = new Set();
      const pushUnique = (arr, col) => { if (!col) return; const k=String(col).trim(); if (!k || seen.has(k)) return; seen.add(k); arr.push(col); };

      // Pre-scan adjustment names by category for header placement
      const nameToCat = new Map();
const allAdjNamesSet = new Set();

adjustments.forEach(a => {
  const n = String(a.name || '').trim();
  if (!n) return;

  // âœ… Do not let system components participate in category-driven logic
  if (_isSystemComponentName_(n)) return;

  allAdjNamesSet.add(n);
  if (!nameToCat.has(n)) nameToCat.set(n, a.cat);
});

const allAdjNames = [...allAdjNamesSet];


      allAdjNames.forEach(n => {
         if (_isSystemComponentName_(n)) return;
  const cat = (nameToCat.get(n) || '').toLowerCase();
  if (cat === 'deduction') dynamicDeductionCols.push(n);
  else if (cat === 'addition') dynamicAdditionCols.push(n);
  else addlEarningCols.push(n);
      });

let fullHeader = [
  ...preCols,
  ...filteredBaseEarningCols,    // core fixed earnings
  ...masterDynamicColsEarnings,  // MF extra earnings (NOT deductions/additions)
  ...addlEarningCols,            // Inputs earnings buckets
  ...coreCols,                   // Gross/EE/Taxable/WTax
  ...masterDynamicAdditionCols,  // MF additions (net-only)
  ...dynamicAdditionCols,        // Inputs additions (net-only)
  ...fixedDeductionHeaders,      // fixed list
  ...masterDynamicDeductionCols, // MF deductions
  ...dynamicDeductionCols,       // Inputs deductions
  ...postCols
];



    // âœ… Deduplicate while preserving order
    fullHeader = [...new Set(fullHeader)];




      // ======== COMPUTATION ========
      const outRows = [];
      const total = rows.length;
      const startTime = new Date();
      const masterHeaderIndex = new Map(mHeaders.map((h, i) => [String(h).trim(), i]));

      // SPECIAL period logic
      const _periodPortion_ = (monthly, mode) => {
        if (IS_MONTHLY) return monthly;      
        if (partLabel === 'A') { if (mode === 'split') return monthly/2; if (mode === 'first') return monthly; return 0; }
        if (partLabel === 'B') { if (mode === 'split') return monthly/2; if (mode === 'second') return monthly; return 0; }
        return monthly;
      };
      const _getSignedForPeriod_ = (monthlyValue, mode, priorTaken = 0) =>
        _r2_(_periodPortion_(monthlyValue, mode) - (Number(priorTaken) || 0));

      rows.forEach((r, i) => {
  const dataMap = new Map();

  // âœ… Case-insensitive header lookups
  const empIdIdx  = headerIndex['EMPLOYEE ID'];
  const nameIdx   = headerIndex['EMPLOYEE NAME'];
  const hiredIdx  = headerIndex['DATE HIRED'];
  const sepIdx    = headerIndex['DATE SEPARATED'];

  if (empIdIdx == null || empIdIdx < 0 || nameIdx == null || nameIdx < 0) {
    throw new Error('Missing "EMPLOYEE ID" or "EMPLOYEE NAME" column in Masterfile Import.');
  }

  const empId = String(r[empIdIdx] || '').trim();
  const name  = String(r[nameIdx]  || '').trim();
  if (!empId || !name) return; // skip rows with no ID or Name

  // YTD "13th Month Pay and Other Benefits" before this run
const ytdOtherBefore = ytdOtherBenefitsMap.get(empId) || 0;

  if (partLabel === 'SPECIAL') {
    Logger.log(`ðŸŸ£ [SPECIAL] ${empId} | ${name}: using adjustments only (no Masterfile pull)`);
  }

  const hired = (hiredIdx != null && hiredIdx >= 0) ? _safeDate_(r[hiredIdx]) : null;
  const sep   = (sepIdx   != null && sepIdx   >= 0) ? _safeDate_(r[sepIdx])   : null;

        const activeStart = hired && hired > rangeStart ? hired : rangeStart;
        const activeEnd   = sep && sep < rangeEnd ? sep : rangeEnd;
        if (activeStart > activeEnd) return;

                // Month-to-date prior object (kept for places that expect an object, e.g. statutory internals)
const priorTaken = (takenMap && typeof takenMap.get === 'function') ? (takenMap.get(empId) || {}) : {};
// Numeric prior for THIS run (A/B same-part for non-stat; MTD for stat; MTD for non A/B)
const priorFor = (k) => _getPriorTakenForRun_(takenMap, takenByPt, empId, k, partLabel);



        const isFullPeriod = (!hired || hired <= rangeStart) && (!sep || sep >= rangeEnd);

        // STATUS: only inclusion flag
        const statusIdx = headerIndex['STATUS'];
        const statusVal = statusIdx > -1 ? String(r[statusIdx] || '').trim().toLowerCase() : '';
        if (statusVal && statusVal !== 'active') {
          // Not Active â†’ skip from payroll
          return;
        }

// CONTRACT TYPE: drives employee vs consultant/freelance behavior
const contractIdx = headerIndex['CONTRACT TYPE'];
const contractVal = contractIdx > -1 ? String(r[contractIdx] || '').trim().toLowerCase() : '';
const isConsultant = /freelance|contractor|consultant/.test(contractVal);

// Retirement flag from Masterfile â†’ drives SSS/PH/HDMF instead of age 60
const retireIdx = headerIndex['APPLIED FOR RETIREMENT'];
let isRetired = false;
if (retireIdx > -1) {
  const v = r[retireIdx];
  if (typeof v === 'boolean') {
    isRetired = v;
  } else {
    const s = String(v || '').trim().toUpperCase();
    isRetired = (s === 'TRUE');
  }
}

// Age from BIRTHDAY (kept for reference only; contributions now use retirement flag)
const birthdayIdx = headerIndex['BIRTHDAY'];
const birthdayVal = birthdayIdx > -1 ? _safeDate_(r[birthdayIdx]) : null;
const today = _stripTime(new Date());
let ageYears = 0;
if (birthdayVal) {
  ageYears = today.getFullYear() - birthdayVal.getFullYear();
  const mDiff = today.getMonth() - birthdayVal.getMonth();
  if (mDiff < 0 || (mDiff === 0 && today.getDate() < birthdayVal.getDate())) ageYears--;
}
// NOTE: no isOver60 logic anymore; retirement flag now controls statutories


// PWD flag â†’ no PhilHealth EE
const pwdIdx = headerIndex['PWD'];
const pwdRaw = pwdIdx > -1 ? String(r[pwdIdx] || '').trim().toUpperCase() : '';
const isPwd = (pwdRaw === 'Y' || pwdRaw === 'YES');

// NATIONALITY â†’ only HDMF (Pag-IBIG) is suppressed for non-Filipinos
const nationalityIdx = headerIndex['NATIONALITY'];
const nationalityRaw = nationalityIdx > -1
  ? String(r[nationalityIdx] || '').trim().toUpperCase()
  : '';
const isFilipino = nationalityRaw.indexOf('FILIPINO') !== -1;

// MWE flag â†’ no withholding tax computation
const mweIdx = headerIndex['MWE'];
let isMwe = false;
if (mweIdx > -1) {
  const v = r[mweIdx];
  if (typeof v === 'boolean') {
    isMwe = v;
  } else {
    const s = String(v || '').trim().toUpperCase();
    isMwe = (s === 'TRUE');
  }
}


const payBasisIdx = headerIndex['PAY BASIS'];
const payBasis = payBasisIdx > -1 ? String(r[payBasisIdx] || '').trim().toUpperCase() : 'MONTHLY';
const isDailyPayBasis = (payBasis === 'DAILY');

const basicIdx = headerIndex['BASIC PAY'];
const computedBasicIdx = headerIndex['COMPUTED BASIC PAY']; // optional override

const rawBasic = basicIdx > -1 ? _toNumber_(r[basicIdx]) : 0; // MONTHLY salary OR DAILY rate (if Pay Basis = DAILY)
const overrideBasic = computedBasicIdx > -1 ? _toNumber_(r[computedBasicIdx]) : 0;

// Attendance Days Worked applies ONLY for DAILY pay basis
const daysWorked = isDailyPayBasis ? (Number(attendanceDaysMap.get(empId)) || 0) : 0;

// Prior taken for reruns (same-part for non-statutory)
const priorBasicSamePart = Number(priorFor('BASIC PAY')) || 0;

// BASIC PAY to post this run (net of same-part prior if rerun)
const basicForRun = isDailyPayBasis
  ? _r2_(((overrideBasic > 0 ? overrideBasic : _r2_(rawBasic * daysWorked))) - priorBasicSamePart)
  : 0;

// Effective basic base used for statutory/tax bases:
// - default behavior for MONTHLY pay basis remains unchanged
// - for DAILY pay basis: use month-to-date Basic Pay AFTER this run
let baseMonthlySalary = overrideBasic > 0 ? overrideBasic : rawBasic;
if (isDailyPayBasis) {
  const priorBasicMTD = _nCI_(takenMap.get(empId) || {}, 'BASIC PAY');
  baseMonthlySalary = _r2_(priorBasicMTD + basicForRun);
}


// For contributions base:
// - SSS & Pag-IBIG base will INCLUDE Basic-Pay-Related adjustments (policy change)
// - PhilHealth base will be ONLY the effective basic (no basic-related adds)


        const consIdx = headerIndex['WITHHOLDING TAX (FOR CONSULTANTS)'];
        const consultantTaxRate = consIdx > -1 ? _parsePercentOrNumber_(r[consIdx]) : 0;


        const getModeFor = (componentName) => {
          const key = String(componentName || '').trim();
          const override = cfg.employeeOverrides.get(`${empId}-${key}`);
          if (override) return override;
          return cfg.componentModes.get(key) || 'split';
        };

        // 1ï¸âƒ£ Pull masterfile components â€” skip entirely for SPECIAL payrolls
    if (partLabel !== 'SPECIAL') {
  fullHeader.forEach(header => {
    const up = _normHdr_(header);
    const idx = masterHeaderIndex.get(header);
    if (idx == null) return;

    // Always keep identity/text fields
    if (keepText.has(up)) { dataMap.set(header, r[idx] || ''); return; }
    if (infoBlock.has(up)) return;

  // â›” Safety: never process a computed-basic header even if it sneaks in
if (up === 'COMPUTED BASIC PAY') return;

// ðŸ” BASIC PAY: if a COMPUTED BASIC PAY override is present (overrideBasic > 0),
//     treat it as per-cutoff and DO NOT split for A/B.
//     Whatever is in the Masterfile will be used as-is (minus priorTaken, if any).
if (up === 'BASIC PAY') {
  if (isDailyPayBasis) {
    dataMap.set(header, _r2_(basicForRun));
    return;
  }

  if (overrideBasic > 0) {
    const prior = priorFor(header);
    const valueForPeriod = _r2_(overrideBasic - (Number(prior) || 0));
    dataMap.set(header, valueForPeriod);
    return;
  }
}


// âœ… For all other components (and BASIC PAY when there is no override),
//     use the standard monthlyâ†’per-period logic.
const monthlyValue = (up === 'BASIC PAY')
  ? baseMonthlySalary
  : _toNumber_(r[idx]);

const mode  = getModeFor(header);
  const prior = priorFor(header);

if (isDeductionComponent(header)) {
  const signedVal = _getSignedForPeriod_(monthlyValue, mode, prior);
  dataMap.set(header, signedVal);
} else {
  const valueForPeriod = _getSignedForPeriod_(monthlyValue, mode, prior);
  dataMap.set(header, _r2_(valueForPeriod));
}

  });
} else {
      // SPECIAL payroll â†’ only copy identity fields (no pay components)
['Employee ID','Employee Name', tc1Label,'Payroll Group',tc2Label]
  .forEach(f => {
    const idx = masterHeaderIndex.get(f);
    if (idx != null) dataMap.set(f, r[idx] || '');
  });


    }



       // 2) Apply adjustments (by category) and capture sums that affect bases
const myAdj = adjustments.filter(a => a.empId === empId);
let basicRelatedSum   = 0;  // affects SSS/PI base and taxable
let basicRelatedSumPH = 0;  // affects PH base (EXCEPT absence/tardiness)
let taxableOnlySum    = 0;  // taxable-only (no contributions base)
let nonTaxableSum     = 0;  // gross-only
let deductionSum      = 0;  // deductions bucket (post-tax, pre-Net)
let additionSum       = 0;


// âœ… NEW: system component adjustments that should MERGE into SSS/PH/PI/WTax
const sysAdj = {
  'SSS EE MC': 0,
  'SSS EE MPF': 0,
  'PhilHealth EE': 0,
  'Pag-IBIG EE': 0,

  'SSS ER MC': 0,
  'SSS ER MPF': 0,
  'SSS EC': 0,
  'PhilHealth ER': 0,
  'Pag-IBIG ER': 0,

  'Withholding Tax': 0
};


myAdj.forEach(adj => {
  const prior = priorFor(adj.name);

  const valueForRun = _r2_((adj.amt || 0) - prior);
  const cat = (adj.cat || '').toLowerCase();

  // âœ… Map "philhealth", "PAGIBIG", "WITHHOLDING TAX", etc. into canonical system keys
  const sysKey = _canonicalSysKey_(adj.name);
  if (sysKey && Object.prototype.hasOwnProperty.call(sysAdj, sysKey)) {
    sysAdj[sysKey] += valueForRun;
    // Show under the canonical header so it merges with the main line
    dataMap.set(sysKey, (_n_(dataMap.get(sysKey)) + valueForRun));
    return; // do NOT feed into basic/taxable/non-tax/add/ded buckets
  }

  // Normal adjustments
  dataMap.set(adj.name, valueForRun);

  const catLower = String(cat || '').toLowerCase();

// --- SSS base adders (forced headers + mapped Basic Pay Related) ---
if (_isSssBaseComponent_(adj.name, catLower)) {
  basicRelatedSum += valueForRun;
}

// --- PhilHealth base adders (forced Salary Adjustment + mapped Basic Pay Related except Abs/Tard) ---
if (_isPhilHealthBaseComponent_(adj.name, catLower)) {
  basicRelatedSumPH += valueForRun;
}


  else if (cat === 'taxable earning')     taxableOnlySum  += valueForRun;
  else if (
  cat === 'non-taxable earning' ||
  cat === 'non-taxable earning - de minimis' ||
  cat === 'non-taxable earning - other'
) nonTaxableSum += valueForRun;
  else if (cat === 'addition')            additionSum     += valueForRun;
  else if (cat === 'deduction')           deductionSum    += valueForRun; // usually negative
});




// 3) Statutory contributions â€” base includes BASIC PAY RELATED adjustments
let baseForSSS_PI = baseMonthlySalary + basicRelatedSum;


// PhilHealth = basic + basic-related (except absence/tardiness)
let baseForPH = baseMonthlySalary + basicRelatedSumPH;
let baseForPHIsMonthly = false;

// âœ… SEMI-MONTHLY B: use (A + B) actuals as the MONTHLY base
const isSemiPayFreq = String(cfg.PAY_FREQUENCY || '').toUpperCase().indexOf('SEMI') !== -1;

// âœ… use dedicated vars here (DO NOT use "priorA" because it is declared later in this function)
let priorA_stat = {};
let basicA_stat = 0;
let basicB_stat = 0;

if (isSemiPayFreq && String(partLabel || '').toUpperCase() === 'B' && !isDailyPayBasis) {

  const empIdTrim = String(empId || '').trim();

  // takenByPtSigned is { A: Map, B: Map, MTD: Map } but SIGNED (for monthly base rebuild)
const mapA = takenByPtSigned && takenByPtSigned.A;

  if (mapA && typeof mapA.get === 'function') {
    priorA_stat = mapA.get(empIdTrim) || mapA.get(empIdTrim.toUpperCase()) || {};
  }

  basicA_stat = _n_(
    (priorA_stat['BASIC PAY'] != null) ? priorA_stat['BASIC PAY']
    : (priorA_stat['Basic Pay'] != null) ? priorA_stat['Basic Pay']
    : 0
  );

  let basicRelatedA_PH = 0;
Object.keys(priorA_stat || {}).forEach(k => {
  if (!k) return;
  if (_normHdr_(k) === 'BASIC PAY') return;

  const catLower = String(_classifyComponent_(k, componentMap) || '').toLowerCase();
  if (_isPhilHealthBaseComponent_(k, catLower)) {
    basicRelatedA_PH += _n_(priorA_stat[k]);
  }
});


  basicB_stat = _n_(dataMap.get('BASIC PAY'));

  // Monthly PH base = (A basic + A basic-related-PH) + (B basic + B basic-related-PH)
  baseForPH = (basicA_stat + basicRelatedA_PH) + (basicB_stat + basicRelatedSumPH);
  baseForPHIsMonthly = true;
  // --- also build SSS/HDMF monthly base in semi-B ---
  let basicRelatedA_SSSPI = 0;
Object.keys(priorA_stat || {}).forEach((k) => {
  if (!k) return;
  if (_normHdr_(k) === 'BASIC PAY') return; // avoid double count

  const catLower = String(_classifyComponent_(k, componentMap) || '').trim().toLowerCase();
  if (_isSssBaseComponent_(k, catLower)) {
    basicRelatedA_SSSPI += _n_(priorA_stat[k]);
  }
});



  // Month base = (A basic + A basic-related) + (B basic + B basic-related)
  baseForSSS_PI = (basicA_stat + basicRelatedA_SSSPI) + (basicB_stat + basicRelatedSum);


}









// âœ… Prevent double-splitting when basis is already monthly
if (computedBasicIdx > -1 && overrideBasic > 0) {
  const phMode = String(getModeFor('PhilHealth EE') || '').trim().toLowerCase();
  if (phMode === 'split' && !baseForPHIsMonthly) baseForPH = baseForPH * 2;
}






// Employee-only + not retired + not SPECIAL
let stat = (computeContrib && partLabel !== 'SPECIAL' && !isConsultant && !isRetired)
  ? _computeStatutoryForPeriod_({
    baseMonthlySSSPI: baseForSSS_PI,
    baseMonthlyPH:    baseForPH,
    getModeFor,
    sssTable,
    isFullPeriod,
    priorTaken,
    partLabel,
    empId,
  periodLabel,cfg,
    isDailyPayBasis: !!isDailyPayBasis // âœ… NEW (use your per-employee flag)
  })

  : { sssEe: 0, sssEr: 0, sssEc: 0, phEe: 0, phEr: 0, piEe: 0, piEr: 0 };

// PWD â†’ no PhilHealth EE deduction (ER still recorded)
// (only relevant while not retired)
if (isPwd && !isConsultant && !isRetired) {
  stat.phEe = 0;
}

// Non-Filipino â†’ no HDMF (Pag-IBIG) EE/ER, but SSS & PH still apply
// (only relevant while not retired)
if (!isFilipino && !isConsultant && !isRetired) {
  stat.piEe = 0;
  stat.piEr = 0;
}



// âœ… Merge system-component adjustments into statutory lines (BREAKDOWN-FIRST)
const sssEeMcAdj = sysAdj['SSS EE MC']      || 0;
const sssEeMpfAdj = sysAdj['SSS EE MPF']   || 0;
const phEeAdj    = sysAdj['PhilHealth EE'] || 0;
const piEeAdj    = sysAdj['Pag-IBIG EE']   || 0;

const sssErMcAdj = sysAdj['SSS ER MC']     || 0;
const sssErMpfAdj = sysAdj['SSS ER MPF']  || 0;
const sssEcAdj   = sysAdj['SSS EC']        || 0;
const phErAdj    = sysAdj['PhilHealth ER'] || 0;
const piErAdj    = sysAdj['Pag-IBIG ER']   || 0;

// EE lines stored NEGATIVE
dataMap.set('SSS EE MC',     _r2_(-stat.sssEeMc  + sssEeMcAdj));
dataMap.set('SSS EE MPF',    _r2_(-stat.sssEeMpf + sssEeMpfAdj));
dataMap.set('PhilHealth EE', _r2_(-stat.phEe     + phEeAdj));
dataMap.set('Pag-IBIG EE',   _r2_(-stat.piEe     + piEeAdj));

// Keep legacy total populated (hidden), derived from breakdown
dataMap.set('SSS EE', _r2_(
  _n_(dataMap.get('SSS EE MC')) + _n_(dataMap.get('SSS EE MPF'))
));

// ER/EC remain POSITIVE
dataMap.set('SSS ER MC',     _r2_(stat.sssErMc   + sssErMcAdj));
dataMap.set('SSS ER MPF',    _r2_(stat.sssErMpf  + sssErMpfAdj));
dataMap.set('SSS EC',        _r2_(stat.sssEc     + sssEcAdj));
dataMap.set('PhilHealth ER', _r2_(stat.phEr      + phErAdj));
dataMap.set('Pag-IBIG ER',   _r2_(stat.piEr      + piErAdj));

// Keep legacy total populated (hidden), derived from breakdown
dataMap.set('SSS ER', _r2_(
  _n_(dataMap.get('SSS ER MC')) + _n_(dataMap.get('SSS ER MPF'))
));

        // 4) TAXABLE INCOME
let taxableEarnings = 0;

// Base taxable earnings from Masterfile components
mHeaders.forEach(h => {
  const cat = _classifyComponent_(h, componentMap);
  const val = _n_(dataMap.get(h));
  if (cat === 'Basic Pay Related' || cat === 'Taxable Earning') {
    taxableEarnings += val;
  }
});

// DEMINIMIS & NON-TAXABLE ALLOWANCE explicitly excluded from tax base

// Add BASIC PAY RELATED adjustments (pos/neg):
taxableEarnings += basicRelatedSum;

// Add Taxable-only adjustments:
taxableEarnings += taxableOnlySum;

// ðŸ”¹ 13th Month Pay & Other Benefits â€“ YTD 90k exemption
let otherBenefitsThisRun = 0;
fullHeader.forEach(h => {
  const v = _n_(dataMap.get(h));
  if (!v) return;

  const catFromInputs = (nameToCat.get(h) || '').toLowerCase();
  const catFromMap    = (_classifyComponent_(h, componentMap) || '').toLowerCase();
  const cat           = catFromInputs || catFromMap;

  if (cat === '13th month pay and other benefits') {
    otherBenefitsThisRun += v;
  }
});

let taxableOtherBenefits      = 0;
let nonTaxableOtherBenefits   = 0;
const cap                     = OTHER_BENEFITS_EXEMPT_YTD; // 90,000

// ðŸ”´ FIX: Correctly compute remaining exemption based on YTD usage
// ytdOtherBefore is loaded at the start of the loop from history
const priorYtdTotal = Math.abs(ytdOtherBenefitsMap.get(empId) || 0);
const remainingExempt = Math.max(0, cap - priorYtdTotal);

if (otherBenefitsThisRun !== 0) {
  const runAbs = Math.abs(otherBenefitsThisRun);
  
  // The taxable portion is whatever exceeds the *remaining* exemption
  const taxableAbs = Math.max(0, runAbs - remainingExempt);
  const nonTaxableAbs = runAbs - taxableAbs;

  const sign = otherBenefitsThisRun >= 0 ? 1 : -1;
  taxableOtherBenefits    = sign * taxableAbs;
  nonTaxableOtherBenefits = sign * nonTaxableAbs;
}

// Add taxable portion of 13th month / other benefits
taxableEarnings += taxableOtherBenefits;


// EE contributions reduce taxable income (use actual EE lines from dataMap)
const sssEeActual =
  Math.abs(_n_(dataMap.get('SSS EE MC'))) +
  Math.abs(_n_(dataMap.get('SSS EE MPF')));

const phEeActual  = Math.abs(_n_(dataMap.get('PhilHealth EE')));
const piEeActual  = Math.abs(_n_(dataMap.get('Pag-IBIG EE')));

const taxableIncomeForPeriod = Math.max(
  0,
  taxableEarnings - sssEeActual - phEeActual - piEeActual
);
dataMap.set('Taxable Income', _r2_(taxableIncomeForPeriod));


          const priorMTD = takenMap.get(empId) || {};
  const priorA   = (takenByPt.A.get(empId) || {});




// 5) Withholding Tax
let annualProjected      = null;
let annualRateFor13th    = null;
let taxRegularPortion    = null;
let tax13thPortion       = null;

if (computeTax && partLabel !== 'SPECIAL' && !isMwe) {
  if (isConsultant) {
    // âœ… Consultants/freelancers: WTax = taxable income for this period Ã— consultant rate
    // (includes BASIC + Basic Pay Related + Taxable Earning components already rolled into taxableIncomeForPeriod)
    const t = _r2_(Math.max(0, _n_(taxableIncomeForPeriod)) * consultantTaxRate);
    dataMap.set('Withholding Tax', -t);
    taxRegularPortion = Math.abs(t); // treat full as "regular" for debug
  } else {
    const taxable13th = _n_(taxableOtherBenefits);
    const regularTaxable = _r2_(
      (Number(taxableIncomeForPeriod) || 0) - taxable13th
    );

    // Decide whether we can use the annual brackets; if not, fall back to old behavior.
    let useAnnualRate        = false;
    let annualRate           = 0;
    let annualProjectedLocal = null;

    if (taxable13th) {
      annualProjectedLocal = _estimateAnnualProjectedTaxable_(
        empId,
        regularTaxable,
        cfg && cfg.PAY_FREQUENCY,
        ytdTaxableIncomeMap
      ) + Math.max(0, taxable13th);  // âž• include current run taxable 13th / other benefits

      annualRate = _lookupAnnualRateFor13th_(annualProjectedLocal, bir);
      if (annualRate && annualRate > 0) useAnnualRate = true;

      annualProjected   = annualProjectedLocal;
      annualRateFor13th = annualRate;
    }

    if (!useAnnualRate) {
      // Fallback: original behavior â€” tax the full taxable income via the table.
      _applyWithholdingTax_(dataMap, {
        empId,
        periodLabel,
        isFreelance: false,
        consultantTaxRate,
        taxableIncomeForPeriod,
        priorA,
        priorMTD,
        partLabel,
        isFullPeriod,
        cfg,
        bir
      });

      const totalTax = Math.abs(_n_(dataMap.get('Withholding Tax')));
      taxRegularPortion = totalTax;
      tax13thPortion    = null;
    } else {
      // New behavior:
      //   1) Regular taxable income â†’ withholding table (semi/monthly, including prior A/B).
      //   2) Taxable 13th month / other benefits â†’ annual marginal rate.
      _applyWithholdingTax_(dataMap, {
        empId,
        periodLabel,
        isFreelance: false,
        consultantTaxRate,
        taxableIncomeForPeriod: regularTaxable,
        priorA,
        priorMTD,
        partLabel,
        isFullPeriod,
        cfg,
        bir
      });

      const taxRegular = Math.abs(_n_(dataMap.get('Withholding Tax')));
      const tax13th    = _r2_(Math.abs(taxable13th) * annualRate);
      const totalTax   = _r2_(taxRegular + tax13th);

      dataMap.set('Withholding Tax', -totalTax);

      taxRegularPortion = taxRegular;
      tax13thPortion    = tax13th;
    }
  }
} else {
  dataMap.set('Withholding Tax', 0);
}

        // âœ… Merge any "Withholding Tax" adjustments captured from Inputs
const wtaxAdj = sysAdj['Withholding Tax'] || 0;
if (wtaxAdj) {
  dataMap.set('Withholding Tax', _r2_(_n_(dataMap.get('Withholding Tax')) + wtaxAdj));
}



        // 6) GROSS & NET PAY
        // Gross pay = positive earnings + non-taxable earnings + (negatives for absences/lates)
        // Deductions (including all â€œDeductionâ€ category adjustments) are NOT part of gross; they reduce Net only.
        let grossPay = 0;
        let totalDeductions = 0;

        // Add all master positive earnings (excluding tax markers & EE/ER lines) and include non-taxable
        // Add all master positive earnings (excluding tax markers & EE/ER lines) and include non-taxable
const nonEarningCols = new Set([
  'WITHHOLDING TAX','TAXABLE INCOME','GROSS PAY','NET PAY','PHILHEALTH EE','PAG-IBIG EE','SSS EC','PHILHEALTH ER','PAG-IBIG ER','SSS EE','SSS ER',
  // âœ… NEW: Add breakdown columns to exclusion list so they aren't deducted twice
  'SSS EE MC', 'SSS EE MPF',
  'SSS ER MC', 'SSS ER MPF'
]);

        fullHeader.forEach(h => {
        const up = String(h).toUpperCase();
        const v  = _n_(dataMap.get(h));
        if (nonEarningCols.has(up)) return;
        


        // ðŸ”§ Merge categories from Inputs and Masterfile
        const catFromInputs = (nameToCat.get(h) || '').toLowerCase(); // from Inputs file
        const catFromMap    = (_classifyComponent_(h, componentMap) || '').toLowerCase();
        const cat           = catFromInputs || catFromMap;

                // âœ… Category-first flags (supports "addition - ..." / "deduction - ...")
        const isAdditionCat  = /^addition\b/i.test(cat);
        const isDeductionCat = /^deduction\b/i.test(cat);

        // âœ… Deduction ONLY if:
        // - explicitly deduction category, OR
        // - keyword matches AND it is NOT categorized as addition
        // âœ… Only apply keyword-based deduction detection when NO category is provided
const isDed = isDeductionCat ||
  (!cat && !isAdditionCat && /LOAN|DEDUCTION|DEDUK|CALAMITY|CHARGE|ADVANCE|HMO|BANK|RECOVERY/i.test(up));


        if (isDed) {
          // âœ… For deductions: negative = more deduction, positive = refund (adds to net)
          if (v < 0) totalDeductions += Math.abs(v);
          else if (v > 0) totalDeductions -= Math.abs(v);
          return; // handled as deduction; does not go into Gross
        }

        // âœ… Additions are net-only; do not add to gross and do not count as deduction here
        if (isAdditionCat) return;


  const isTaxableEarning    = (cat === 'taxable earning');
  const isNonTaxableEarning =
  cat === 'non-taxable earning' ||
  cat === 'non-taxable earning - de minimis' ||
  cat === 'non-taxable earning - other';

  if (isTaxableEarning || isNonTaxableEarning) {
    // Signed impact on Gross:
    // - positive = increase Gross
    // - negative = decrease Gross
    grossPay += v;
    return;
  }

  // Other earnings
  if (v > 0) grossPay += v;
  if (v < 0 && (_isUnworkedTime_(h) || _isSalaryAdjustment_(h))) grossPay += v;
});



        // Also ensure the categorized sums that didnâ€™t come from master columns are respected (already set into dataMap above)

        // âœ… Include categorized adjustment sums in gross/net calculations
        


        // ========================================================
        // ðŸ§¾ DEBUG LOGGING â€” EMPLOYEE PAY SUMMARY (TEMPORARY)
        // ========================================================
        if (false) {  // log every employee

          Logger.log(`=== PAYROLL TRACE: ${empId} | ${name} ===`);

          Logger.log(`Gross Pay: ${grossPay}`);

          const debugDeductions = [];
          fullHeader.forEach(h => {
            const up = String(h).toUpperCase();
            const v  = _n_(dataMap.get(h));
            const cat = (nameToCat.get(h.toUpperCase()) || '').toLowerCase();
            const isDed = cat === 'deduction' ||
            /LOAN|CHARGE|ADVANCE|HMO|DEDUCTION|AGADPAY|RECOVERY/i.test(h);
            if (isDed && v !== 0) debugDeductions.push({ name: h, val: v, cat });
          });

          Logger.log(`Deductions found (${debugDeductions.length}):`);
          debugDeductions.forEach(d => Logger.log(`â†’ ${d.name}: ${d.val} (${d.cat})`));

          Logger.log(`Total Deductions: ${totalDeductions}`);
          Logger.log(`Net Pay: ${grossPay - totalDeductions}`);
          Logger.log('=============================================');
        }
// ðŸ”¹ Sum all "Addition" category columns from either Masterfile or Inputs
let netOnlyAdditions = 0;
fullHeader.forEach(h => {
  const v = _n_(dataMap.get(h));
  if (!v) return;
  const catFromInputs = (nameToCat.get(h) || '').toLowerCase();
  const catFromMap    = (_classifyComponent_(h, componentMap) || '').toLowerCase();
  const cat = catFromInputs || catFromMap;
  if (/^addition\b/i.test(cat)) netOnlyAdditions += v;

});


            // --- Final Payroll Totals ---
        // Gross Pay already computed
        const sssEE  =
  _n_(dataMap.get('SSS EE MC')) +
  _n_(dataMap.get('SSS EE MPF'));

        const phEE   = _n_(dataMap.get('PhilHealth EE'));
        const piEE   = _n_(dataMap.get('Pag-IBIG EE'));
        const wtax   = _n_(dataMap.get('Withholding Tax'));

        // Total statutory deductions (all are negative in dataMap)
        // Withholding Tax is SIGNED (negative = deduct, positive = refund)
const wtaxSigned = _n_(dataMap.get('Withholding Tax'));

const statutoryDeductions =
  Math.abs(sssEE) +
  Math.abs(phEE) +
  Math.abs(piEE) +
  (wtaxSigned < 0 ? Math.abs(wtaxSigned) : -Math.abs(wtaxSigned));


        // Add manual/other deductions (loans, hmo, etc.)
        const totalAllDeductions = statutoryDeductions + totalDeductions;

        Logger.log(`${name} â†’ deductionSum=${deductionSum} â†’ totalDeductions now=${totalDeductions}`);

        // Compute Net Pay (gross less *all* deductions)
        const netPay = _r2_(grossPay - totalAllDeductions + netOnlyAdditions);

        dataMap.set('Gross Pay', _r2_(grossPay));
        dataMap.set('Net Pay', netPay);


        // 7) Metadata (as requested: no WorkingDaysBase, no Remarks, no Crediting Date)
           dataMap.set('Employee ID', empId);
dataMap.set('Employee Name', name);

const tc1Key = tc1Label.toUpperCase();
const tc2Key = tc2Label.toUpperCase();
const pgKey  = 'PAYROLL GROUP';

const tc1Idx = headerIndex[tc1Key];
const tc2Idx = headerIndex[tc2Key];
const pgIdx  = headerIndex[pgKey];

dataMap.set(tc1Label, tc1Idx > -1 ? (r[tc1Idx] || '') : '');
dataMap.set('Payroll Group', pgIdx > -1 ? (r[pgIdx] || '') : '');
dataMap.set(tc2Label, tc2Idx > -1 ? (r[tc2Idx] || '') : '');

        dataMap.set('Period', periodLabel);
        dataMap.set('From', _fmtDate_(rangeStart));
        dataMap.set('To', _fmtDate_(rangeEnd));
        // âœ… Crediting Date: use manual override if provided
        let creditingDate = String(form.creditingDate || '').trim();
        if (!creditingDate) {
          // Auto-compute if none provided
          creditingDate = _creditingDateFromRange_(rangeEnd, partLabel);
        }
        dataMap.set('Crediting Date', creditingDate);
        dataMap.set('Payroll Month', payrollMonth);

        outRows.push(fullHeader.map(h => dataMap.get(h) ?? ''));

        const pct = Math.min(98, Math.round(((i + 1) / total) * 100));
        const elapsed = (new Date() - startTime) / 1000;
        const eta = ((elapsed / (i + 1)) * (total - (i + 1))).toFixed(1);
        if (i % 2 === 0 || i + 1 === total)
          _progress(pct, `Phase 2/4: Computing employees (${i + 1}/${total})...`, `${eta}s`);

      });

_progress(98, "Phase 3/4: Writing payroll sheetâ€¦", "<1s>");
_writeComputation_(out, fullHeader, outRows);

_progress(99, "Phase 4/4: Formatting & computing totalsâ€¦", "<1s>");
formatPayrollSheetUnified_(out, true);  // includes totals

      // OLD (remove this)
    // out.setName(`Payroll computation - ${payrollMonth} ${partLabel}`);

       // out.setName(`Payroll computation - ${payrollMonth} ${partLabel}`);

    // âœ… Smart sheet naming that always respects the 100-char limit
    const entityLabel = (entityVal && entityVal !== 'ALL') ? entityVal : 'All Entities';
    const groupsArray = isAllGroups ? ['All Groups'] : [...selectedGroups];

    // 1) Start with full list of groups
    let groupsLabel = groupsArray.join(', ');
    let newName = `${groupsLabel} - ${periodLabel}`;

    // 2) If too long, compress the groups part:
    //    show first few, then "+N more"
    if (newName.length > 100 && !isAllGroups && groupsArray.length > 1) {
      const groupCount = groupsArray.length;
      if (groupCount <= 3) {
        groupsLabel = groupsArray.join(' + ');
      } else {
        groupsLabel = `${groupsArray.slice(0, 3).join(' + ')} +${groupCount - 3} more`;
      }
      newName = `${groupsLabel} - ${periodLabel}`;
    }

    // 3) If still too long, fall back to "<Entity> â€“ <N groups> - <Period>"
    if (newName.length > 100) {
      const groupCount = groupsArray.length;
      groupsLabel = isAllGroups ? 'All Groups' : `${groupCount} groups`;
      newName = `${groupsLabel} - ${periodLabel}`;
    }

    // 4) Final safety: hard-truncate to 100 chars so setName never errors
    if (newName.length > 100) {
      newName = newName.slice(0, 100);
    }

    out.setName(newName);



    // ðŸ”’ Protect the computation sheet immediately after creation/formatting
    protectComputationSheet_(out);

      _progress(100, "âœ… Payroll complete! (not yet posted)", "0s");
      return true;

      
    }

/**
 * MONTHLY payroll runner (full-month, no A/B splitting).
 * - Ignores split/first/second modes and treats components as FULL for the month.
 * - Uses monthly BIR brackets.
 * - Prior-taken still protects monthly caps.
 */
/**
 * MONTHLY payroll runner (full-month, no A/B splitting).
 * - Ignores split/first/second modes and treats components as FULL for the month.
 * - Uses monthly BIR brackets.
 * - Prior-taken still protects monthly caps.
 */
function _runPayrollMonthly_(form) {
  if (!form || !form.payrollCode || !form.startDate || !form.endDate)
    throw new Error('Incomplete payroll details for MONTHLY run.');

  // Normalize flags
  const computeContrib = form.computeContrib === true || String(form.computeContrib).toLowerCase() === 'true';
  const computeTax     = form.computeTax     === true || String(form.computeTax).toLowerCase() === 'true';

  // Context
    const rangeStart = new Date(form.startDate);
  const rangeEnd   = new Date(form.endDate);

  // ðŸ” Anchor month on TO date
  const anchorDate = rangeEnd;
  const tz         = Session.getScriptTimeZone();

  const year        = anchorDate.getFullYear();
  const month       = anchorDate.getMonth() + 1;
  const periodKey   = `${year}-${String(month).padStart(2, '0')}`;
  const partLabel   = 'M'; // monthly marker
  const periodLabel = `${periodKey}-M`;
  const payrollMonth = Utilities.formatDate(anchorDate, tz, 'MMMM yyyy');

  const activeSS = SpreadsheetApp.getActiveSpreadsheet();
  const cfg = _readSettings_();

  _progress(0, "Phase 1/4: Loading settings & source data...", "--");

  const { sourceSS, inputsSS } = _openLinkedFiles_(cfg, activeSS);

  // Build component map (for categorization)
  const componentMap = (() => {
    try { return _buildComponentMap_(cfg); } catch(e){ Logger.log(e); return {}; }
  })();

  // ---------- Entity + Group filter (same as core) ----------
  const entityVal = String(form.entity || '').trim().toUpperCase();
  const normalizeGroups = (g) => Array.isArray(g) ? g : String(g || '').split(/[\n,;|]/g).map(s=>s.trim()).filter(Boolean);
  const rawGroupList = normalizeGroups(form.payrollGroups || []);
  let selectedGroups = new Set(rawGroupList.map(g => String(g).trim().toUpperCase()));
  if (selectedGroups.size > 1 && selectedGroups.has('ALL')) selectedGroups.delete('ALL');
  const isAllGroups = selectedGroups.size === 0;

  const master = _mustGetSheet_(sourceSS, cfg.MASTER_SHEET_NAME);
  const allRows = master.getDataRange().getValues();
  if (allRows.length < 2) throw new Error(`No data found in ${cfg.MASTER_SHEET_NAME}.`);

  const rawHeaders = allRows[0].map(h => String(h || '').trim());

// --- Resolve dynamic tracking columns (dimension 1 & 2)
// For Masterfile, _resolveTrackingColumns_ will map columns D/E as dim1/dim2.
const {
  dim1Idx: entityIdx,
  dim1Label: tc1Label,
  dim2Label: tc2Label
} = _resolveTrackingColumns_(rawHeaders);

let groupIdx = _findHeaderFuzzy_(rawHeaders, [
  'Payroll Group',
  'PAYROLL GROUP',
  'Group',
  'Group Name'
]);


if (entityIdx === -1) {
  throw new Error('Missing Tracking/Entity column in Masterfile Import (dimension 1).');
}
if (groupIdx === -1) {
  throw new Error('Missing "Payroll Group" column in Masterfile Import.');
}


  const filteredRows = [allRows[0], ...allRows.slice(1).filter(r => {
    const ent = String(r[entityIdx] || '').trim().toUpperCase();
    const grp = String(r[groupIdx]  || '').trim().toUpperCase();
    const entMatch = !entityVal || entityVal === 'ALL' || ent === entityVal;
    if (isAllGroups) return entMatch;
    if (!grp) return false;
    return entMatch && selectedGroups.has(grp);
  })];
  if (filteredRows.length <= 1) {
    const sel = isAllGroups ? 'ALL' : [...selectedGroups].join(', ');
    throw new Error(`No employees found for Entity "${entityVal || 'ALL'}" and selected groups: ${sel}`);
  }

  const mVals    = filteredRows;
  const mHeaders = mVals[0].map(s => String(s || '').trim());
  const rows     = mVals.slice(1);
  const headerIndex = {};
  mHeaders.forEach((h, i) => headerIndex[h.trim().toUpperCase()] = i);

  // Tables & sheets
  const bir      = _loadBirTable_(_mustGetSheet_(activeSS, 'BIR_TABLE'));
  const sssTable = _loadSssTable_(_mustGetSheet_(activeSS, 'SSS_TABLE'));
    const out      = activeSS.getSheetByName('Payroll computation') || activeSS.insertSheet('Payroll computation');
  const inputsSheet = inputsSS ? (inputsSS.getSheetByName('Inputs') || inputsSS.getSheetByName('Adjustments')) : null;

// Load unified Inputs if present
let baseAdjustments = _loadInputsWithin_(inputsSheet);

// âœ… Always also read Absences_Tardiness directly (and force Basic Pay Related)
// This guarantees ABSENCE/TARDINESS are treated as Basic Pay Related even if Inputs is stale.
const absTardDirect = _loadAbsencesTardinessDirect_(inputsSS);

// Merge (same keying behavior as _loadInputsWithin_: empId + name case-insensitive)
const mergeMap = new Map();
baseAdjustments.forEach(a => mergeMap.set(`${a.empId}||${String(a.name).toLowerCase()}`, a));

absTardDirect.forEach(a => {
  const k = `${a.empId}||${String(a.name).toLowerCase()}`;
  const prev = mergeMap.get(k);

  if (prev) {
    // âœ… Prevent double-counting:
    // Absence/Tardiness may already exist in baseAdjustments (from Inputs/Adjustments loader),
    // so DO NOT add again. Only enforce category.
    prev.cat = 'Basic Pay Related';
    return;
  }

  // Not present yet â†’ add it (and enforce category)
  a.cat = 'Basic Pay Related';
  mergeMap.set(k, a);
});

baseAdjustments = Array.from(mergeMap.values());



const attendanceSheet = inputsSS ? inputsSS.getSheetByName('Attendance') : null;
const attendanceDaysMap = _loadAttendanceDaysMap_(attendanceSheet);


  // History for prior-taken protection
  // History for prior-taken protection
const hist      = _ensureHistorySheet_();
const takenMap  = _loadTakenThisMonth_(hist, periodKey);
const takenByPt = _loadTakenThisMonthByPart_(hist, periodKey);


  // ðŸ”¹ YTD 13th month & other benefits
const anchorYear = anchorDate.getFullYear();
const ytdOtherBenefitsMap = _loadYtdOtherBenefitsMap_(hist, anchorYear, componentMap);
const ytdTaxableIncomeMap  = _loadYtdTaxableIncomeMap_(hist, anchorYear);


  // ðŸ”¹ One-off adjustments from Inputs/Adjustment file
  

const payBasisMap = (() => {
  const map = new Map();
  const idxEmp = _findHeaderFuzzy_(mHeaders, ['Employee ID','Emp ID']);
  const idxPB  = _findHeaderFuzzy_(mHeaders, ['Pay Basis','PAY BASIS']);
  rows.forEach(r => {
    const eid = idxEmp > -1 ? String(r[idxEmp] || '').trim() : '';
    if (!eid) return;
    const pb = idxPB > -1 ? String(r[idxPB] || '').trim().toUpperCase() : '';
    map.set(eid, pb || 'MONTHLY');
  });
  return map;
})();


  // ðŸ”¹ Recurring Adjustments from Masterfile (sheet: "Recurring Adjustments")
  // - For monthly runs, Mode is ignored â†’ always full Amount per payroll
  // - Maximum Amount still respected using PAYROLL_HISTORY
  const recurringAdjustments = _loadRecurringAdjustments_(sourceSS, {
    rangeStart,
    rangeEnd,
    partLabel,
    periodKey,
    hist
  });

  // âœ… Combined adjustments used in computation
  const adjustments = [...baseAdjustments, ...recurringAdjustments];


  // Header plan
    // Header plan
const U_TC1 = tc1Label.toUpperCase();
const U_TC2 = tc2Label.toUpperCase();

const keepText = new Set([U_TC1,'PAYROLL GROUP',U_TC2]);
const infoBlock = new Set([
  'EMPLOYEE ID','EMPLOYEE NAME','STATUS','CONTRACT TYPE','DATE HIRED','DATE SEPARATED',
  'WORKING DAYS PER YEAR','PAY BASIS','PAYROLL GROUP',
  'NO.','HR','HRSTATUS','SOFTWARE','SERVICES OFFERED',
  'LAST NAME','FIRST NAME','MIDDLE NAME','POSITION / JOB TITLE',
  'START DATE','TODAY','TENURE','COMPANY EMAIL','ADDRESS','BIRTHDAY',
  'AGE','GENDER','CIVIL STATUS','CONTACT NO.','PWD','PERSONAL EMAIL',
  'CONTACT PERSON IN CASE OF EMERGENCY','RELATION','TIN','SSS','PAG-IBIG','PHILHEALTH','HMO','HMO CARD NO.',
  'POLICY INSURANCE NO.','JOB OFFER','EMPLOYMENT CONTRACT','NBI CLEARANCE','2X2 PIC','ITR/2316','TIN ID',
  'SSS FORM E-1','PHILHEALTH ID','HDMF/PAGIBIG ID','COE','MEDICAL RESULT','BIRTH CERT','TOR/DIPLOMA','MARRIAGE CERT',
  "CHILDREN'S BIRTH CERT",'MONTH YEAR START (FOR CSM TRACKER)','INTERNAL/EXTERNAL (FOR CSM TRACKER)',
  'WITHHOLDING TAX (FOR CONSULTANTS)','BANK NAME','BANK ACCOUNT NUMBER','BANK ACCOUNT NAME','DISBURSING BANK','SEPARATION DATE','REGULARIZATION DATE',
  'APPLIED FOR RETIREMENT',   // <<< NEW
  U_TC1, U_TC2
]);


const preCols = [
  'Employee ID','Employee Name',
  tc1Label,'Payroll Group',tc2Label,
  'Period','From','To','Crediting Date','Payroll Month'
];



  const baseEarningCols = [
    'BASIC PAY','NON-TAXABLE ALLOWANCE','DEMINIMIS ALLOWANCE','MONTHLY TAXABLE ALLOWANCE',
    'ALLOWANCE','REGULAR OT PAY','NIGHT DIFFERENTIAL','HOLIDAY PAY','REST DAY PAY','ABSENCES','LATES'
  ];
  const presentMasterCols = new Set(mHeaders.map(h => String(h).trim()));

  // === Dynamic masterfile columns (same logic as core runner) ===
  const masterDynamicColsEarnings = [];
const masterDynamicDeductionCols = [];
const masterDynamicAdditionCols  = [];

mHeaders.forEach(h => {
  const key = String(h).trim();
  const up  = key.toUpperCase();

    // âœ… HARD EXCLUDE: never treat tracker/info fields as pay components
  if (infoBlock.has(up) || keepText.has(up)) return;


  // skip system totals
  if (/^(GROSS PAY|TAXABLE INCOME|WITHHOLDING TAX|SSS (EE|ER|EC)|PHILHEALTH (EE|ER)|PAG-IBIG (EE|ER))$/.test(up))
    return;

  // detect masterfile deductions
  if (/LOAN|DEDUCTION|DEDUK|CALAMITY|CHARGE|ADVANCE|HMO|RECOVERY/i.test(up)) {
    masterDynamicDeductionCols.push(key);
    return;
  }

  // detect masterfile net-only additions
  if (/NET[-\s]*ONLY|NET\s*ADD/i.test(up)) {
    masterDynamicAdditionCols.push(key);
    return;
  }

  
});


  // Filter base earning cols to actual headers
  const filteredBaseEarningCols = baseEarningCols.filter(h => presentMasterCols.has(h));

  const nameToCat = new Map();
const allAdjNamesSet = new Set();

adjustments.forEach(a => {
  const n = String(a.name || '').trim();
  if (!n) return;

  // âœ… Do not let system components participate in category-driven logic
  if (_isSystemComponentName_(n)) return;

  allAdjNamesSet.add(n);
  if (!nameToCat.has(n)) nameToCat.set(n, a.cat);
});

const allAdjNames = [...allAdjNamesSet];


const addlEarningCols = [];
const dynamicAdditionCols = [];
const dynamicDeductionCols = [];
allAdjNames.forEach(n => {
  // Skip SSS/PhilHealth/Pag-IBIG/WTax here, handled via sysAdj
  if (_isSystemComponentName_(n)) return;

  const cat = (nameToCat.get(n) || '').toLowerCase();
  if (cat === 'deduction') dynamicDeductionCols.push(n);
  else if (cat === 'addition') dynamicAdditionCols.push(n);      // Net-only adders (not in Gross)
  else addlEarningCols.push(n);                                   // Basic/Taxable/Non-taxable earnings
});



  const coreCols = ['Gross Pay','SSS EE MC','SSS EE MPF','PhilHealth EE','Pag-IBIG EE','Taxable Income','Withholding Tax'];


const fixedDeductionHeaders = [
  'SSS LOAN','SSS CALAMITY LOAN',
  'HDMF LOAN','HDMF CALAMITY LOAN',
  'HMO DEDUCTION','OTHER DEDUCTIONS'
];

const postCols = ['Net Pay','SSS ER MC','SSS ER MPF','SSS EC','PhilHealth ER','Pag-IBIG ER'];



// âœ… MONTHLY header now aligns with CORE:
// - preCols
// - base earnings
// - master dynamic earnings
// - Inputs earnings
// - core cols
// - master net-only additions
// - Inputs net-only additions
// - fixed + dynamic deductions
// - post cols
let fullHeader = [...new Set([
  ...preCols,
  ...filteredBaseEarningCols,    // basic pay + standard earnings
  ...masterDynamicColsEarnings,  // extra MF earnings
  ...addlEarningCols,            // Inputs earnings (Basic/Taxable/Non-taxable)
  ...coreCols,
  ...masterDynamicAdditionCols,  // MF net-only additions
  ...dynamicAdditionCols,        // Inputs net-only additions
  ...fixedDeductionHeaders,
  ...masterDynamicDeductionCols, // MF deductions
  ...dynamicDeductionCols,       // Inputs deductions
  ...postCols
])];



  // Compute rows
  const outRows = [];
  const total = rows.length;
  const startTime = new Date();
  const masterHeaderIndex = new Map(mHeaders.map((h, i) => [String(h).trim(), i]));

  // Helper: in MONTHLY we force FULL month for components
  const getModeFor = (_componentName) => 'full';

  const _getSignedForMonth_ = (monthlyValue, prior = 0) => _r2_( (Number(monthlyValue) || 0) - (Number(prior) || 0) );

  rows.forEach((r, i) => {
  const dataMap = new Map();

  const empIdIdx  = headerIndex['EMPLOYEE ID'];
  const nameIdx   = headerIndex['EMPLOYEE NAME'];
  const hiredIdx  = headerIndex['DATE HIRED'];
  const sepIdx    = headerIndex['DATE SEPARATED'];

  if (empIdIdx == null || empIdIdx < 0 || nameIdx == null || nameIdx < 0) {
    throw new Error('Missing "EMPLOYEE ID" or "EMPLOYEE NAME" column in Masterfile Import.');
  }

  const empId = String(r[empIdIdx] || '').trim();
  const name  = String(r[nameIdx]  || '').trim();
  if (!empId || !name) return;

  // YTD 13th month & other benefits before this payroll
const ytdOtherBefore = ytdOtherBenefitsMap.get(empId) || 0;


  const hired = (hiredIdx != null && hiredIdx >= 0) ? _safeDate_(r[hiredIdx]) : null;
  const sep   = (sepIdx   != null && sepIdx   >= 0) ? _safeDate_(r[sepIdx])   : null;

    const activeStart = hired && hired > rangeStart ? hired : rangeStart;
    const activeEnd   = sep && sep < rangeEnd ? sep : rangeEnd;
    if (activeStart > activeEnd) return;

        // Month-to-date prior object (kept for places that expect an object, e.g. statutory internals)
const priorTaken = (takenMap && typeof takenMap.get === 'function') ? (takenMap.get(empId) || {}) : {};
// Numeric prior for THIS run (A/B same-part for non-stat; MTD for stat; MTD for non A/B)
const priorFor = (k) => _getPriorTakenForRun_(takenMap, takenByPt, empId, k, partLabel);




    // STATUS â†’ inclusion only
const statusIdx = headerIndex['STATUS'];
const statusVal = statusIdx > -1 ? String(r[statusIdx] || '').trim().toLowerCase() : '';
if (statusVal && statusVal !== 'active') {
  return; // skip non-active employees
}

// CONTRACT TYPE for employee vs consultant/freelance
const contractIdx = headerIndex['CONTRACT TYPE'];
const contractVal = contractIdx > -1 ? String(r[contractIdx] || '').trim().toLowerCase() : '';
const isConsultant = /freelance|contractor|consultant/.test(contractVal);

// Retirement flag from Masterfile â†’ drives SSS/PH/HDMF instead of age 60
const retireIdx = headerIndex['APPLIED FOR RETIREMENT'];
let isRetired = false;
if (retireIdx > -1) {
  const v = r[retireIdx];
  if (typeof v === 'boolean') {
    isRetired = v;
  } else {
    const s = String(v || '').trim().toUpperCase();
    isRetired = (s === 'TRUE');
  }
}

// Age from BIRTHDAY (reference only; not used to stop statutories)
const birthdayIdx = headerIndex['BIRTHDAY'];
const birthdayVal = birthdayIdx > -1 ? _safeDate_(r[birthdayIdx]) : null;
const today = _stripTime(new Date());
let ageYears = 0;
if (birthdayVal) {
  ageYears = today.getFullYear() - birthdayVal.getFullYear();
  const mDiff = today.getMonth() - birthdayVal.getMonth();
  if (mDiff < 0 || (mDiff === 0 && today.getDate() < birthdayVal.getDate())) ageYears--;
}

// PWD flag
const pwdIdx = headerIndex['PWD'];
const pwdRaw = pwdIdx > -1 ? String(r[pwdIdx] || '').trim().toUpperCase() : '';
const isPwd = (pwdRaw === 'Y' || pwdRaw === 'YES');


// NATIONALITY â†’ only HDMF (Pag-IBIG) is suppressed for non-Filipinos
const nationalityIdx = headerIndex['NATIONALITY'];
const nationalityRaw = nationalityIdx > -1
  ? String(r[nationalityIdx] || '').trim().toUpperCase()
  : '';
const isFilipino = nationalityRaw.indexOf('FILIPINO') !== -1;

// MWE flag â†’ no withholding tax computation
const mweIdx = headerIndex['MWE'];
let isMwe = false;
if (mweIdx > -1) {
  const v = r[mweIdx];
  if (typeof v === 'boolean') {
    isMwe = v;
  } else {
    const s = String(v || '').trim().toUpperCase();
    isMwe = (s === 'TRUE');
  }
}


const payBasisIdx = headerIndex['PAY BASIS'];
const payBasis = payBasisIdx > -1 ? String(r[payBasisIdx] || '').trim().toUpperCase() : 'MONTHLY';
const isDailyPayBasis = (payBasis === 'DAILY');

const basicIdx = headerIndex['BASIC PAY'];
const computedBasicIdx = headerIndex['COMPUTED BASIC PAY'];

const rawBasic = basicIdx > -1 ? _toNumber_(r[basicIdx]) : 0;
const overrideBasic = computedBasicIdx > -1 ? _toNumber_(r[computedBasicIdx]) : 0;

const daysWorked = isDailyPayBasis ? (Number(attendanceDaysMap.get(empId)) || 0) : 0;

// Monthly runner uses MTD prior for netting
const priorBasic = Number(priorFor('BASIC PAY')) || 0;

const basicForRun = isDailyPayBasis
  ? _r2_(((overrideBasic > 0 ? overrideBasic : _r2_(rawBasic * daysWorked))) - priorBasic)
  : 0;

let baseMonthlySalary = overrideBasic > 0 ? overrideBasic : rawBasic;
if (isDailyPayBasis) {
  const priorBasicMTD = _nCI_(takenMap.get(empId) || {}, 'BASIC PAY');
  baseMonthlySalary = _r2_(priorBasicMTD + basicForRun);
}


    const consIdx = headerIndex['WITHHOLDING TAX (FOR CONSULTANTS)'];
    const consultantTaxRate = consIdx > -1 ? _parsePercentOrNumber_(r[consIdx]) : 0;

    // 1) Masterfile pay components (FULL month)
    fullHeader.forEach(header => {
      const up = String(header).toUpperCase();
      const idx = masterHeaderIndex.get(header);
      if (idx == null) return;

      if (keepText.has(up)) { dataMap.set(header, r[idx] || ''); return; }
      if (infoBlock.has(up)) return;

      // never process computed-basic header
      if (up === 'COMPUTED BASIC PAY') return;

      // BASIC PAY = computed override if present
      if (up === 'BASIC PAY' && isDailyPayBasis) {
  dataMap.set(header, _r2_(basicForRun));
  return;
}

const monthlyValue = (up === 'BASIC PAY')
  ? baseMonthlySalary
  : _toNumber_(r[idx]);


      const prior = priorFor(header);


      if (isDeductionComponent(header)) {
        dataMap.set(header, _getSignedForMonth_(monthlyValue, prior)); // negative applied later in totals
      } else {
        dataMap.set(header, _r2_(_getSignedForMonth_(monthlyValue, prior)));
      }
    });

    // 2) Inputs (aggregate) â€” affect bases
// 2) Inputs (aggregate) â€” affect bases
const myAdj = adjustments.filter(a => a.empId === empId);
let basicRelatedSum   = 0;
let basicRelatedSumPH = 0;  // affects PH base (EXCEPT absence/tardiness)
let taxableOnlySum    = 0;
let nonTaxableSum     = 0;
let deductionSum      = 0;
let additionSum       = 0;


// âœ… NEW: system component adjustments for SSS/PH/PI/WTax
const sysAdj = {
  'SSS EE MC': 0,
  'SSS EE MPF': 0,
  'PhilHealth EE': 0,
  'Pag-IBIG EE': 0,

  'SSS ER MC': 0,
  'SSS ER MPF': 0,
  'SSS EC': 0,
  'PhilHealth ER': 0,
  'Pag-IBIG ER': 0,

  'Withholding Tax': 0
};


myAdj.forEach(adj => {
  const prior = priorFor(adj.name);

  const valueForRun = _r2_((adj.amt || 0) - prior);
  const cat = (adj.cat || '').toLowerCase();

  const sysKey = _canonicalSysKey_(adj.name);
  if (sysKey && Object.prototype.hasOwnProperty.call(sysAdj, sysKey)) {
    sysAdj[sysKey] += valueForRun;
    dataMap.set(sysKey, (_n_(dataMap.get(sysKey)) + valueForRun));
    return;
  }

  dataMap.set(adj.name, valueForRun);

  if (cat === 'basic pay related') {
  basicRelatedSum += valueForRun;

  // PhilHealth: include basic-pay-related EXCEPT Absence/Tardiness
  if (!_isUnworkedTime_(adj.name)) basicRelatedSumPH += valueForRun;
}

  else if (cat === 'taxable earning')     taxableOnlySum  += valueForRun;
  else if (
  cat === 'non-taxable earning' ||
  cat === 'non-taxable earning - de minimis' ||
  cat === 'non-taxable earning - other'
) nonTaxableSum += valueForRun;
  else if (cat === 'addition')            additionSum     += valueForRun;
  else if (cat === 'deduction')           deductionSum    += valueForRun;
});


    // 3) Statutory (FULL month; no split logic)
const baseForSSS_PI = baseMonthlySalary + basicRelatedSum;
const baseForPH     = baseMonthlySalary + basicRelatedSumPH;


let stat = (computeContrib && !isConsultant && !isRetired)
  ? (function _monthlyStat() {
      return _computeStatutoryForPeriod_({
        baseMonthlySSSPI: baseForSSS_PI,
        baseMonthlyPH:    baseForPH,
        getModeFor: (_componentName) => 'full',
        sssTable,
        isFullPeriod: true,
        priorTaken,
        partLabel: 'M',
        cfg,
         empId,
  periodLabel
      });
    })()
  : { sssEe:0, sssEr:0, sssEc:0, phEe:0, phEr:0, piEe:0, piEr:0 };

// PWD â†’ no PhilHealth EE (while not retired)
if (isPwd && !isConsultant && !isRetired) {
  stat.phEe = 0;
}

// Non-Filipino â†’ no HDMF (Pag-IBIG) EE/ER, but SSS & PH still apply (while not retired)
if (!isFilipino && !isConsultant && !isRetired) {
  stat.piEe = 0;
  stat.piEr = 0;
}


// âœ… Merge system-component adjustments into statutory lines (BREAKDOWN-FIRST)
const sssEeMcAdj = sysAdj['SSS EE MC']      || 0;
const sssEeMpfAdj = sysAdj['SSS EE MPF']   || 0;
const phEeAdj    = sysAdj['PhilHealth EE'] || 0;
const piEeAdj    = sysAdj['Pag-IBIG EE']   || 0;

const sssErMcAdj = sysAdj['SSS ER MC']     || 0;
const sssErMpfAdj = sysAdj['SSS ER MPF']  || 0;
const sssEcAdj   = sysAdj['SSS EC']        || 0;
const phErAdj    = sysAdj['PhilHealth ER'] || 0;
const piErAdj    = sysAdj['Pag-IBIG ER']   || 0;

// EE lines stored NEGATIVE
dataMap.set('SSS EE MC',     _r2_(-stat.sssEeMc  + sssEeMcAdj));
dataMap.set('SSS EE MPF',    _r2_(-stat.sssEeMpf + sssEeMpfAdj));
dataMap.set('PhilHealth EE', _r2_(-stat.phEe     + phEeAdj));
dataMap.set('Pag-IBIG EE',   _r2_(-stat.piEe     + piEeAdj));

// Keep legacy total populated (hidden), derived from breakdown
dataMap.set('SSS EE', _r2_(
  _n_(dataMap.get('SSS EE MC')) + _n_(dataMap.get('SSS EE MPF'))
));

// ER/EC remain POSITIVE
dataMap.set('SSS ER MC',     _r2_(stat.sssErMc   + sssErMcAdj));
dataMap.set('SSS ER MPF',    _r2_(stat.sssErMpf  + sssErMpfAdj));
dataMap.set('SSS EC',        _r2_(stat.sssEc     + sssEcAdj));
dataMap.set('PhilHealth ER', _r2_(stat.phEr      + phErAdj));
dataMap.set('Pag-IBIG ER',   _r2_(stat.piEr      + piErAdj));

// Keep legacy total populated (hidden), derived from breakdown
dataMap.set('SSS ER', _r2_(
  _n_(dataMap.get('SSS ER MC')) + _n_(dataMap.get('SSS ER MPF'))
));

// 4) TAXABLE INCOME (monthly)
let taxableEarnings = 0;

// Base taxable earnings from Masterfile components
mHeaders.forEach(h => {
  const cat = _classifyComponent_(h, componentMap);
  const val = _n_(dataMap.get(h));
  if (cat === 'Basic Pay Related' || cat === 'Taxable Earning') {
    taxableEarnings += val;
  }
});

// Earnings from adjustments
taxableEarnings += basicRelatedSum + taxableOnlySum;

// ðŸ”¹ 13th Month Pay & Other Benefits â€“ YTD 90k exemption
let otherBenefitsThisRun = 0;
fullHeader.forEach(h => {
  const v = _n_(dataMap.get(h));
  if (!v) return;

  const catFromInputs = (nameToCat.get(h) || '').toLowerCase();
  const catFromMap    = (_classifyComponent_(h, componentMap) || '').toLowerCase();
  const cat           = catFromInputs || catFromMap;

  if (cat === '13th month pay and other benefits') {
    otherBenefitsThisRun += v;
  }
});

let taxableOtherBenefits      = 0;
let nonTaxableOtherBenefits   = 0;
const cap                     = OTHER_BENEFITS_EXEMPT_YTD;

// ðŸ”´ FIX: Correctly compute remaining exemption based on YTD usage
const priorYtdTotal = Math.abs(ytdOtherBenefitsMap.get(empId) || 0);
const remainingExempt = Math.max(0, cap - priorYtdTotal);

if (otherBenefitsThisRun !== 0) {
  const runAbs = Math.abs(otherBenefitsThisRun);
  
  const taxableAbs = Math.max(0, runAbs - remainingExempt);
  const nonTaxableAbs = runAbs - taxableAbs;

  const sign = otherBenefitsThisRun >= 0 ? 1 : -1;
  taxableOtherBenefits    = sign * taxableAbs;
  nonTaxableOtherBenefits = sign * nonTaxableAbs;
}

taxableEarnings += taxableOtherBenefits;


const taxableIncomeForPeriod = Math.max(
  0,
  taxableEarnings
    - (Math.abs(_n_(dataMap.get('SSS EE MC'))) + Math.abs(_n_(dataMap.get('SSS EE MPF'))))
    - Math.abs(_n_(dataMap.get('PhilHealth EE')))
    - Math.abs(_n_(dataMap.get('Pag-IBIG EE')))
);
dataMap.set('Taxable Income', _r2_(taxableIncomeForPeriod));

// 5) Withholding Tax (monthly)
let annualProjected      = null;
let annualRateFor13th    = null;
let taxRegularPortion    = null;
let tax13thPortion       = null;

if (computeTax && !isMwe) {

  if (isConsultant) {
    // âœ… Consultants: WTax = taxable income for this run Ã— consultant rate
    // (includes BASIC + Basic Pay Related + Taxable Earning components already rolled into taxableIncomeForPeriod)
    const t = _r2_(Math.max(0, _n_(taxableIncomeForPeriod)) * consultantTaxRate);
    dataMap.set('Withholding Tax', -t);
    taxRegularPortion = Math.abs(t);
  } else {
    // Split regular taxable vs taxable 13th month / other benefits
    const taxable13th    = _n_(taxableOtherBenefits);
    const regularTaxable = _r2_(
      (Number(taxableIncomeForPeriod) || 0) - taxable13th
    );

    let useAnnualRate        = false;
    let annualRate           = 0;
    let annualProjectedLocal = null;

    if (taxable13th) {
      annualProjectedLocal = _estimateAnnualProjectedTaxable_(
        empId,
        regularTaxable,
        cfg && cfg.PAY_FREQUENCY,
        ytdTaxableIncomeMap
      ) + Math.max(0, taxable13th);  // âž• add this cutoffâ€™s taxable 13th / other benefits

      annualRate = _lookupAnnualRateFor13th_(annualProjectedLocal, bir);
      if (annualRate && annualRate > 0) useAnnualRate = true;

      annualProjected   = annualProjectedLocal;
      annualRateFor13th = annualRate;
    }

    if (!useAnnualRate) {
      // Fallback: original behavior â€” tax full taxable income via MONTHLY table
      const tax = _computeWithholdingTaxEx_(taxableIncomeForPeriod, /*isSemi=*/false, bir);
      dataMap.set('Withholding Tax', _r2_(-tax));

      const totalTax = Math.abs(_n_(dataMap.get('Withholding Tax')));
      taxRegularPortion = totalTax;
      tax13thPortion    = null;
    } else {
      // New behavior:
      //   1) Regular taxable â†’ monthly table
      //   2) Taxable 13th/other benefits â†’ annual marginal rate
      const taxRegular = _computeWithholdingTaxEx_(regularTaxable, /*isSemi=*/false, bir);
      const tax13th    = _r2_(Math.abs(taxable13th) * annualRate);
      const totalTax   = _r2_(taxRegular + tax13th);

      dataMap.set('Withholding Tax', -totalTax);

      taxRegularPortion = taxRegular;
      tax13thPortion    = tax13th;
    }
  }
} else {
  dataMap.set('Withholding Tax', 0);
}

    // âœ… Merge any case-insensitive "Withholding Tax" adjustments
const wtaxAdj = sysAdj['Withholding Tax'] || 0;
if (wtaxAdj) {
  dataMap.set('Withholding Tax', _r2_(_n_(dataMap.get('Withholding Tax')) + wtaxAdj));
}

// ðŸ” DEBUG: log 13th/other-benefits annualization for MONTHLY run
if (false) if ((otherBenefitsThisRun !== 0 || taxableOtherBenefits !== 0) && empId) {
  debugTaxAnnualizationRow({
    empId,
    periodLabel,
    partLabel: 'M',
    payFrequency: cfg.PAY_FREQUENCY,
    runType: 'MONTHLY',

    ytdOtherBefore,
    otherBenefitsThisRun,
    nonTaxableOtherBenefits,
    taxableOtherBenefits,
    cap: OTHER_BENEFITS_EXEMPT_YTD,
    remainingExemptBeforeRun: remainingExempt,

    taxableIncomeForPeriod,
    projectedAnnual: annualProjected,
    annualRate: annualRateFor13th,
    wtaxRegular: taxRegularPortion,
    wtax13th: tax13thPortion,
    wtaxTotal: Math.abs(_n_(dataMap.get('Withholding Tax')))
  });
}


    // 6) Gross & Net
    let grossPay = 0;
    const nonEarningCols = new Set([
  'WITHHOLDING TAX','TAXABLE INCOME','GROSS PAY','NET PAY','PHILHEALTH EE','PAG-IBIG EE','SSS EC','PHILHEALTH ER','PAG-IBIG ER','SSS EE','SSS ER',
  // âœ… NEW: Add breakdown columns to exclusion list so they aren't deducted twice
  'SSS EE MC', 'SSS EE MPF',
  'SSS ER MC', 'SSS ER MPF'
]);
    fullHeader.forEach(h => {
      const up = String(h).toUpperCase();
      const v  = _n_(dataMap.get(h));
      if (nonEarningCols.has(up)) return;

      const catFromInputs = (nameToCat.get(h) || '').toLowerCase();
      const catFromMap    = (_classifyComponent_(h, componentMap) || '').toLowerCase();
      const cat = catFromInputs || catFromMap;

            const isAdditionCat  = /^addition\b/i.test(cat);
      const isDeductionCat = /^deduction\b/i.test(cat);

      const isDed = isDeductionCat ||
        (!isAdditionCat && /LOAN|DEDUCTION|DEDUK|CALAMITY|CHARGE|ADVANCE|HMO|RECOVERY/i.test(up));

      if (isDed) return;        // handled as deduction; does not go into Gross
      if (isAdditionCat) return; // additions are net-only


  const isTaxableEarning    = (cat === 'taxable earning');
  const isNonTaxableEarning = (cat === 'non-taxable earning');

  if (isTaxableEarning || isNonTaxableEarning) {
    // Signed impact on Gross:
    grossPay += v;   // positive â†’ increase, negative â†’ decrease
    return;
  }

  // Other earnings
  if (v > 0) grossPay += v;
  if (v < 0 && (_isUnworkedTime_(h) || _isSalaryAdjustment_(h))) grossPay += v; // reduce gross
});

    const sssEE = 
  Math.abs(_n_(dataMap.get('SSS EE MC'))) +
  Math.abs(_n_(dataMap.get('SSS EE MPF')));

    const phEE  = Math.abs(_n_(dataMap.get('PhilHealth EE')));
    const piEE  = Math.abs(_n_(dataMap.get('Pag-IBIG EE')));
    // Withholding Tax is SIGNED (negative = deduct, positive = refund)
const wtaxSigned = _n_(dataMap.get('Withholding Tax'));
const wtaxEffect = (wtaxSigned < 0 ? Math.abs(wtaxSigned) : -Math.abs(wtaxSigned));


       // manual deductions (from Inputs + masterfile)
    let manualDeductionsAbs = 0;

        [...dynamicDeductionCols, ...masterDynamicDeductionCols].forEach(h => {
      const v = _n_(dataMap.get(h));
      if (!v) return;

      // âœ… For deductions (Inputs or Masterfile/keyword): negative = deduct more, positive = refund
      if (v < 0) manualDeductionsAbs += Math.abs(v);
      else if (v > 0) manualDeductionsAbs -= Math.abs(v);
    });

    // additions (net-only)
// additions (net-only): MF + Inputs
let additions = 0;
[...masterDynamicAdditionCols, ...dynamicAdditionCols].forEach(h => {
  additions += _n_(dataMap.get(h));
});

const totalAllDeductions = sssEE + phEE + piEE + wtaxEffect + manualDeductionsAbs;

dataMap.set('Gross Pay', _r2_(grossPay));
dataMap.set('Net Pay', _r2_(grossPay - totalAllDeductions + additions));

        // 7) Identity/period fields
    dataMap.set('Employee ID', empId);
dataMap.set('Employee Name', name);

// Tracking categories + payroll group (same as core runner)
const tc1Key = tc1Label.toUpperCase();
const tc2Key = tc2Label.toUpperCase();
const pgKey  = 'PAYROLL GROUP';

const tc1Idx = headerIndex[tc1Key];
const tc2Idx = headerIndex[tc2Key];
const pgIdx  = headerIndex[pgKey];

dataMap.set(tc1Label, tc1Idx > -1 ? (r[tc1Idx] || '') : '');
dataMap.set('Payroll Group', pgIdx  > -1 ? (r[pgIdx]  || '') : '');
dataMap.set(tc2Label, tc2Idx > -1 ? (r[tc2Idx] || '') : '');


    dataMap.set('Period', periodLabel);
    dataMap.set('From', _fmtDate_(rangeStart));
    

    dataMap.set('To', _fmtDate_(rangeEnd));
    let creditingDate = String(form.creditingDate || '').trim();
    if (!creditingDate) creditingDate = _creditingDateFromRange_(rangeEnd, 'B'); // default near month-end
    dataMap.set('Crediting Date', creditingDate);
    dataMap.set('Payroll Month', payrollMonth);

    outRows.push(fullHeader.map(h => dataMap.get(h) ?? ''));

    const pct = Math.min(98, Math.round(((i + 1) / total) * 100));
    const elapsed = (new Date() - startTime) / 1000;
    const eta = ((elapsed / (i + 1)) * (total - (i + 1))).toFixed(1);
    if (i % 2 === 0 || i + 1 === total) _progress(pct, `Phase 2/4: Computing employees (${i + 1}/${total})...`, `${eta}s`);

  });

  _progress(98, "Phase 3/4: Writing payroll sheetâ€¦", "<1s>");
_writeComputation_(out, fullHeader, outRows);

_progress(99, "Phase 4/4: Formatting & computing totalsâ€¦", "<1s>");
formatPayrollSheetUnified_(out, true);  // includes totals

  _writeComputation_(out, fullHeader, outRows);
  formatPayrollSheetUnified_(out, true);

  // Name & protect
  const entityLabel = (entityVal && entityVal !== 'ALL') ? entityVal : 'All Entities';
  const normGroupsList = isAllGroups ? ['All Groups'] : [...selectedGroups];
  const groupsLabel = normGroupsList.join(', ');
  const payrollGroup = `${groupsLabel}`;
  out.setName(`${payrollGroup} - ${periodLabel}`);
  protectComputationSheet_(out);

  _progress(100, "âœ… Monthly payroll complete!", "0s");
  return true;
}

    /**
     * SPECIAL payroll: full-featured path, seamless with CORE.
     * - Reuses: BIR, history, column build, formatter, protection, posting.
     * - Pulls identity fields from Masterfile (ID â†’ Name/Entity/Group/Clients/Sales Manager).
     * - Ignores Masterfile pay components entirely; uses Inputs rows only.
     */
    /**
     * SPECIAL payroll (Inputs-only), robust & aligned with Core formatting/totals.
     * Fixes:
     * - Missing Entity/Group/Clients/Sales Manager in output
     * - Doubled Taxable Income (now computed exactly once)
     * - Header de-duping and stable order
     * - Same totals/format/protection/sheet naming as Core
     * - Defensive guards for null sheets/headers and missing helpers
     */
    /**
     * SPECIAL payroll: full-featured path, seamless with CORE.
     * - Reuses: BIR, history, column build, formatter, protection, posting.
     * - Pulls identity fields from Masterfile (ID â†’ Name/Entity/Group/Clients/Sales Manager).
     * - Ignores Masterfile pay components entirely; uses Inputs rows only.
     */
    /**
     * SPECIAL payroll (Inputs-only), robust & aligned with Core formatting/totals.
     * Fixes:
     * - Missing Entity/Group/Clients/Sales Manager in output
     * - Doubled Taxable Income (now computed exactly once)
     * - Header de-duping and stable order
     * - Same totals/format/protection/sheet naming as Core
     * - Defensive guards for null sheets/headers and missing helpers
     */
    function _runPayrollSpecial_(form) {
  // ===== Validate form =====
  if (!form || !form.startDate || !form.endDate) {
    throw new Error('Incomplete payroll details for SPECIAL run (need startDate & endDate).');
  }

  // âœ… Normalize computeTax (bool or string)
  const computeTax =
    form.computeTax === true ||
    String(form.computeTax).toLowerCase() === 'true';

  // ===== Context =====
  const payrollCode  = String(form.payrollCode || '').trim(); // used in sheet name
    const rangeStart = new Date(form.startDate);
  const rangeEnd   = new Date(form.endDate);

  // ðŸ” Anchor month on TO date
  const anchorDate = rangeEnd;
  const tz         = Session.getScriptTimeZone();

  const year  = anchorDate.getFullYear();
  const month = anchorDate.getMonth() + 1;

  const rawCode   = String(form.payrollCode || 'SPECIAL').trim().toUpperCase();
  const safeCode  = rawCode.replace(/[^A-Z0-9_-]/g, '');
  const partLabel = `S-${safeCode || 'SPECIAL'}`;

  const periodKey    = `${year}-${String(month).padStart(2, '0')}`;
  const periodLabel  = `${periodKey}-${partLabel}`;
  const payrollMonth = Utilities.formatDate(anchorDate, tz, 'MMMM yyyy');

  // ðŸ”Ž Filters from dialog (Entity + Payroll Groups)
  const entityVal = String(form.entity || '').trim().toUpperCase();

  const normalizeGroups = (g) => {
    if (Array.isArray(g)) return g;
    return String(g || '')
      .split(/[\n,;|]/g)
      .map(s => s.trim())
      .filter(Boolean);
  };

  const rawGroupList   = normalizeGroups(form.payrollGroups || []);
  let selectedGroups   = new Set(
    rawGroupList.map(g => String(g).trim().toUpperCase())
  );
  if (selectedGroups.size > 1 && selectedGroups.has('ALL')) {
    selectedGroups.delete('ALL');
  }
  const isAllGroups = selectedGroups.size === 0;

  const activeSS = SpreadsheetApp.getActiveSpreadsheet();
  const cfg      = _readSettings_();
  _progress(0, "Phase 1/4: Loading settings & source data...", "--");

  const files    = _openLinkedFiles_(cfg, activeSS);
  const sourceSS = files && files.sourceSS ? files.sourceSS : null;
  const inputsSS = files && files.inputsSS ? files.inputsSS : null;
  if (!sourceSS) throw new Error('Missing/invalid Employee Masterfile (SOURCE_SS_ID) in Settings.');

    // Build component map for classification (including 13th month category)
  const componentMap = (() => {
    try {
      return _buildComponentMap_(cfg);
    } catch (e) {
      Logger.log('componentMap (SPECIAL) error: ' + e.message);
      return {};
    }
  })();


  // ===== Masterfile =====
  const master = _mustGetSheet_(sourceSS, cfg.MASTER_SHEET_NAME);
  const mVals  = master.getDataRange().getValues();
  if (!mVals || mVals.length < 2) {
    throw new Error(`No data found in "${cfg.MASTER_SHEET_NAME}".`);
  }

  const mHeaders = mVals[0].map(h => String(h || '').trim());
  const mRows    = mVals.slice(1);

  const dims = _resolveTrackingColumns_(mHeaders);
const tc1Label = dims.dim1Label || 'Tracking Category 1';
const tc2Label = dims.dim2Label || 'Tracking Category 2';

const IDX = {
  EMP_ID : _findHeaderFuzzy_(mHeaders, ['Employee ID', 'Emp ID']),
  EMP_NM : _findHeaderFuzzy_(mHeaders, ['Employee Name', 'Name']),
  TC1    : dims.dim1Idx,
  TC2    : dims.dim2Idx,
  PGRP   : _findHeaderFuzzy_(mHeaders, ['Payroll Group','PAYROLL GROUP','Group','Group Name']),
  STATUS : _findHeaderFuzzy_(mHeaders, ['Status']),
  CONTRACT: _findHeaderFuzzy_(mHeaders, ['Contract Type','CONTRACT TYPE']),
  BIRTHDAY: _findHeaderFuzzy_(mHeaders, ['Birthday','Birthdate']),
  PWD    : _findHeaderFuzzy_(mHeaders, ['PWD']),
  RET_FLAG: _findHeaderFuzzy_(mHeaders, ['Applied for Retirement','APPLIED FOR RETIREMENT']), // NEW
  NAT    : _findHeaderFuzzy_(mHeaders, ['Nationality','NATIONALITY']),
  WHCONS : _findHeaderFuzzy_(mHeaders, ['Withholding Tax (for Consultants)', 'Consultant WH %']),
    MWE    : _findHeaderFuzzy_(mHeaders, ['MWE']),

};



  if (IDX.EMP_ID === -1 || IDX.EMP_NM === -1) {
    throw new Error('Masterfile must contain "Employee ID" and "Employee Name" columns.');
  }

  // Map masterfile rows by Employee ID
  const mfById = new Map();
  mRows.forEach(r => {
    const id = String(r[IDX.EMP_ID] || '').trim();
    if (id) mfById.set(id, r);
  });

  // ===== Inputs (Adjustments) =====
// SPECIAL must consider multiple inputs tabs (some clients use "Adjustment Inputs")
const inputSheets = [];
if (inputsSS) {
  [
    'Inputs',
    'Adjustments',
    'Adjustment Inputs',
    'Adjustment_Inputs'
  ].forEach(n => {
    const sh = inputsSS.getSheetByName(n);
    if (sh) inputSheets.push(sh);
  });
}

let allAdjRaw = [];
inputSheets.forEach(sh => {
  allAdjRaw = allAdjRaw.concat(_loadInputsWithin_(sh));
});

// Re-aggregate across sheets by Employee ID + Description (case-insensitive)
const grouped = new Map();
allAdjRaw.forEach(r => {
  const key = `${String(r.empId || '').trim()}||${String(r.name || '').trim().toLowerCase()}`;
  if (!r.empId || !r.name) return;

  const prev = grouped.get(key);
  if (prev) {
    prev.amt += Number(r.amt) || 0;
    // keep a non-empty category if one exists
    if (!prev.cat && r.cat) prev.cat = r.cat;
  } else {
    grouped.set(key, {
      empId: String(r.empId || '').trim(),
      name:  String(r.name || '').trim(),
      amt:   Number(r.amt) || 0,
      cat:   String(r.cat || '').trim()
    });
  }
});

const allAdj = Array.from(grouped.values());
if (!allAdj || allAdj.length === 0) {
  throw new Error('No Inputs found for SPECIAL run (checked Inputs/Adjustments/Adjustment Inputs).');
}


  // Group adjustments per employee (already aggregated inside _loadInputsWithin_)
  const byEmp = new Map();
  allAdj.forEach(a => {
    const key = String(a.empId || '').trim();
    if (!key) return;
    if (!byEmp.has(key)) byEmp.set(key, []);
    byEmp.get(key).push(a);
  });

  // ===== Tables & History =====
  const birSheet = _mustGetSheet_(activeSS, 'BIR_TABLE');
  const sssSheet = _mustGetSheet_(activeSS, 'SSS_TABLE');
  const bir      = _loadBirTable_(birSheet);
  const sssTable = _loadSssTable_(sssSheet); // kept for future use, but zeroed for SPECIAL
  const hist     = _ensureHistorySheet_();
  const takenMap = _loadTakenThisMonth_(hist, periodKey) || new Map();
  const takenByPt = _loadTakenThisMonthByPart_(hist, periodKey) || { A: new Map(), B: new Map(), MTD: new Map() };

    // ðŸ”¹ YTD 13th month & other benefits for this year
  const anchorYear = anchorDate.getFullYear();
  const ytdOtherBenefitsMap = _loadYtdOtherBenefitsMap_(hist, anchorYear, componentMap);
  const ytdTaxableIncomeMap = _loadYtdTaxableIncomeMap_(hist, anchorYear);



  // ===== Header build =====
  const preCols  = [
  'Employee ID','Employee Name',
  tc1Label,'Payroll Group',tc2Label,
  'Period','From','To','Crediting Date','Payroll Month'
];


  const coreCols = [
  'Gross Pay',
  'SSS EE MC','SSS EE MPF','PhilHealth EE','Pag-IBIG EE',
  'Taxable Income','Withholding Tax'
];


  const fixedDeductionHeaders = [
    'SSS LOAN','SSS CALAMITY LOAN',
    'HDMF LOAN','HDMF CALAMITY LOAN',
    'HMO DEDUCTION','OTHER DEDUCTIONS'
  ];

  const postCols = [
  'Net Pay',
  'SSS ER MC','SSS ER MPF','SSS EC','PhilHealth ER','Pag-IBIG ER'
];


  const allAdjNames = [];
  const nameToCat   = new Map();
  allAdj.forEach(a => {
    const n = String(a.name || '').trim();
    if (!n) return;
    if (!nameToCat.has(n)) {
      allAdjNames.push(n);
      nameToCat.set(n, String(a.cat || '').trim());
    }
  });

  const addlEarningCols    = []; // Basic / Taxable / Non-taxable earnings
  const dynamicDeductionCols = [];
  const dynamicAdditionCols  = []; // Net-only additions

  allAdjNames.forEach(n => {
  // System components (SSS/PhilHealth/Pag-IBIG/WTax) are handled via sysAdj
  if (_isSystemComponentName_(n)) return;

  const cat = (nameToCat.get(n) || '').toLowerCase();
  if (cat === 'deduction') dynamicDeductionCols.push(n);
  else if (cat === 'addition') dynamicAdditionCols.push(n);
  else addlEarningCols.push(n); // basic-related, taxable earning, non-taxable earning
});


  const fullHeader = [];
  const seen = new Set();
  function pushUnique(h) {
    const k = String(h || '').trim();
    if (k && !seen.has(k)) {
      seen.add(k);
      fullHeader.push(k);
    }
  }

  [].concat(
    preCols,
    addlEarningCols,
    coreCols,
    dynamicAdditionCols,     // â¬… additions appear before deductions (net-only)
    fixedDeductionHeaders,
    dynamicDeductionCols,
    postCols
  ).forEach(pushUnique);

  // ===== Output compute =====
  const outRows = [];
  const empIds  = Array.from(byEmp.keys());
  const total   = empIds.length;
  

  for (let i = 0; i < empIds.length; i++) {
    const empId = empIds[i];
    const mfRow = mfById.get(empId);
    const empName = mfRow ? String(mfRow[IDX.EMP_NM] || '').trim() : '';
    if (!empName) continue;

     // YTD 13th-month & other benefits before this SPECIAL run
    const ytdOtherBefore = ytdOtherBenefitsMap.get(empId) || 0;

    // ðŸ”Ž Entity + Group filter (same logic as core)
    const empEnt  = mfRow && IDX.TC1  > -1 ? String(mfRow[IDX.TC1]  || '').trim().toUpperCase() : '';
    const empGrp  = mfRow && IDX.PGRP > -1 ? String(mfRow[IDX.PGRP] || '').trim().toUpperCase() : '';

    const entMatch =
      !entityVal ||
      entityVal === 'ALL' ||
      empEnt === entityVal;

    if (!entMatch) continue;

    if (!isAllGroups) {
      if (!empGrp || !selectedGroups.has(empGrp)) continue;
    }

    // STATUS filter
    const statusStr = (mfRow && IDX.STATUS > -1)
      ? String(mfRow[IDX.STATUS] || '').trim().toLowerCase()
      : '';
    if (statusStr && statusStr !== 'active') {
      continue;
    }

    // CONTRACT TYPE (for consultant rule)
const contractStr = IDX.CONTRACT >= 0 && mfRow
  ? String(mfRow[IDX.CONTRACT] || '').trim().toLowerCase()
  : '';
const isConsultant = /freelance|contractor|consultant/.test(contractStr);

// Retirement flag from Masterfile
let isRetired = false;
if (IDX.RET_FLAG >= 0 && mfRow) {
  const v = mfRow[IDX.RET_FLAG];
  if (typeof v === 'boolean') {
    isRetired = v;
  } else {
    const s = String(v || '').trim().toUpperCase();
    isRetired = (s === 'TRUE');
  }
}

// NATIONALITY â†’ only HDMF (Pag-IBIG) is suppressed for non-Filipinos
let isFilipino = true;
if (IDX.NAT >= 0 && mfRow) {
  const natRaw = String(mfRow[IDX.NAT] || '').trim().toUpperCase();
  isFilipino = natRaw.indexOf('FILIPINO') !== -1;
}

// MWE flag from Masterfile â†’ no withholding tax computation
let isMwe = false;
if (IDX.MWE >= 0 && mfRow) {
  const v = mfRow[IDX.MWE];
  if (typeof v === 'boolean') {
    isMwe = v;
  } else {
    const s = String(v || '').trim().toUpperCase();
    isMwe = (s === 'TRUE');
  }
}


const dataMap = new Map();

    // Identity / Meta
    dataMap.set('Employee ID', empId);
dataMap.set('Employee Name', empName);
dataMap.set(tc1Label, mfRow && IDX.TC1  > -1 ? (mfRow[IDX.TC1]  || '') : '');
dataMap.set('Payroll Group', mfRow && IDX.PGRP > -1 ? (mfRow[IDX.PGRP] || '') : '');
dataMap.set(tc2Label, mfRow && IDX.TC2  > -1 ? (mfRow[IDX.TC2]  || '') : '');



    dataMap.set('Period', periodLabel);
    dataMap.set('From', Utilities.formatDate(rangeStart, tz, 'yyyy-MM-dd'));
    dataMap.set('To',   Utilities.formatDate(rangeEnd,   tz, 'yyyy-MM-dd'));

    const credDate = form.creditingDate ? new Date(form.creditingDate) : rangeEnd;
    dataMap.set('Crediting Date', Utilities.formatDate(credDate, tz, 'yyyy-MM-dd'));
    dataMap.set('Payroll Month', payrollMonth);


    const priorTaken = takenMap.get(empId) || {};
    const priorFor = (k) => _getPriorTakenForRun_(takenMap, takenByPt, empId, k, partLabel);




    // === Inputs for this employee ===
    const inputsForEmp = byEmp.get(empId) || [];

    let sumBasicRelated    = 0;
let sumTaxableOnly     = 0;
let sumNonTaxable      = 0;
let manualDeductionAbs = 0;
let additionSum        = 0;   // net-only additions

// âœ… NEW: system component adjustments for SPECIAL, including WTAX
const sysAdj = {
  'SSS EE MC': 0, 'SSS EE MPF': 0,
  'SSS ER MC': 0, 'SSS ER MPF': 0,
  'SSS EC': 0,
  'PhilHealth EE': 0, 'PhilHealth ER': 0,
  'Pag-IBIG EE': 0, 'Pag-IBIG ER': 0
};



inputsForEmp.forEach(adj => {
  const cat   = String(adj.cat || '').toLowerCase();
  const prior = 0;

  const val   = _r2_((Number(adj.amt) || 0) - prior);

  const sysKey = _canonicalSysKey_(adj.name);
  if (sysKey && Object.prototype.hasOwnProperty.call(sysAdj, sysKey)) {
    sysAdj[sysKey] += val;
    dataMap.set(sysKey, (_n_(dataMap.get(sysKey)) + val));
    return;
  }

  dataMap.set(adj.name, val);

  if (cat === 'basic pay related')        sumBasicRelated   += val;
  else if (cat === 'taxable earning')     sumTaxableOnly    += val;
  else if (
  cat === 'non-taxable earning' ||
  cat === 'non-taxable earning - de minimis' ||
  cat === 'non-taxable earning - other'
) sumNonTaxable += val;
  else if (cat === 'deduction') {
    if (val < 0)      manualDeductionAbs += Math.abs(val);
    else if (val > 0) manualDeductionAbs -= Math.abs(val);
  }
  else if (cat === 'addition')            additionSum       += val;
});

// === Statutory (SPECIAL):
// by default still 0, but merge any explicit system adjustments from Inputs
let sssEeVal0 = (sysAdj['SSS EE MC'] || 0) + (sysAdj['SSS EE MPF'] || 0);
let phEeVal0  = sysAdj['PhilHealth EE'] || 0;
let piEeVal0  = sysAdj['Pag-IBIG EE']   || 0;

let sssErVal0 = (sysAdj['SSS ER MC'] || 0) + (sysAdj['SSS ER MPF'] || 0);
let sssEcVal0 = sysAdj['SSS EC']        || 0;
let phErVal0  = sysAdj['PhilHealth ER'] || 0;
let piErVal0  = sysAdj['Pag-IBIG ER']   || 0;


// If Applied for Retirement is TRUE â†’ no SSS/PhilHealth/Pag-IBIG EE/ER at all
if (isRetired && !isConsultant) {
  sssEeVal0 = 0;
  phEeVal0  = 0;
  piEeVal0  = 0;
  sssErVal0 = 0;
  sssEcVal0 = 0;
  phErVal0  = 0;
  piErVal0  = 0;
} else if (!isFilipino && !isConsultant) {
  // Non-Filipino â†’ no HDMF (Pag-IBIG) EE/ER even if manually input
  piEeVal0 = 0;
  piErVal0 = 0;
}


dataMap.set('SSS EE',        _r2_(sssEeVal0));
dataMap.set('PhilHealth EE', _r2_(phEeVal0));
dataMap.set('Pag-IBIG EE',   _r2_(piEeVal0));
dataMap.set('SSS ER',        _r2_(sssErVal0));
dataMap.set('SSS EC',        _r2_(sssEcVal0));
dataMap.set('PhilHealth ER', _r2_(phErVal0));
dataMap.set('Pag-IBIG ER',   _r2_(piErVal0));

// === Taxable Income ===
let taxableEarnings = _n_(sumBasicRelated) + _n_(sumTaxableOnly);

// ðŸ”¹ 13th Month Pay & Other Benefits â€“ YTD 90k exemption (SPECIAL)
let otherBenefitsThisRun = 0;
fullHeader.forEach(h => {
  const v = _n_(dataMap.get(h));
  if (!v) return;

  const catFromInputs = (nameToCat.get(h) || '').toLowerCase();
  const catFromMap    = (_classifyComponent_(h, componentMap) || '').toLowerCase();
  const cat           = catFromInputs || catFromMap;

  if (cat === '13th month pay and other benefits') {
    otherBenefitsThisRun += v;
  }
});


let taxableOtherBenefits      = 0;
let nonTaxableOtherBenefits   = 0;
const cap                     = OTHER_BENEFITS_EXEMPT_YTD;

// ðŸ”´ FIX: Correctly compute remaining exemption based on YTD usage
// In SPECIAL, ytdOtherBefore is defined earlier in the loop
const priorYtdTotal = Math.abs(ytdOtherBefore || 0);
const remainingExempt = Math.max(0, cap - priorYtdTotal);

if (otherBenefitsThisRun !== 0) {
  const runAbs = Math.abs(otherBenefitsThisRun);
  
  const taxableAbs = Math.max(0, runAbs - remainingExempt);
  const nonTaxableAbs = runAbs - taxableAbs;

  const sign = otherBenefitsThisRun >= 0 ? 1 : -1;
  taxableOtherBenefits    = sign * taxableAbs;
  nonTaxableOtherBenefits = sign * nonTaxableAbs;
}

taxableEarnings += taxableOtherBenefits;
const rawTaxableIncome  = _r2_(taxableEarnings);

    // EE contributions reduce taxable income (use actual lines from dataMap)
    const sssEeActual = Math.abs(_n_(dataMap.get('SSS EE')));
    const phEeActual  = Math.abs(_n_(dataMap.get('PhilHealth EE')));
    const piEeActual  = Math.abs(_n_(dataMap.get('Pag-IBIG EE')));

    const taxableIncomeForPeriod = Math.max(
      0,
      rawTaxableIncome - sssEeActual - phEeActual - piEeActual
    );
    dataMap.set('Taxable Income', taxableIncomeForPeriod);

// === Withholding Tax ===
const consRateRaw = (mfRow && IDX.WHCONS > -1)
  ? _toNumber_(mfRow[IDX.WHCONS] || 0)
  : 0;
const consultantTaxRate = consRateRaw > 1 ? consRateRaw / 100 : consRateRaw;

let wtax = 0;
let annualProjected      = null;
let annualRateFor13th    = null;
let taxRegularPortion    = null;
let tax13thPortion       = null;

if (computeTax && !isMwe) {

  if (isConsultant) {
    // SPECIAL + Consultant: tax = taxable income * consultant rate
    wtax = _r2_(taxableIncomeForPeriod * consultantTaxRate);
    dataMap.set('Withholding Tax', -wtax);
    taxRegularPortion = Math.abs(wtax);
  } else {
    const taxable13th = _n_(taxableOtherBenefits);
    const regularTaxable = _r2_(
      (Number(taxableIncomeForPeriod) || 0) - taxable13th
    );

    let useAnnualRate        = false;
    let annualRate           = 0;
    let annualProjectedLocal = null;

    if (taxable13th) {
      annualProjectedLocal = _estimateAnnualProjectedTaxable_(
        empId,
        regularTaxable,
        cfg && cfg.PAY_FREQUENCY,
        ytdTaxableIncomeMap
      ) + Math.max(0, taxable13th);  // âž• SPECIAL: include this runâ€™s taxable 13th / other benefits

      annualRate = _lookupAnnualRateFor13th_(annualProjectedLocal, bir);
      if (annualRate && annualRate > 0) useAnnualRate = true;

      annualProjected   = annualProjectedLocal;
      annualRateFor13th = annualRate;
    }

    if (!useAnnualRate) {
      // Fallback: original behavior â€” tax full taxable income via table.
      _applyWithholdingTax_(dataMap, {
        taxableIncomeForPeriod: taxableIncomeForPeriod,
        partLabel: 'SPECIAL',
        cfg: cfg,
        bir: bir
      });
      wtax = Math.abs(_n_(dataMap.get('Withholding Tax')));
      taxRegularPortion = wtax;
      tax13thPortion    = null;
    } else {
      // Regular taxable via table, 13th month via annual marginal rate.
      _applyWithholdingTax_(dataMap, {
        taxableIncomeForPeriod: regularTaxable,
        partLabel: 'SPECIAL',
        cfg: cfg,
        bir: bir
      });
      const taxRegular = Math.abs(_n_(dataMap.get('Withholding Tax')));
      const tax13th    = _r2_(Math.abs(taxable13th) * annualRate);
      wtax             = _r2_(taxRegular + tax13th);
      dataMap.set('Withholding Tax', -wtax);

      taxRegularPortion = taxRegular;
      tax13thPortion    = tax13th;
    }
  }
} else {
  dataMap.set('Withholding Tax', 0);
}


// âœ… Merge any Withholding Tax adjustments (case-insensitive)
const wtaxAdj = sysAdj['Withholding Tax'] || 0;
if (wtaxAdj) {
  dataMap.set('Withholding Tax', _r2_(_n_(dataMap.get('Withholding Tax')) + wtaxAdj));
  wtax = Math.abs(_n_(dataMap.get('Withholding Tax')));
}

// ðŸ” DEBUG: log 13th/other-benefits annualization for SPECIAL run
if (false) if (empId && typeof debugTaxAnnualizationRow === 'function') {
  debugTaxAnnualizationRow({
    empId,
    periodLabel,
    partLabel,
    payFrequency: cfg.PAY_FREQUENCY,
    runType: 'SPECIAL',

    ytdOtherBefore,
    otherBenefitsThisRun,
    nonTaxableOtherBenefits,
    taxableOtherBenefits,
    cap: OTHER_BENEFITS_EXEMPT_YTD,
    remainingExemptBeforeRun: remainingExempt,

    taxableIncomeForPeriod,
    projectedAnnual: annualProjected,
    annualRate: annualRateFor13th,
    wtaxRegular: taxRegularPortion,
    wtax13th: tax13thPortion,
    wtaxTotal: Math.abs(_n_(dataMap.get('Withholding Tax')))
  });
}

    // === Gross & Net ===
    let grossPay = 0;
    addlEarningCols.forEach(h => {
      grossPay += _n_(dataMap.get(h));
    });

    const sssEEAbs =
  Math.abs(_n_(dataMap.get('SSS EE MC'))) +
  Math.abs(_n_(dataMap.get('SSS EE MPF')));
const phEEAbs  = Math.abs(_n_(dataMap.get('PhilHealth EE')));
const piEEAbs  = Math.abs(_n_(dataMap.get('Pag-IBIG EE')));
// IMPORTANT: Withholding Tax is SIGNED (negative = deduction, positive = refund)
const wtaxSigned = _n_(dataMap.get('Withholding Tax'));

// Net Pay: subtract statutory contributions, then APPLY signed tax (refund adds, deduction subtracts)
const statutoryAbsNoTax = sssEEAbs + phEEAbs + piEEAbs;
const netPay = _r2_(grossPay - statutoryAbsNoTax + wtaxSigned - manualDeductionAbs + additionSum);


    dataMap.set('Gross Pay', _r2_(grossPay));
    dataMap.set('Net Pay',   netPay);

    outRows.push(fullHeader.map(h => dataMap.get(h) ?? ''));

    if (i % 2 === 0 || i + 1 === total) {
      _progress(
        Math.min(98, Math.round(((i + 1) / total) * 100)),
        `Phase 2/4: Computing employees (${i + 1}/${total})...`,

        '--'
      );
    }
  }

  // ===== Write to sheet =====
const out = activeSS.getSheetByName(payrollCode) || activeSS.insertSheet(payrollCode);

_progress(98, "Phase 3/4: Writing payroll sheetâ€¦", "<1s>");
_writeComputation_(out, fullHeader, outRows);

_progress(99, "Phase 4/4: Formatting & computing totalsâ€¦", "<1s>");
formatPayrollSheetUnified_(out, true);

  // === Name and protect (same pattern as core) ===
  const entityLabel = (entityVal && entityVal !== 'ALL') ? entityVal : 'All Entities';
  const normGroupsList = isAllGroups ? ['All Groups'] : [...selectedGroups];
  const groupsLabel = normGroupsList.join(', ');
  const label = `${groupsLabel}`;
  const newName = `${label} - ${payrollCode || periodLabel}`;

  out.setName(newName);
  protectComputationSheet_(out);

  _progress(100, 'âœ… SPECIAL payroll complete!', '0s');
  return true;
}


function resetProgress() {
  _resetProgress_();
}



    function _resetProgress_() {
      const props = PropertiesService.getScriptProperties();
      props.deleteProperty('progress');
    }


/**
 * Returns detailed rows from Masterfile where "Computed Basic Pay" has a value,
 * filtered by dialog selection (Entity + Payroll Groups).
 *
 * Output:
 * {
 *   sheetName: string,
 *   headerName: string,
 *   rows: [{ rowNumber:number, empId:string, empName:string, computed:any }]
 * }
 */
function listMasterfileComputedBasicPayRows(form) {
  const cfg = _readSettings_();
  if (!cfg || !cfg.SOURCE_SS_ID) throw new Error('Missing/invalid Employee Masterfile (SOURCE_SS_ID) in Settings.');

  const masterSS = SpreadsheetApp.openById(cfg.SOURCE_SS_ID);
  const masterSh = _mustGetSheet_(masterSS, cfg.MASTER_SHEET_NAME);

  const all = masterSh.getDataRange().getValues();
  if (!all || all.length < 2) {
    return { sheetName: masterSh.getName(), headerName: '', rows: [] };
  }

  const headers = all[0].map(h => String(h || '').trim());
  const data = all.slice(1);

  // Dialog filter inputs
  const entityVal = String((form && form.entity) || '').trim().toUpperCase();

  const selectedGroupsRaw = Array.isArray(form && form.payrollGroups) ? form.payrollGroups : [];
  let selectedGroups = new Set(selectedGroupsRaw.map(g => String(g || '').trim().toUpperCase()).filter(Boolean));
  if (selectedGroups.size > 1 && selectedGroups.has('ALL')) selectedGroups.delete('ALL');
  const isAllGroups = selectedGroups.size === 0;

  // Indices
  const dims = _resolveTrackingColumns_(headers);
  const entityIdx = dims.dim1Idx;

  const groupIdx = _findHeaderFuzzy_(headers, [
    'Payroll Group',
    'PAYROLL GROUP',
    'Group',
    'Group Name'
  ]);

  const empIdIdx = _findHeaderFuzzy_(headers, ['Employee ID', 'EMPLOYEE ID', 'Emp ID', 'ID']);
  const empNameIdx = _findHeaderFuzzy_(headers, ['Employee Name', 'EMPLOYEE NAME', 'Name']);

  // Computed Basic Pay column
  let computedIdx = _findHeaderFuzzy_(headers, [
    'Computed Basic Pay',
    'COMPUTED BASIC PAY',
    'Computed Basic',
    'BASIC PAY (COMPUTED)',
    'ComputedBP'
  ]);
  if (computedIdx === -1) {
    const up = headers.map(h => String(h || '').trim().toUpperCase());
    computedIdx = up.findIndex(h => h.includes('COMPUTED') && h.includes('BASIC') && h.includes('PAY'));
  }
  if (computedIdx === -1) {
    // No column -> nothing to show
    return { sheetName: masterSh.getName(), headerName: '', rows: [] };
  }

  const headerName = headers[computedIdx] || 'Computed Basic Pay';

  const hasNonZero = (v) => {
    if (v == null) return false;
    if (typeof v === 'number') return Math.abs(v) > 1e-9;
    const s0 = String(v).trim();
    if (!s0) return false;

    // parse numbers like "1,234.56" or "(1,234.56)"
    let s = s0;
    let neg = false;
    if (s.startsWith('(') && s.endsWith(')')) { neg = true; s = s.slice(1, -1); }
    s = s.replace(/,/g, '');
    const n = parseFloat(s);
    if (isFinite(n)) return Math.abs((neg ? -n : n)) > 1e-9;

    // non-empty non-numeric -> treat as value
    return true;
  };

  const out = [];

  for (let i = 0; i < data.length; i++) {
    const r = data[i];

    // Entity filter
    let entMatch = true;
    if (entityIdx !== -1) {
      const ent = String(r[entityIdx] || '').trim().toUpperCase();
      entMatch = !entityVal || entityVal === 'ALL' || ent === entityVal;
    }
    if (!entMatch) continue;

    // Group filter
    if (!isAllGroups) {
      if (groupIdx === -1) continue;
      const grp = String(r[groupIdx] || '').trim().toUpperCase();
      if (!grp) continue;
      if (!selectedGroups.has(grp)) continue;
    }

    const v = r[computedIdx];
    if (!hasNonZero(v)) continue;

    const empId = (empIdIdx !== -1) ? String(r[empIdIdx] || '').trim() : '';
    const empName = (empNameIdx !== -1) ? String(r[empNameIdx] || '').trim() : '';

    // rowNumber in sheet (header row is 1, data starts at row 2)
    out.push({
      rowNumber: i + 2,
      empId: empId,
      empName: empName,
      computed: v
    });
  }

  return { sheetName: masterSh.getName(), headerName: headerName, rows: out };
}

/**
 * Clears Computed Basic Pay for specific Masterfile rowNumbers.
 * payload: { rowNumbers:number[] }
 *
 * Returns: { clearedCount:number }
 */
function clearMasterfileComputedBasicPayRows(payload) {
  payload = payload || {};
  const rowNumbers = Array.isArray(payload.rowNumbers) ? payload.rowNumbers : [];
  if (!rowNumbers.length) return { clearedCount: 0 };

  const cfg = _readSettings_();
  if (!cfg || !cfg.SOURCE_SS_ID) throw new Error('Missing/invalid Employee Masterfile (SOURCE_SS_ID) in Settings.');

  const masterSS = SpreadsheetApp.openById(cfg.SOURCE_SS_ID);
  const masterSh = _mustGetSheet_(masterSS, cfg.MASTER_SHEET_NAME);

  const headers = masterSh.getRange(1, 1, 1, masterSh.getLastColumn()).getValues()[0].map(h => String(h || '').trim());

  let computedIdx = _findHeaderFuzzy_(headers, [
    'Computed Basic Pay',
    'COMPUTED BASIC PAY',
    'Computed Basic',
    'BASIC PAY (COMPUTED)',
    'ComputedBP'
  ]);
  if (computedIdx === -1) {
    const up = headers.map(h => String(h || '').trim().toUpperCase());
    computedIdx = up.findIndex(h => h.includes('COMPUTED') && h.includes('BASIC') && h.includes('PAY'));
  }
  if (computedIdx === -1) return { clearedCount: 0 };

  const col = computedIdx + 1;

  // sanitize + sort unique row numbers >= 2
  const rows = [...new Set(rowNumbers.map(n => Number(n || 0)).filter(n => isFinite(n) && n >= 2))].sort((a,b)=>a-b);
  if (!rows.length) return { clearedCount: 0 };

  // clear in contiguous batches
  let clearedCount = 0;
  let start = rows[0], prev = rows[0];

  const flush = (sRow, eRow) => {
    const num = (eRow - sRow) + 1;
    masterSh.getRange(sRow, col, num, 1).clearContent();
    clearedCount += num;
  };

  for (let i = 1; i < rows.length; i++) {
    const rn = rows[i];
    if (rn === prev + 1) { prev = rn; continue; }
    flush(start, prev);
    start = rn; prev = rn;
  }
  flush(start, prev);

  return { clearedCount: clearedCount };
}


function postPayrollToHistory_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getActiveSheet();
  return _postPayrollSheetToHistoryCore_(sheet, { refresh: true });
}

function listPayrollSheetsForHistory() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheets = ss.getSheets();

  // Known non-computation sheets in this file (case-insensitive)
  const SKIP_NAMES = new Set([
    'PAYROLL_HISTORY',
    'YEAR_TO_DATE',
    'INPUTS',
    'ADJUSTMENTS',
    'ADJUSTMENTSCHEDULE',
    'ADJUSTMENT SCHEDULE',
    'ADJUST_SCHEDULE',
    'RECURRING ADJUSTMENTS',
    'RECURRING ADJUSTMENT',
    'PAYSLIP_CHECK',
    'ADJUSTMENT_TYPES',
    'PAYROLL_COMPONENT_MODES',
    'WORKING_DAYS_GROUPS',
    'EMPLOYEE_MODE_OVERRIDES',
    'COLUMN_ORDER',
    'BIR_TABLE',
    '_DEBUG_1601C',
    '_DEBUG_BIR',
    '_EMPLOYEEDATACACHE',
    'PAYROLL COMPUTATION' // template / scratch, not a posted run
  ]);

  const out = [];

  sheets.forEach(sh => {
    const name = sh.getName();
    const trimmed = String(name || '').trim();
    if (!trimmed) return;

    const upper = trimmed.toUpperCase();

    // Skip helpers/configs
    if (SKIP_NAMES.has(upper)) return;
    if (trimmed[0] === '_') return; // any other hidden/internal sheets

    const range = sh.getDataRange();
    if (!range) return;

    const values = range.getValues();
    if (!values.length || values.length < 2) return;

    const headers = values[0].map(h => String(h || '').trim());

    const hasEmpId       = headers.some(h => /^Employee ID$/i.test(h));
    const hasEmpName     = headers.some(h => /^Employee Name$/i.test(h));
    const hasPayrollGrp  = headers.some(h => /^Payroll Group$/i.test(h));
    const hasNetPay      = headers.some(h => /^Net Pay$/i.test(h));

    // Only keep sheets that look like payroll computation outputs
    if (!(hasEmpId && hasEmpName && hasPayrollGrp && hasNetPay)) return;

    const isPosted = /\(posted\)$/i.test(trimmed);

    out.push({
      name: trimmed,
      isPosted: isPosted,
      canPost: !isPosted,
      canUnpost: isPosted
    });
  });

  // Unposted first, then alphabetical
  out.sort((a, b) => {
    if (a.isPosted !== b.isPosted) return a.isPosted ? 1 : -1;
    return a.name.localeCompare(b.name);
  });

  return out;
}

function applyPostHistoryAction(payload) {
  payload = payload || {};
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const histSheet = _ensureHistorySheet_();
  const logSheet = _getPostLogSheet_();

  const toPost = Array.isArray(payload.toPost) ? payload.toPost : [];
  const toUnpost = Array.isArray(payload.toUnpost) ? payload.toUnpost : [];

  let postedSheets = 0;
  let totalPostedRows = 0;

  // --- POST SELECTED SHEETS ---
  toPost.forEach(name => {
    const sh = ss.getSheetByName(name);
    if (!sh) return;
    const res = _postPayrollSheetToHistoryCore_(sh, { refresh: false });
    if (res && res.rows > 0) {
      postedSheets++;
      totalPostedRows += res.rows;
    }
  });

  // --- UNPOST SELECTED SHEETS ---
  const logValues = logSheet.getDataRange().getValues();
  if (!logValues.length) {
    // nothing to unpost
  }

  const header = logValues[0].map(h => String(h || '').trim());
  const idxSheetId    = header.indexOf('Sheet ID');
  const idxPostedName = header.indexOf('Posted Sheet Name');
  const idxFirstRow   = header.indexOf('History First Row');
  const idxLastRow    = header.indexOf('History Last Row');
  const idxRowCount   = header.indexOf('Row Count');
  const idxUnpostedAt = header.indexOf('Unposted At');

  const toUnpostSet = new Set(toUnpost);
  const nameToSheet = {};
  ss.getSheets().forEach(sh => (nameToSheet[sh.getName()] = sh));

  const ranges = [];
  const skippedUnpost = [];

  for (let r = 1; r < logValues.length; r++) {
    const row = logValues[r];
    const postedName = String(row[idxPostedName] || '').trim();
    if (!toUnpostSet.has(postedName)) continue;

    const alreadyUnposted = row[idxUnpostedAt];
    if (alreadyUnposted) continue;

    const firstRow = Number(row[idxFirstRow] || 0);
    const lastRow  = Number(row[idxLastRow]  || 0);
    const rowCount = Number(row[idxRowCount] || (lastRow - firstRow + 1));

    if (!firstRow || !lastRow || lastRow < firstRow || rowCount <= 0) {
      skippedUnpost.push(postedName);
      continue;
    }

    const sheet = nameToSheet[postedName];
    if (!sheet) {
      skippedUnpost.push(postedName);
      continue;
    }

    const baseName = postedName.replace(/\s*\(posted\)$/i, '').trim();

    ranges.push({
      sheet: sheet,
      baseName: baseName,
      firstRow: firstRow,
      lastRow: lastRow,
      rowCount: rowCount,
      logRowIndex: r + 1 // 1-based in sheet
    });
  }

  // Delete from bottom to top so row indexes donâ€™t shift
  ranges.sort((a, b) => b.firstRow - a.firstRow);

  let unpostedSheets = 0;
  let totalUnpostedRows = 0;

  ranges.forEach(info => {
  // snapshot cleanup BEFORE rename (sheet name still includes "(Posted)")
  try {
    const postedNameNow = info.sheet.getName(); // e.g. "2025-12 A (Posted)"
    _deletePayslipInputSnapshotForPostedSheet_(ss, postedNameNow);
  } catch (e) {
    Logger.log('âš ï¸ Snapshot delete failed (non-blocking): ' + e.message);
  }

  histSheet.deleteRows(info.firstRow, info.rowCount);
  info.sheet.setName(info.baseName);
  totalUnpostedRows += info.rowCount;
  unpostedSheets++;

  if (idxUnpostedAt >= 0) {
    logSheet
      .getRange(info.logRowIndex, idxUnpostedAt + 1)
      .setValue(new Date());
  }
});


  
  // Returned to the HTML dialog
  return {
    postedSheets,
    totalPostedRows,
    unpostedSheets,
    totalUnpostedRows,
    skippedUnpost
  };
}



/**************************************************
 * HELPERS USED BY postPayrollToHistory_
 **************************************************/

function _ensureHistorySheet_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const name = 'PAYROLL_HISTORY';
  return ss.getSheetByName(name) || ss.insertSheet(name);
}

/**
 * Ensures header in PAYROLL_HISTORY and upserts a row
 * based on (Period, Employee ID, Part).
 */
function _upsertHistoryRow_(histSheet, compHeader, keyValues, rowValues) {
  const baseHdr = ['Period', 'Employee ID', 'Part'];

  // Build desired header for history sheet
  const targetHeader = [...baseHdr];
  compHeader.forEach((h) => {
    if (h && targetHeader.indexOf(h) === -1) {
      targetHeader.push(h);
    }
  });

  const lastCol = histSheet.getLastColumn();
  const existingHeader =
    lastCol > 0
      ? histSheet
          .getRange(1, 1, 1, lastCol)
          .getValues()[0]
          .map(h => String(h || ''))
      : [];

  // If header differs, rewrite it
  const headerChanged =
    existingHeader.length !== targetHeader.length ||
    targetHeader.some((h, i) => existingHeader[i] !== h);

  if (headerChanged) {
    histSheet.getRange(1, 1, 1, targetHeader.length)
      .setValues([targetHeader])
      .setFontWeight('bold');
    if (lastCol > targetHeader.length) {
      histSheet
        .getRange(1, targetHeader.length + 1, 1, lastCol - targetHeader.length)
        .clearContent();
    }
  }

  const periodCol = targetHeader.indexOf('Period') + 1;
  const empIdCol  = targetHeader.indexOf('Employee ID') + 1;
  const partCol   = targetHeader.indexOf('Part') + 1;

  const lastRow = histSheet.getLastRow();
  let existing = [];
  if (lastRow > 1) {
    existing = histSheet
      .getRange(2, 1, lastRow - 1, targetHeader.length)
      .getValues();
  }

  // Look for existing row with same (Period, Employee ID, Part)
  let matchRowIndex = -1;
  for (let i = 0; i < existing.length; i++) {
    const r = existing[i];
    if (
      r[periodCol - 1] === keyValues.period &&
      r[empIdCol  - 1] === keyValues.employeeId &&
      r[partCol   - 1] === keyValues.part
    ) {
      matchRowIndex = i + 2; // +2 because of header row
      break;
    }
  }

  // Build row to write
  const rowToWrite = new Array(targetHeader.length).fill('');

  rowToWrite[periodCol - 1] = keyValues.period || '';
  rowToWrite[empIdCol  - 1] = keyValues.employeeId || '';
  rowToWrite[partCol   - 1] = keyValues.part || '';

  compHeader.forEach((h, i) => {
    const destIdx = targetHeader.indexOf(h);
    if (destIdx !== -1) {
      rowToWrite[destIdx] = rowValues[i];
    }
  });

  if (matchRowIndex === -1) {
    histSheet.appendRow(rowToWrite);
  } else {
    histSheet
      .getRange(matchRowIndex, 1, 1, rowToWrite.length)
      .setValues([rowToWrite]);
  }
}

/**
 * Simple, safe formatting for PAYROLL_HISTORY.
 * No external dependencies.
 */
function _formatHistorySheet_(histSheet) {
  if (!histSheet) return;

  const lastRow = histSheet.getLastRow();
  const lastCol = histSheet.getLastColumn();
  if (lastRow < 1 || lastCol < 1) return;

  histSheet.setFrozenRows(1);

  // Recreate filter on full data range
  const range = histSheet.getRange(1, 1, lastRow, lastCol);
  const existingFilter = histSheet.getFilter();
  if (existingFilter) existingFilter.remove();
  range.createFilter();

  histSheet.autoResizeColumns(1, lastCol);
}

/**
 * Basic formatting for the now-posted computation sheet.
 */
function _formatPostedSheet_(sheet) {
  if (!sheet) return;

  const lastRow = sheet.getLastRow();
  const lastCol = sheet.getLastColumn();
  if (lastRow < 1 || lastCol < 1) return;

  sheet.setFrozenRows(1);
  sheet.getRange(1, 1, 1, lastCol).setFontWeight('bold');
  sheet.autoResizeColumns(1, lastCol);
}




    /* ======================================
    * 4) TABLES, STATUTORY & TAX UTILITIES
    * ====================================== */
    /* ======================================================
    * UPDATED WITHHOLDING TAX LOGIC (Semi-Monthly + Monthly)
    * ======================================================
    * - Uses extended 8-column BIR table with semi & monthly brackets
    * - Computes A using SEMI columns
    * - Computes B = full-month tax âˆ’ Aâ€™s tax (from payroll history)
    * - Works with Freelance % and monthly fallback
    */

    /**
     * Loads the extended BIR tax table.
     * Columns required:
     * EXCESS_OVER_SEMI | MAX_SEMI | FIXED_SEMI | RATE_SEMI |
     * EXCESS_OVER_MONTHLY | MAX_MONTHLY | FIXED_MONTHLY | RATE_MONTHLY
     */
    /**
 * Loads the extended BIR tax table.
 * Columns required:
 * EXCESS_OVER_SEMI | MAX_SEMI | FIXED_SEMI | RATE_SEMI |
 * EXCESS_OVER_MONTHLY | MAX_MONTHLY | FIXED_MONTHLY | RATE_MONTHLY
 */
function _loadBirTable_(sheet) {
  const lr = sheet.getLastRow(), lc = sheet.getLastColumn();
  if (lr < 2 || lc < 8)
    throw new Error(
      'BIR_TABLE must have at least 8 columns: ' +
      'EXCESS_OVER_SEMI, MAX_SEMI, FIXED_SEMI, RATE_SEMI, ' +
      'EXCESS_OVER_MONTHLY, MAX_MONTHLY, FIXED_MONTHLY, RATE_MONTHLY.'
    );

  const normRate = (v) => {
    const n = Number(String(v || '').replace('%', '').trim());
    if (!isFinite(n)) return 0;
    return n > 1 ? n / 100 : n; // accept 20 or 20% or 0.20
  };

  // Allow up to 12 cols: Aâ€“H (semi + monthly), Iâ€“L (annual)
  const colCount = Math.min(lc, 12);
  const raw = sheet.getRange(2, 1, lr - 1, colCount).getValues();

  const rows = raw
    .map(r => {
      const exSemi        = Number(r[0]) || 0;
      const maxSemiBlank  = (r[1] === '' || r[1] == null);
      const maxSemi       = maxSemiBlank ? Infinity : (Number(r[1]) || 0);
      const fixedSemi     = Number(r[2]) || 0;
      const rateSemi      = normRate(r[3]);

      const exMonth       = Number(r[4]) || 0;
      const maxMonthBlank = (r[5] === '' || r[5] == null);
      const maxMonth      = maxMonthBlank ? Infinity : (Number(r[5]) || 0);
      const fixedMonth    = Number(r[6]) || 0;
      const rateMonth     = normRate(r[7]);

      // Optional annual columns: Iâ€“L = EXCESS_OVER_ANNUAL, MAX_ANNUAL, FIXED_ANNUAL, RATE_ANNUAL
      const exAnnual       = colCount >= 9  ? (Number(r[8]) || 0) : 0;
      const maxAnnualBlank = colCount >= 10 ? (r[9] === '' || r[9] == null) : true;
      const maxAnnual      = maxAnnualBlank ? Infinity : (Number(r[9]) || 0);
      const fixedAnnual    = colCount >= 11 ? (Number(r[10]) || 0) : 0;
      const rateAnnual     = colCount >= 12 ? normRate(r[11]) : 0;

      return {
        exSemi, maxSemi, fixedSemi, rateSemi,
        exMonth, maxMonth, fixedMonth, rateMonth,
        exAnnual, maxAnnual, fixedAnnual, rateAnnual
      };
    })
    .filter(r => {
      // Drop rows that are â€œemptyâ€ across ALL three scales
      const semiBlank =
        r.exSemi === 0 && r.maxSemi === Infinity &&
        r.fixedSemi === 0 && r.rateSemi === 0;

      const monthBlank =
        r.exMonth === 0 && r.maxMonth === Infinity &&
        r.fixedMonth === 0 && r.rateMonth === 0;

      const annualBlank =
        r.exAnnual === 0 && r.maxAnnual === Infinity &&
        r.fixedAnnual === 0 && r.rateAnnual === 0;

      return !(semiBlank && monthBlank && annualBlank);
    });

  // Keep original sort behavior (by monthly first, then semi)
  rows.sort((a, b) => a.exMonth - b.exMonth || a.exSemi - b.exSemi);
  return rows;
}



    /**
     * Computes withholding tax using either semi-monthly or monthly rates.
     */
    function _computeWithholdingTaxEx_(taxableIncome, isSemi, birTable) {
      const t = Number(taxableIncome) || 0;
      if (t <= 0) return 0;

      const row = birTable.find(r =>
        t > (isSemi ? r.exSemi : r.exMonth) &&
        t <= (isSemi ? r.maxSemi : r.maxMonth)
      );
      if (!row) return 0;

      if (isSemi)
        return _r2_(row.fixedSemi + (t - row.exSemi) * row.rateSemi);
      else
        return _r2_(row.fixedMonth + (t - row.exMonth) * row.rateMonth);
    }

    function _applyWithholdingTax_(dataMap, context) {
  const {
    empId,              // from core (may be undefined for SPECIAL)
    periodLabel,        // from core (may be undefined for SPECIAL)
    isFreelance,
    consultantTaxRate,
    taxableIncomeForPeriod,
    priorA = {},
    priorMTD = {},
    partLabel,
    cfg,
    bir
  } = context;

  let tax = 0;
  const payFreq = String((cfg && cfg.PAY_FREQUENCY) || '').toLowerCase();
  const isSemi  = payFreq.indexOf('semi') !== -1;
  const part    = String(partLabel || '').toUpperCase();

  // --- CONSULTANTS / FREELANCERS ------------------------------------------
  if (isFreelance) {
    const taxable = Number(taxableIncomeForPeriod) || 0;
    const rate    = Number(consultantTaxRate) || 0;

    tax = taxable * rate; // same as your existing logic

    Logger.log(
      `[WTAX][FREELANCE][${empId || ''}] ` +
      `Period=${periodLabel || ''} taxable=${taxable} rate=${rate} tax=${tax}`
    );

  // --- SEMI-MONTHLY EMPLOYEES (A/B) --------------------------------------
  } else if (isSemi) {
    const taxableA     = _nCI_(priorA, 'Taxable Income');
    const taxAWithheld = Math.abs(_nCI_(priorA, 'Withholding Tax'));
    const taxableB     = Number(taxableIncomeForPeriod) || 0;

    if (part === 'A') {
      // A cutoff: semi table on this cutoff only (current behavior)
      tax = _computeWithholdingTaxEx_(taxableB, /*isSemi=*/true, bir);

      Logger.log(
        `[WTAX][SEMI-A][${empId || ''}] Period=${periodLabel || ''} ` +
        `taxableA_hist=${taxableA} taxA_hist=${taxAWithheld} ` +
        `taxableB=${taxableB} semiTaxA=${tax}`
      );

      if (false)       if (empId && periodLabel) {
        _debugWithholdingTaxRow_({
          empId,
          periodLabel,
          partLabel: part,
          payFrequency: payFreq,
          mode: 'SEMI-A',
          taxableA,
          taxAWithheld,
          taxableB,
          taxableForMonth: taxableA + taxableB,
          taxMonth: null,
          fallbackA: null,
          already: null,
          tax
        });
      }

  if (false)   _debugWithholdingTaxDeep_({
      empId,
      periodLabel,
      partLabel: part,
      payFrequency: payFreq,
      mode: 'SEMI-A',
      taxableIncome: taxableB,   // this is what _computeWithholdingTaxEx_ sees
      birTable: bir,
      isSemi: true,
      finalTax: tax
    });


    } else if (part === 'B') {
      // B cutoff: MONTHLY tax on (A+B), then subtract "already" (current behavior)
      const taxableMonth = taxableA + taxableB;

      const taxMonth  = _computeWithholdingTaxEx_(taxableMonth, /*isSemi=*/false, bir);
      const fallbackA = _computeWithholdingTaxEx_(taxableA,       /*isSemi=*/true,  bir);
      const already   = taxAWithheld;

        // âœ… Allow refund in B if A overwithheld
  tax = _r2_(taxMonth - already);


      // For comparison: what B would be if we *only* used actual A from history
      const expectedB_noFallback = Math.max(0, taxMonth - taxAWithheld);

      Logger.log(
        `[WTAX][SEMI-B][${empId || ''}] Period=${periodLabel || ''} ` +
        `taxableA_hist=${taxableA} taxA_hist=${taxAWithheld} ` +
        `taxableB=${taxableB} taxableMonth=${taxableMonth} ` +
        `taxMonth=${taxMonth} fallbackA=${fallbackA} alreadyUsed=${already} ` +
        `taxB=${tax} expectedB_noFallback=${expectedB_noFallback}`
      );

          if (false)   if (empId && periodLabel) {
        _debugWithholdingTaxRow_({
          empId,
          periodLabel,
          partLabel: part,
          payFrequency: payFreq,
          mode: 'SEMI-B',
          taxableA,
          taxAWithheld,
          taxableB,
          taxableForMonth: taxableMonth,
          taxMonth,
          fallbackA,
          already,
          tax
        });
      }


    } else {
      // Weird part label (e.g. SPECIAL using semi frequency) â€“ treat as monthly on this cutoff
      const taxable = Number(taxableIncomeForPeriod) || 0;
      tax = _computeWithholdingTaxEx_(taxable, /*isSemi=*/false, bir);

      Logger.log(
        `[WTAX][SEMI-OTHER][${empId || ''}] Period=${periodLabel || ''} ` +
        `part=${part} taxable=${taxable} tax=${tax}`
      );
    }

  // --- MONTHLY / SPECIAL USING MONTHLY TABLE ------------------------------
  } else {
    const taxable = Number(taxableIncomeForPeriod) || 0;
    tax = _computeWithholdingTaxEx_(taxable, /*isSemi=*/false, bir);

    Logger.log(
      `[WTAX][MONTHLY-or-SPECIAL][${empId || ''}] Period=${periodLabel || ''} ` +
      `taxable=${taxable} tax=${tax}`
    );
  }

  // Write back to map (unchanged behavior)
  dataMap.set('Withholding Tax', _r2_(-tax));
}


    /* * âœ… UPDATED: SSS table loader to extract MC and MPF components separately
*/
function _loadSssTable_(sheet) {
  const data = sheet.getDataRange().getValues();
  const headers = data.shift().map(h => String(h || '').trim().toUpperCase());

  const IDX = {
    MINBASE: headers.indexOf('MINBASE'),
    MAXBASE: headers.indexOf('MAXBASE'),
    MSC: headers.indexOf('MSC'),
    EE_MC: headers.indexOf('EE_MC'),
    EE_MPF: headers.indexOf('EE_MPF'),
    ER_MC: headers.indexOf('ER_MC'),
    ER_MPF: headers.indexOf('ER_MPF'),
    EC: headers.indexOf('EC')
  };
  const missing = Object.entries(IDX).filter(([k,v]) => v === -1).map(([k]) => k);
  if (missing.length) throw new Error('SSS_TABLE missing: ' + missing.join(', '));

  return data
    .filter(r => r[IDX.MINBASE] && r[IDX.MAXBASE])
    .map(r => ({
      MinBase: Number(r[IDX.MINBASE]),
      MaxBase: Number(r[IDX.MAXBASE]),
      MSC: Number(r[IDX.MSC]),
      // Store components separately
      EE_MC: (Number(r[IDX.EE_MC]) || 0),
      EE_MPF: (Number(r[IDX.EE_MPF]) || 0),
      ER_MC: (Number(r[IDX.ER_MC]) || 0),
      ER_MPF: (Number(r[IDX.ER_MPF]) || 0),
      EC: Number(r[IDX.EC]) || 0,
      // Keep totals for backward compatibility/total calculation
      EE: (Number(r[IDX.EE_MC]) || 0) + (Number(r[IDX.EE_MPF]) || 0),
      ER: (Number(r[IDX.ER_MC]) || 0) + (Number(r[IDX.ER_MPF]) || 0)
    }));
}

/*
* âœ… UPDATED: Statutory computation to return MC/MPF splits
*/
function _computeStatutoryForPeriod_({
  baseMonthlySSSPI,
  baseMonthlyPH,
  getModeFor,
  sssTable,
  isFullPeriod,
  priorTaken,
  partLabel,
  cfg,
  isDailyPayBasis,
  empId,
  periodLabel // âœ… NEW
}) {

  // Inputs-only runs never carry statutories unless you explicitly add them.
  if (String(partLabel).toUpperCase() === 'SPECIAL') {
    return { 
      sssEe:0, sssEeMc:0, sssEeMpf:0,
      sssEr:0, sssErMc:0, sssErMpf:0,
      sssEc:0, 
      phEe:0, phEr:0, piEe:0, piEr:0 
    };
  }

  const n = (x) => Number(x) || 0;
  const isSemi = String(cfg.PAY_FREQUENCY || '').toLowerCase().includes('semi');
  const AorB   = String(partLabel || '').toUpperCase();

  // ---------- MONTHLY FULL VALUES (before per-cutoff mode) ----------
  // SSS (table row gives monthly totals)
  const sssRow = _sssRowForSalary_(baseMonthlySSSPI, sssTable) || { 
    EE:0, EE_MC:0, EE_MPF:0, 
    ER:0, ER_MC:0, ER_MPF:0, 
    EC:0 
  };
  
  // PhilHealth: clamp base then EE/ER = 50/50 of monthly
  const PH_FLOOR   = n(cfg.PH_MIN_BASE) > 0 ? n(cfg.PH_MIN_BASE) : 10000;
  const PH_CEILING = n(cfg.PH_MAX_BASE) > 0 ? n(cfg.PH_MAX_BASE) : 100000;
  const PH_RATE    = n(cfg.PH_RATE) > 0 ? n(cfg.PH_RATE) : 0.05;
  const phMonthlyBase   = _clamp_(n(baseMonthlyPH), PH_FLOOR, PH_CEILING);
  const phMonthlyTotal  = phMonthlyBase * PH_RATE;      // EE+ER
  const phEeFull        = phMonthlyTotal / 2;
  const phErFull        = phMonthlyTotal / 2;

  // Pag-IBIG (HDMF): clamp to max base
const piBase   = Math.min(n(baseMonthlySSSPI), n(cfg.PAGIBIG_MAX_BASE) || 10000);
let piEeFull = piBase * n(cfg.PAGIBIG_EE_RATE);
let piErFull = piBase * n(cfg.PAGIBIG_ER_RATE);

// âœ… DAILY pay basis + Semi-monthly A: enforce minimum MONTHLY Pag-IBIG cap at 100
// so that the Part A "minimum 100" will not get capped by due().
if (isDailyPayBasis && isSemi && AorB === 'A') {
  if (piEeFull > 0 && piEeFull < 100) piEeFull = 100;
  if (piErFull > 0 && piErFull < 100) piErFull = 100;
}



  // ---------- PER-CUTOFF SHARE (apply component mode) ----------
const shareForCutoff = (fullAmt, mode, part) => {
  const m = String(mode || 'split').toLowerCase();
  const p = String(part || '').toUpperCase();

  

  // existing behavior: split = A half, B wants full (catch-up capped by due())
  if (m === 'split')  return (p === 'A') ? (fullAmt / 2) : fullAmt;

  if (m === 'first')  return p === 'A' ? fullAmt : 0;
  if (m === 'second') return p === 'B' ? fullAmt : 0;
  return fullAmt;
};




  const sssMode = getModeFor('SSS EE');
  const phMode  = getModeFor('PhilHealth EE');
  const piMode  = getModeFor('Pag-IBIG EE');

  // Calculate Breakdown shares
  let sssEeMcWant  = shareForCutoff(sssRow.EE_MC, sssMode, AorB);
  let sssEeMpfWant = shareForCutoff(sssRow.EE_MPF, sssMode, AorB);
  let sssErMcWant  = shareForCutoff(sssRow.ER_MC, sssMode, AorB);
  let sssErMpfWant = shareForCutoff(sssRow.ER_MPF, sssMode, AorB);
  let sssEcWant    = shareForCutoff(sssRow.EC, sssMode, AorB);

  let phEeWant  = shareForCutoff(phEeFull,  phMode,  AorB);
  let phErWant  = shareForCutoff(phErFull,  phMode,  AorB);

  // âœ… DAILY pay basis + Semi-monthly A: PhilHealth should take FULL monthly EE/ER in A
// so B becomes (monthly - A) via due() cap enforcement.
if (isDailyPayBasis && isSemi && String(AorB) === 'A') {
  const m = String(phMode || 'split').toLowerCase();
  if (m === 'split') {
    phEeWant = phEeFull;
    phErWant = phErFull;
  }
}

  let piEeWant  = shareForCutoff(piEeFull,  piMode,  AorB);
  let piErWant  = shareForCutoff(piErFull,  piMode,  AorB);

  // âœ… DAILY pay basis + Semi-monthly A:
// SSS in A should take the FULL MONTHLY amount (B becomes monthly - A via due())
if (isDailyPayBasis && isSemi && AorB === 'A') {
  sssEeMcWant  = sssRow.EE_MC;
  sssEeMpfWant = sssRow.EE_MPF;
  sssErMcWant  = sssRow.ER_MC;
  sssErMpfWant = sssRow.ER_MPF;
  sssEcWant    = sssRow.EC;
}


  // âœ… DAILY pay basis + Semi-monthly A: Pag-IBIG MUST remain split (A = half)
if (isDailyPayBasis && isSemi && String(AorB) === 'A') {
  const m = String(piMode || 'split').toLowerCase();
  if (m === 'split') {
    piEeWant = piEeFull / 2;
    piErWant = piErFull / 2;
  }
}

// âœ… DAILY pay basis + Semi-monthly A: minimum Pag-IBIG for Part A
// (Apply only if this cutoff is actually collecting something.)
if (isDailyPayBasis && isSemi && String(AorB) === 'A') {
  if (piEeWant > 0 && piEeWant < 100) piEeWant = 100;
  if (piErWant > 0 && piErWant < 100) piErWant = 100;
}


  // ---------- MONTHLY CAP ENFORCEMENT ----------
// NOTE: History headers may vary ("PAGIBIG EE" vs "Pag-IBIG EE", etc.).
// _nCI_ now supports normalized matching; this adds SSS total â†’ MC/MPF fallback.
const takenRaw = (k) => _nCI_(priorTaken, k);

const taken = (k) => {
  const ku = String(k || '').trim().toUpperCase();

  // If history only has totals ("SSS EE"/"SSS ER"), allocate totals into MC first then MPF.
  if (ku === 'SSS EE MC' || ku === 'SSS EE MPF') {
    const mc = takenRaw('SSS EE MC');
    const mpf = takenRaw('SSS EE MPF');
    if (mc || mpf) return ku.endsWith('MC') ? mc : mpf;

    const total = takenRaw('SSS EE');
    if (!total) return 0;

    const mcCap = n(sssRow.EE_MC);
    const mpfCap = n(sssRow.EE_MPF);

    const allocMc = Math.min(total, mcCap);
    const allocMpf = Math.min(Math.max(0, total - allocMc), mpfCap);

    return ku.endsWith('MC') ? allocMc : allocMpf;
  }

  if (ku === 'SSS ER MC' || ku === 'SSS ER MPF') {
    const mc = takenRaw('SSS ER MC');
    const mpf = takenRaw('SSS ER MPF');
    if (mc || mpf) return ku.endsWith('MC') ? mc : mpf;

    const total = takenRaw('SSS ER');
    if (!total) return 0;

    const mcCap = n(sssRow.ER_MC);
    const mpfCap = n(sssRow.ER_MPF);

    const allocMc = Math.min(total, mcCap);
    const allocMpf = Math.min(Math.max(0, total - allocMc), mpfCap);

    return ku.endsWith('MC') ? allocMc : allocMpf;
  }

  return takenRaw(k);
};

if (false) Logger.log('[SSS][TAKENCHK][%s] taken(EE MC)=%s taken(EE MPF)=%s taken(EE TOTAL)=%s fullMC=%s fullMPF=%s',
  empId,
  taken('SSS EE MC'),
  taken('SSS EE MPF'),
  taken('SSS EE'),
  sssRow.EE_MC,
  sssRow.EE_MPF
);


 // Helper: Calculate due amount for a component based on its specific monthly limit
// âœ… Allow refunds in Semi-monthly B when A overdeducted (taken > full).
// - In A: never refund (cap at 0).
// - In B: if overdeducted, return a NEGATIVE due so the payroll line becomes a refund.
const due = (want, full, key) => {
  const rem = (Number(full) || 0) - (Number(taken(key)) || 0);

  // Refund logic applies only to semi-monthly Part B
  if (isSemi && String(AorB) === 'B' && rem < 0) {
    return rem; // negative = refund of the overdeducted amount
  }

  // Normal behavior (no refunds)
  const remaining = Math.max(0, rem);
  return Math.min(remaining, Number(want) || 0);
};




  const sssEeMc  = due(sssEeMcWant, sssRow.EE_MC, 'SSS EE MC');
  const sssEeMpf = due(sssEeMpfWant, sssRow.EE_MPF, 'SSS EE MPF');
  const sssEe    = sssEeMc + sssEeMpf; // Total

  const sssErMc  = due(sssErMcWant, sssRow.ER_MC, 'SSS ER MC');
  const sssErMpf = due(sssErMpfWant, sssRow.ER_MPF, 'SSS ER MPF');
  const sssEr    = sssErMc + sssErMpf; // Total

  const sssEc    = due(sssEcWant, sssRow.EC, 'SSS EC');

  if (isSemi && String(sssMode || '').toLowerCase() === 'split') {
  Logger.log(
    `[SSS][SPLIT][${empId || ''}] Period=${periodLabel || ''} Part=${AorB} ` +
    `baseSSS=${_r2_(baseMonthlySSSPI)} ` +
    `EE_MC(full)=${_r2_(sssRow.EE_MC)} want=${_r2_(sssEeMcWant)} taken=${_r2_(taken('SSS EE MC'))} due=${_r2_(sssEeMc)} | ` +
    `EE_MPF(full)=${_r2_(sssRow.EE_MPF)} want=${_r2_(sssEeMpfWant)} taken=${_r2_(taken('SSS EE MPF'))} due=${_r2_(sssEeMpf)}`
  );
}


  const phEe  = due(phEeWant,  phEeFull,  'PhilHealth EE');
  const phEr  = due(phErWant,  phErFull,  'PhilHealth ER');

    // DEBUG: verify split logic (B should be monthly - A via due() and priorTaken)
  if (isSemi && String(phMode || '').toLowerCase() === 'split') {
    Logger.log(
      `[PH][SPLIT][${empId || ''}] Period=${periodLabel || ''} Part=${AorB} ` +
      `basePH=${_r2_(phMonthlyBase)} rate=${PH_RATE} ` +
      `EE(full)=${_r2_(phEeFull)} want=${_r2_(phEeWant)} taken=${_r2_(taken('PhilHealth EE'))} due=${_r2_(phEe)} | ` +
      `ER(full)=${_r2_(phErFull)} want=${_r2_(phErWant)} taken=${_r2_(taken('PhilHealth ER'))} due=${_r2_(phEr)}`
    );
  }

  const piEe  = due(piEeWant,  piEeFull,  'Pag-IBIG EE');
  const piEr  = due(piErWant,  piErFull,  'Pag-IBIG ER');

  return { 
    sssEe, sssEeMc, sssEeMpf,
    sssEr, sssErMc, sssErMpf,
    sssEc, 
    phEe, phEr, piEe, piEr 
  };
}

    function _sssRowForSalary_(salary, sssTable){
  const s = Number(salary) || 0;
  if (!sssTable || !sssTable.length) return null;

  // Assumes table is sorted from lowest to highest bracket
  const first = sssTable[0];
  const last  = sssTable[sssTable.length - 1];

  // âœ… Below minimum bracket â†’ use FIRST row (not max)
  if (s <= Number(first.MaxBase)) return first;

  // âœ… Above maximum bracket â†’ use LAST row
  if (s >= Number(last.MinBase)) return last;

  // âœ… Normal match within table
  return sssTable.find(row => s >= Number(row.MinBase) && s <= Number(row.MaxBase)) || last;
}


    function _monthlyEEContrib_(monthlySalary, cfg, sssTable) {
      const sssRow = _sssRowForSalary_(monthlySalary, sssTable);
      const phBase = _clamp_(monthlySalary, cfg.PH_MIN_BASE, cfg.PH_MAX_BASE);
      const piBase = Math.min(monthlySalary, cfg.PAGIBIG_MAX_BASE);
      const sssEe = sssRow ? sssRow.EE : 0;
      const phEe  = (phBase * cfg.PH_RATE)/2;
      const piEe  = piBase * cfg.PAGIBIG_EE_RATE;
      return _r2_(sssEe + phEe + piEe);
    }

    
/**
 * Build a map of Employee ID â†’ YTD total for components categorized as
 * "13th Month Pay and Other Benefits" for a given calendar year.
 * Uses PAYROLL_HISTORY + componentMap classification.
 */
function _loadYtdOtherBenefitsMap_(histSheet, year, componentMap) {
  const map = new Map();
  if (!histSheet || histSheet.getLastRow() < 2) return map;

  const data = histSheet.getDataRange().getValues();
  const headers = data[0].map(h => String(h || '').trim());
  const rows = data.slice(1);

  const idxEmp = headers.findIndex(h => /^Employee ID$/i.test(h));
  const idxPeriod = headers.findIndex(h => /^Period$/i.test(h));
  const idxPayrollMonth = headers.findIndex(h => /^Payroll Month$/i.test(h));

  if (idxEmp === -1) return map;

  // Identify columns that are tagged as "13th Month Pay and Other Benefits"
  const benefitColIdx = [];
  headers.forEach((h, i) => {
    const cat = (_classifyComponent_(h, componentMap) || '').toLowerCase();
    if (cat === '13th month pay and other benefits') {
      benefitColIdx.push(i);
    }
  });

  if (!benefitColIdx.length) return map;

  rows.forEach(r => {
    const empId = String(r[idxEmp] || '').trim();
    if (!empId) return;

    // Resolve row year from Payroll Month (e.g. "November 2025") or Period ("2025-11-A")
    let rowYear = null;

    if (idxPayrollMonth > -1 && r[idxPayrollMonth]) {
      const s = String(r[idxPayrollMonth]);
      const m = s.match(/(\d{4})/);
      if (m) rowYear = Number(m[1]);
    }

    if (rowYear == null && idxPeriod > -1 && r[idxPeriod]) {
      const s = String(r[idxPeriod]);
      const m = s.match(/^(\d{4})-/);
      if (m) rowYear = Number(m[1]);
    }

    if (rowYear !== year) return;

    let sum = map.get(empId) || 0;
    benefitColIdx.forEach(c => {
      const v = Number(r[c]) || 0;
      sum += v;
    });
    map.set(empId, sum);
  });

  return map;
}


    /* ======================================
    * 5) ADJUSTMENTS + HISTORY + COMPUTATION
    * ====================================== */
    /**
   * Loads and aggregates Inputs (Adjustments) by Employee ID + Description.
   * Works universally for all types â€” Overtime, Absences, Adjustments, etc.
   */
  function _loadInputsWithin_(sheet) {
    if (!sheet) return [];
    const lr = sheet.getLastRow();
    if (lr < 2) return [];

    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0].map(s => String(s || '').trim());
    const IDX = {
      EMP_ID: _findHeaderFuzzy_(headers, ['Employee ID','Emp ID']),
      NAME:   _findHeaderFuzzy_(headers, ['Adjustment Name','Description','Type']),
      AMT:    _findHeaderFuzzy_(headers, ['Amount','Amt','Value']),
      CAT:    _findHeaderFuzzy_(headers, ['Payroll Category'])
    };

    // --- Raw rows ---
    const raw = sheet.getRange(2, 1, lr - 1, sheet.getLastColumn()).getValues()
      .map(r => ({
        empId: String(r[IDX.EMP_ID] || '').trim(),
        name:  String(r[IDX.NAME]   || '').trim(),
        amt:   _toNumber_(r[IDX.AMT] || 0),
        cat:   String(r[IDX.CAT]    || '').trim()
      }))
      .filter(x => x.empId && x.name);

    // --- âœ… Aggregate by Employee ID + Description (case-insensitive) ---
    const grouped = new Map();
    raw.forEach(r => {
      const key = `${r.empId}||${r.name.toLowerCase()}`;
      const prev = grouped.get(key);
      if (prev) {
        prev.amt += Number(r.amt) || 0;
      } else {
        grouped.set(key, { empId: r.empId, name: r.name, amt: Number(r.amt) || 0, cat: r.cat });
      }
    });

    return Array.from(grouped.values());
  }


function _loadAbsencesTardinessDirect_(ss) {
  if (!ss) return [];

  const sh = ss.getSheetByName('Absences_Tardiness');
  if (!sh || sh.getLastRow() < 2) return [];

  const headers = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0].map(h => String(h || '').trim());

  const idxEmpId = _findHeaderFuzzy_(headers, ['Employee ID','Emp ID','EmployeeID']);
  const idxName  = _findHeaderFuzzy_(headers, ['Employee Name','Name']);
  const idxType  = _findHeaderFuzzy_(headers, ['Type']);
  const idxAmt   = _findHeaderFuzzy_(headers, ['Amount','Amt','Total','Computed Amount','Net Amount']);

  if (idxEmpId < 0 || idxType < 0 || idxAmt < 0) return [];

  const vals = sh.getRange(2, 1, sh.getLastRow() - 1, sh.getLastColumn()).getValues();

  // Return in the same schema _loadInputsWithin_ returns: {empId,name,amt,cat}
  // âœ… Force cat = "Basic Pay Related" (this is exactly what rebuildInputsSummary does)
  const out = [];
  vals.forEach(r => {
    const empId = String(r[idxEmpId] || '').trim();
    if (!empId) return;

    const type = String(r[idxType] || '').trim(); // "ABSENCE" / "TARDINESS"
    if (!type) return;

    const amt = _toNumber_(r[idxAmt] || 0);
    if (Math.abs(amt) < 0.01) return;

    out.push({
      empId,
      name: type,
      amt,
      cat: 'Basic Pay Related'
    });
  });

  return out;
}


function _loadAttendanceDaysMap_(attendanceSheet) {
  const map = new Map();
  if (!attendanceSheet) return map;

  const lastRow = attendanceSheet.getLastRow();
  if (lastRow < 2) return map;

  const headers = attendanceSheet
    .getRange(1, 1, 1, attendanceSheet.getLastColumn())
    .getValues()[0]
    .map(h => String(h || '').trim());

  const idxEmp  = _findHeaderFuzzy_(headers, ['Employee ID','Emp ID']);
  const idxDays = _findHeaderFuzzy_(headers, ['Days Worked','Days']);

  if (idxEmp < 0 || idxDays < 0) return map;

  const data = attendanceSheet
    .getRange(2, 1, lastRow - 1, attendanceSheet.getLastColumn())
    .getValues();

  data.forEach(r => {
    const empId = String(r[idxEmp] || '').trim();
    if (!empId) return;

    const days = _toNumber_(r[idxDays] || 0);
    if (!days) return;

    map.set(empId, (map.get(empId) || 0) + days); // supports multiple rows per employee
  });

  return map;
}


    function _isOtherBenefit_(desc) {
        const rx = /(13th|thirteenth|bonus|incentive|leave\s*conversion|vl\s*conversion|sl\s*conversion)/i;
        return rx.test(desc);
    }

    function _isUnworkedTime_(desc) {
        const d = String(desc || '').toLowerCase();
        return d === 'absence' || d === 'tardiness';
    }

    function _isSalaryAdjustment_(desc) {
        const d = String(desc || '').toLowerCase();
        return d.includes('salary adj') || d.includes('retro pay') || d.includes('pay adjustment');
    }

    function isDeductionComponent(header) {
        const upperHeader = header.toUpperCase();
        const deductionKeywords = ['LOAN', 'DEDUCTION', 'DEDUK', 'CALAMITY'];
        return deductionKeywords.some(k => upperHeader.includes(k));
    }



function _writeComputation_(sheet, header, rows) {
  sheet.clear();
  if (!rows || !rows.length) {
    sheet.getRange('A1').setValue('No rows.');
    return;
  }

  // --- Normalize header ---
  let H = header.map(h => String(h || '').trim());
  let HU = H.map(h => h.toUpperCase());

  // Meta block: everything up to (and including) "PAYROLL MONTH" is always kept
  const payMonthIdx = HU.indexOf('PAYROLL MONTH');
  const alwaysKeepIdx = new Set();
  if (payMonthIdx >= 0) {
    for (let i = 0; i <= payMonthIdx; i++) alwaysKeepIdx.add(i);
  }

  // --- Decide which columns actually have data (beyond the meta block) ---
  const colHasData = H.map((_, colIdx) => {
    if (alwaysKeepIdx.has(colIdx)) return true; // meta block always kept

    return rows.some(r => {
      const v = r[colIdx];
      if (v === '' || v == null) return false;

      const s = String(v).trim();
      if (s === '') return false;

      const n = Number(s.replace(/,/g, ''));
      if (!isNaN(n)) return n !== 0; // non-zero numeric counts as data

      return true; // any non-empty non-numeric also counts as data
    });
  });

  const normKey = (name) => String(name || '').trim().toUpperCase();

  // --- Build a de-duplicated column plan ---
  // meta: [{ name, key, sourceCols: [indices...] }]
  const meta = [];
  const keyToMetaIdx = new Map();

  H.forEach((name, colIdx) => {
    if (!colHasData[colIdx]) return; // drop empty columns outside meta

    const key = normKey(name);
    let mIdx = keyToMetaIdx.get(key);

    if (mIdx == null) {
      mIdx = meta.length;
      keyToMetaIdx.set(key, mIdx);
      meta.push({ name, key, sourceCols: [colIdx] });
    } else {
      // Duplicate header â†’ merge into existing column
      meta[mIdx].sourceCols.push(colIdx);
    }
  });

  // Final header after removing empty columns + merging duplicates
  const finalHeader = meta.map(m => m.name);

  // --- Project & merge rows according to meta plan ---
  const mergedRows = rows.map(row => {
    return meta.map(m => {
      let numSum = 0;
      let sawNumber = false;
      let textVal = '';

      m.sourceCols.forEach(colIdx => {
        const v = row[colIdx];
        if (v === '' || v == null) return;

        const s = String(v).trim();
        if (s === '') return;

        const n = Number(s.replace(/,/g, ''));
        if (!isNaN(n)) {
          numSum += n;
          sawNumber = true;
        } else if (!textVal) {
          textVal = v; // keep first non-blank text
        }
      });

      if (sawNumber) return numSum;
      if (textVal)   return textVal;
      return '';
    });
  });

  // --- Rounding: decide where the money columns start ---
  const HU_final = finalHeader.map(h => String(h || '').trim().toUpperCase());
  let numStartIdx = HU_final.indexOf('BASIC PAY');
  if (numStartIdx === -1) numStartIdx = HU_final.indexOf('GROSS PAY');
if (numStartIdx === -1) numStartIdx = HU_final.indexOf('SSS EE MC'); // last resort


  const roundedRows = (numStartIdx >= 0)
    ? mergedRows.map(r => r.map((v, i) => {
        if (i < numStartIdx) return v;
        const n = Number(String(v).replace(/,/g, ''));
        return isFinite(n) ? _r2_(n) : v;  // assumes _r2_ helper exists
      }))
    : mergedRows;

  // --- Write to sheet ---
  sheet.getRange(1, 1, 1, finalHeader.length)
    .setValues([finalHeader])
    .setFontWeight('bold');

  sheet.getRange(2, 1, roundedRows.length, finalHeader.length)
    .setValues(roundedRows);

  sheet.autoResizeColumns(1, finalHeader.length);
  sheet.getRange('A1').setNote(
    `Generated ${roundedRows.length} Â· ${new Date().toLocaleString()}`
  );

  // --- Visual cleanup: hide any remaining empty columns ---
  try {
    const range = sheet.getDataRange();
    const values = range.getValues();
    const headerRow = values[0];
    const body = values.slice(1);

    for (let c = 0; c < headerRow.length; c++) {
      const colVals = body.map(r => r[c]);
      const hasData = colVals.some(v => v !== '' && Number(v) !== 0);
      if (!hasData) sheet.hideColumns(c + 1);
    }

    SpreadsheetApp.getActive().toast('âœ… Payroll generated', 'Payroll', 5);
  } catch (err) {
    Logger.log('âš ï¸ Hide-column routine failed: ' + err.message);
  }
}


    function _ensureHistorySheet_() {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      return ss.getSheetByName('PAYROLL_HISTORY') || ss.insertSheet('PAYROLL_HISTORY');
    }
    

    /* ===================================
    * 6) SETTINGS & LOOKUPS / GROUP DAYS
    * =================================== */
    function _loadComponentModes_() {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      const sh = ss.getSheetByName('PAYROLL_COMPONENT_MODES');
      const map = new Map();
      if (!sh) return map;
      const lr = sh.getLastRow();
      if (lr < 2) return map;

      // Read A:C (Component, Category, Mode)
      sh.getRange(2, 1, lr - 1, 3).getValues().forEach(([component, _category, mode]) => {
        const key = String(component || '').trim();
        const val = String(mode || 'split').trim().toLowerCase();
        if (key && ['split', 'first', 'second', 'full'].includes(val)) map.set(key, val);
      });
      return map;
    }


    function _loadEmployeeOverrides_() {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      const sh = ss.getSheetByName('EMPLOYEE_MODE_OVERRIDES');
      const map = new Map();
      if (!sh || sh.getLastRow() < 2) return map;

      const data = sh.getRange(2, 1, sh.getLastRow() - 1, 4).getValues();
      data.forEach(row => {
        const empId = String(row[1] || '').trim();
        const component = String(row[2] || '').trim();
        const mode = String(row[3] || '').trim().toLowerCase();
        if (empId && component && ['split', 'first', 'second'].includes(mode)) {
          map.set(`${empId}-${component}`, mode);
        }
      });
      return map;
    }

function _readSettingsBase_() {
  const props = _clientSettingsProps_().getProperties();

  const num = (v, def = 0) => isNaN(Number(v)) ? def : Number(v);
  const str = (v, def = '') => String(v == null ? def : v).trim();
  const id  = (v) => {
    const m = String(v || '').match(/[-\w]{25,}/);
    return m ? m[0] : '';
  };

  // Fallback to older keys + raw keys if needed
  const source = props.SOURCE_SS_ID || props.masterIdOrUrl || props.SOURCE_SS_RAW || '';
  const inputs = props.INPUTS_SS_ID || props.inputsIdOrUrl || props.INPUTS_SS_RAW || '';
  const masterSheet = props.MASTER_SHEET_NAME || props.masterSheetName || 'Masterfile Import';

  return {
    SOURCE_SS_ID: id(source),
    INPUTS_SS_ID: id(inputs),
    MASTER_SHEET_NAME: str(masterSheet, 'Masterfile Import'),

    PAY_FREQUENCY: str(props.PAY_FREQUENCY || 'semi-monthly').toLowerCase(),
    WORKING_DAYS_PER_YEAR: num(props.WORKING_DAYS_PER_YEAR || 261),
    PH_RATE: num(props.PH_RATE || 0.05),
    PH_MIN_BASE: num(props.PH_MIN_BASE) > 0 ? num(props.PH_MIN_BASE) : 10000,
    PH_MAX_BASE: num(props.PH_MAX_BASE) > 0 ? num(props.PH_MAX_BASE) : 100000,
    PAGIBIG_EE_RATE: num(props.PAGIBIG_EE_RATE || 0.02),
    PAGIBIG_ER_RATE: num(props.PAGIBIG_ER_RATE || 0.02),
    PAGIBIG_MAX_BASE: num(props.PAGIBIG_MAX_BASE || 10000),

    componentModes: _loadComponentModes_(),
    employeeOverrides: _loadEmployeeOverrides_(),
  };
}

// Keep the public name for everything existing
function _readSettings_() {
  return _readSettingsBase_();
}


function migrateClientSettingsToDocumentProps() {
  const defaults = getDefaultSettings_(); // your canonical key list
  const src = PropertiesService.getScriptProperties();
  const dst = PropertiesService.getDocumentProperties();

  Object.keys(defaults).forEach(k => {
    const v = src.getProperty(k);
    if (v != null && v !== '') dst.setProperty(k, v);
  });

  SpreadsheetApp.getActive().toast('âœ… Migrated settings to this file (Document Properties).', 'Settings', 5);
  return true;
}


    function _getIdFromNameInCache_(name) {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      const cacheSheet = ss.getSheetByName('_EmployeeDataCache');
      if (!cacheSheet) {
        SpreadsheetApp.getActive().toast('Employee cache not found. Please run "Setup Overrides Sheet" again.', 'Error', 8);
        return '';
      }
      const data = cacheSheet.getDataRange().getValues();
      for (let i = 1; i < data.length; i++) {
        if (String(data[i][1]).trim().toLowerCase() === String(name).trim().toLowerCase()) {
          return data[i][0]; 
        }
      }
      return '';
    }

    function _openLinkedFiles_(cfg, activeSS) {
      const sourceSS = SpreadsheetApp.openById(cfg.SOURCE_SS_ID);
      const inputsSS = cfg.INPUTS_SS_ID ? SpreadsheetApp.openById(cfg.INPUTS_SS_ID) : null;
      return { sourceSS, inputsSS };
    }


function _loadRecurringAdjustments_(sourceSS, ctx) {
  try {
    if (!sourceSS) return [];

    const partLabelFromCtx = String(ctx && ctx.partLabel || '').toUpperCase();

    // ðŸš« SPECIAL runs: do NOT load recurring adjustments at all
    // SPECIAL should rely ONLY on Inputs/Adjustment file.
    if (partLabelFromCtx === 'SPECIAL') {
      return [];
    }

    const sheet =
      sourceSS.getSheetByName('Recurring Adjustments') ||
      sourceSS.getSheetByName('AdjustmentSchedule'); // fallback for legacy name

    if (!sheet) return [];

    const lastRow = sheet.getLastRow();
    if (lastRow < 2) return [];

    const headers = sheet
      .getRange(1, 1, 1, sheet.getLastColumn())
      .getValues()[0]
      .map(h => String(h || '').trim());

    const IDX = {
      EMP_ID: _findHeaderFuzzy_(headers, ['Employee ID','Emp ID']),
      NAME:   _findHeaderFuzzy_(headers, ['Adjustment Name','Description','Type']),
      AMT:    _findHeaderFuzzy_(headers, ['Amount per payroll','Amount','Amt','Value']),
      MAX:    _findHeaderFuzzy_(headers, ['Maximum Amount','Max Amount','Cap']),
      MODE:   _findHeaderFuzzy_(headers, ['Mode','Mode (SPLIT / 1ST / 2ND)','Mode (1ST HALF / 2ND HALF)','Split']),
      CAT:    _findHeaderFuzzy_(headers, ['Payroll Category']),
      START:  _findHeaderFuzzy_(headers, ['Start Date','Start']),
      END:    _findHeaderFuzzy_(headers, ['End Date','Until'])
    };

    if (IDX.EMP_ID < 0 || IDX.NAME < 0 || IDX.AMT < 0) {
      Logger.log('Recurring Adjustments: missing required columns (Employee ID / Adjustment Name / Amount).');
      return [];
    }

    const raw = sheet
      .getRange(2, 1, lastRow - 1, sheet.getLastColumn())
      .getValues();

    // ðŸ”¹ Normalise payroll dates to pure date (no time) to avoid off-by-one
    const rangeStart = ctx && ctx.rangeStart ? _stripTime(ctx.rangeStart) : null;
    const rangeEnd   = ctx && ctx.rangeEnd   ? _stripTime(ctx.rangeEnd)   : null;
    const partLabel  = partLabelFromCtx;        // 'A','B','M', etc.
    const periodKey  = String(ctx && ctx.periodKey || '');
    const hist       = (ctx && ctx.hist) || _ensureHistorySheet_();

const payBasisMap = (ctx && ctx.payBasisMap) ? ctx.payBasisMap : null;
const attendanceDaysMap = (ctx && ctx.attendanceDaysMap) ? ctx.attendanceDaysMap : null;

const _normCat_ = (s) => String(s || '').replace(/\s+/g, ' ').trim().toUpperCase();
const DAILY_RECUR_CATS = new Set([
  'NON-TAXABLE EARNING - DE MINIMIS',
  'NON-TAXABLE EARNING - OTHER',
  'TAXABLE EARNING'
]);


    const toDate = v => (v instanceof Date ? v : (v ? new Date(v) : null));

    // ---------- 1st pass: date window (inclusive) + mode (SPLIT/1ST/2ND) ----------
    const candidates = [];
    raw.forEach(row => {
      const empId = String(row[IDX.EMP_ID] || '').trim();
      const name  = String(row[IDX.NAME]   || '').trim();
      if (!empId || !name) return;

      const monthlyAmt = _toNumber_(row[IDX.AMT] || 0);
      if (!monthlyAmt) return;

      const maxAmt = IDX.MAX > -1 ? _toNumber_(row[IDX.MAX] || 0) : 0;
      const catRaw = IDX.CAT > -1 ? String(row[IDX.CAT] || '').trim() : '';
      const cat    = catRaw || '';

      const startDate = IDX.START > -1 ? _stripTime(toDate(row[IDX.START])) : null;
      const endDate   = IDX.END   > -1 ? _stripTime(toDate(row[IDX.END]))   : null;

      // === Date window logic (inclusive) ===
      // - If Start Date falls within Fromâ€“To â†’ starts on that run.
      // - If End Date is still within Fromâ€“To â†’ included on that run.
      // - Blank Start â†’ treated as "from the beginning".
      // - Blank End   â†’ treated as "no end / ongoing".
      if (rangeStart && rangeEnd) {
        if (startDate && startDate > rangeEnd) return;   // starts after the period
        if (endDate && endDate < rangeStart) return;     // ended before the period
      }

      // Mode handling
let include = true;
let amtForThisRun = monthlyAmt;

// âœ… DAILY pay-basis recurring:
// If Pay Basis = DAILY AND category is one of the DAILY_RECUR_CATS,
// then "Amount per payroll" is treated as DAILY RATE and multiplied by Days Worked.
// Mode is ignored (no split/1st/2nd) because the days worked already reflect the period.
if (payBasisMap && attendanceDaysMap) {
  const pb = String(payBasisMap.get(empId) || '').trim().toUpperCase();
  if (pb === 'DAILY' && DAILY_RECUR_CATS.has(_normCat_(cat))) {
    const days = Number(attendanceDaysMap.get(empId) || 0);
    amtForThisRun = _toNumber_(monthlyAmt * days);
    if (!amtForThisRun) return;

    candidates.push({
      empId,
      name,
      baseAmt: amtForThisRun,
      maxAmt,
      cat
    });
    return;
  }
}

// Mode handling (existing behavior)
const rawMode = IDX.MODE > -1 ? String(row[IDX.MODE] || '').trim().toUpperCase() : '';
const norm    = rawMode.replace(/\s|\.|HALF/g, ''); // e.g. "1ST HALF" â†’ "1ST"

if (partLabel === 'A' || partLabel === 'B') {
  if (norm === '1ST') {
    include = (partLabel === 'A');
    amtForThisRun = monthlyAmt;
  } else if (norm === '2ND') {
    include = (partLabel === 'B');
    amtForThisRun = monthlyAmt;
  } else {
    include = true;
    amtForThisRun = monthlyAmt / 2;
  }
} else {
  include = true;
  amtForThisRun = monthlyAmt;
}


      if (!include) return;

      candidates.push({
        empId,
        name,
        baseAmt: amtForThisRun, // already adjusted for split/1st/2nd
        maxAmt,
        cat
      });
    });

    if (!candidates.length) return [];

    // ---------- 2nd pass: lifetime usage vs Maximum Amount ----------
    const usedMap = new Map();
    if (hist && hist.getLastRow() >= 2) {
      const data = hist.getDataRange().getValues();
      const hdr  = data[0].map(h => String(h || '').trim());
      const rowsH = data.slice(1);

      const idxEmp   = hdr.findIndex(h => /^Employee ID$/i.test(h));
      const idxPer   = hdr.findIndex(h => /^Period$/i.test(h));

      if (idxEmp > -1) {
        const neededNames = new Set(candidates.map(c => c.name.toLowerCase()));
        const nameToIdx = new Map();
        hdr.forEach((h, i) => {
          const key = String(h || '').trim().toLowerCase();
          if (neededNames.has(key)) {
            nameToIdx.set(key, i);
          }
        });

        if (nameToIdx.size > 0) {
          rowsH.forEach(r => {
            const eId = String(r[idxEmp] || '').trim();
            if (!eId) return;

            // ðŸ”¹ Read period and normalise to YYYY-MM for comparison
            let perMonth = '';
            if (idxPer > -1) {
              const perRaw = String(r[idxPer] || '').trim();
              if (perRaw) {
                perMonth = perRaw.substring(0, 7); // e.g. "2025-11-A" â†’ "2025-11"
              }
            }

            // âŒ Old (BUGGY):
            // if (periodKey && per && per > periodKey) return;

            // âœ… New: ignore only rows with a *future month* (if that ever happens)
            if (periodKey && perMonth && perMonth > periodKey) return;

            nameToIdx.forEach((colIdx, nameLower) => {
              const v = r[colIdx];
              if (typeof v === 'number' && v) {
                const key = `${eId}||${nameLower}`;
                const prev = usedMap.get(key) || 0;
                // store as absolute lifetime usage
                usedMap.set(key, prev + Math.abs(Number(v) || 0));
              }
            });
          });
        }
      }
    }

    // ---------- 3rd pass: enforce Maximum Amount (sign-aware) & aggregate ----------
    const aggregated = new Map();

    candidates.forEach(c => {
      const key = `${c.empId}||${c.name.toLowerCase()}`;
      const already = usedMap.get(key) || 0;

      const baseAmt = Number(c.baseAmt) || 0;
      if (!baseAmt) return; // nothing to post

      const maxAbs = Math.abs(Number(c.maxAmt) || 0);
      let amtForRun = baseAmt;

      if (maxAbs > 0) {
        // Remaining absolute room against the cap (absolute)
        const remainingAbs = Math.max(maxAbs - already, 0);
        if (!remainingAbs) return; // fully consumed lifetime cap

        const baseAbs = Math.abs(baseAmt);
        const takeAbs = Math.min(baseAbs, remainingAbs);
        const sign    = baseAmt >= 0 ? 1 : -1;

        amtForRun = sign * takeAbs;
      }

      if (!amtForRun) return;

      const existing = aggregated.get(key);
      if (existing) {
        existing.amt = _r2_(existing.amt + amtForRun);
      } else {
        aggregated.set(key, {
          empId: c.empId,
          name:  c.name,
          amt:   _r2_(amtForRun),
          cat:   c.cat
        });
      }
    });

    return Array.from(aggregated.values());
  } catch (err) {
    Logger.log('Recurring Adjustments load error: ' + err.message);
    return [];
  }
}


    /**
     * Returns unique Payroll Groups from the Employee Masterfile import sheet.
     */
    /**
     * Returns unique Payroll Groups from the Employee Masterfile import sheet.
     * Supports flexible header matching: "Group", "Payroll Group", "Group Name".
     */
    /**
     * Returns unique Payroll Groups from the linked Masterfile.
     * - Case-insensitive, supports: "Payroll Group", "Group", "Group Name"
     * - Tries configured MASTER_SHEET_NAME first
     * - If header not found there, scans all sheets for a matching column
     * - As a last resort, derives groups from sheet names ending with "Payroll Group"
     */

    function getPayrollGroups_() {
      try {
        // ðŸ”¹ Read settings directly from Script Properties (set by Settings dialog)
        const props = PropertiesService.getScriptProperties().getProperties();
        const masterId = props.SOURCE_SS_ID;
        const sheetName = props.MASTER_SHEET_NAME || 'Masterfile Import';

        if (!masterId) throw new Error('Missing Employee Masterfile ID in Settings dialog.');

        const sourceSS = SpreadsheetApp.openById(masterId);

        // Helper to find Payroll Group column
        const findGroupIdx = (headers) => {
          const H = headers.map(h => String(h || '').trim().toUpperCase());
          const candidates = ['PAYROLL GROUP', 'GROUP', 'GROUP NAME'];
          for (const name of candidates) {
            const idx = H.indexOf(name);
            if (idx !== -1) return idx;
          }
          return -1;
        };

        // Helper to scan a sheet for groups
        const trySheet = (sh) => {
          const data = sh.getDataRange().getValues();
          if (data.length < 2) return [];
          const headers = data[0];
          const groupIdx = findGroupIdx(headers);
          if (groupIdx === -1) return [];
          const set = new Set();
          for (let i = 1; i < data.length; i++) {
            const v = String(data[i][groupIdx] || '').trim();
            if (v) set.add(v);
          }
          return [...set].sort();
        };

        // 1ï¸âƒ£ Preferred sheet
        const primarySheet = sourceSS.getSheetByName(sheetName);
        let groups = [];

        if (primarySheet) {
          groups = trySheet(primarySheet);
          if (groups.length) {
            Logger.log(`âœ… Groups from "${sheetName}": ${JSON.stringify(groups)}`);
            return groups;
          }
        }

        // 2ï¸âƒ£ Fallback: scan all sheets
        const allSheets = sourceSS.getSheets();
        for (const sh of allSheets) {
          if (sh === primarySheet) continue;
          const g = trySheet(sh);
          if (g.length) {
            Logger.log(`âœ… Groups from fallback sheet "${sh.getName()}": ${JSON.stringify(g)}`);
            SpreadsheetApp.getActive().toast(`Loaded groups from "${sh.getName()}" (fallback)`, 'Payroll', 5);
            return g;
          }
        }

        // 3ï¸âƒ£ Derive from sheet names ending with "Payroll Group"
        const derived = [];
        allSheets.forEach(sh => {
          const name = sh.getName();
          const m = name.match(/^(.*)\s+Payroll\s+Group\s*$/i);
          if (m && m[1]) derived.push(m[1].trim());
        });
        if (derived.length) {
          const unique = [...new Set(derived)].sort();
          Logger.log(`âš ï¸ Derived groups from sheet names: ${JSON.stringify(unique)}`);
          SpreadsheetApp.getActive().toast('No "Payroll Group" column found; derived groups from sheet names.', 'Payroll', 5);
          return unique;
        }

        Logger.log('âŒ No payroll groups found.');
        SpreadsheetApp.getActive().toast('No payroll groups found. Check Masterfile sheet name and "Payroll Group" column.', 'Payroll', 6);
        return [];

      } catch (err) {
        Logger.log('âŒ getPayrollGroups_ error: ' + err.message);
        SpreadsheetApp.getActive().toast('Error loading groups: ' + err.message, 'Payroll', 6);
        return [];
      }
    }


    function getPayrollGroups() {
      return getPayrollGroups_();
    }

    function _parseFileId_(v, optional){
      const s = String(v||'').trim();
      if (!s) { if (optional) return null; throw new Error('Missing file ID/URL in PAYROLL_SETTINGS.'); }
      const m = s.match(/\/d\/([a-zA-Z0-9-_]+)/);
      return m ? m[1] : s;
    }
    function _creditingToGroup_(d) {
      const day = d.getDate();
      if ((day >= 1 && day <= 10) || (day >= 18 && day <= 25)) return '5/20';
      return '15/30';
    }

    /**
     * Returns ISO date string (yyyy-mm-dd) for the crediting date based on the range end and A/B.
     * Uses your _creditingToGroup_ rule (5/20 or 15/30) and the current month of rangeEnd.
     */
    function _creditingDateFromRange_(rangeEnd, partLabel) {
      const tz = Session.getScriptTimeZone() || 'Asia/Manila';
      const end = _stripTime(rangeEnd) || new Date();
      const y = end.getFullYear();
      const m = end.getMonth();

      // Decide which pair weâ€™re using for this period (your existing heuristic)
      const pair = _creditingToGroup_(end); // '5/20' or '15/30'

      // Pick day by part A/B
      let day;
      if (pair === '5/20') {
        day = (String(partLabel).toUpperCase() === 'A') ? 5 : 20;
      } else {
        // 15/30, but clamp 30 to actual month end
        if (String(partLabel).toUpperCase() === 'A') {
          day = 15;
        } else {
          const monthEnd = new Date(y, m + 1, 0).getDate();
          day = Math.min(30, monthEnd);
        }
      }

      return Utilities.formatDate(new Date(y, m, day), tz, 'yyyy-MM-dd');
    }

    function _loadWorkingDaysGroups_(){
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      const sh = ss.getSheetByName('WORKING_DAYS_GROUPS');
      const map = {};
      if (!sh) return map;
      const lr = sh.getLastRow(), lc = sh.getLastColumn();
      if (lr < 2 || lc < 2) return map;
      sh.getRange(2,1,lr-1,2).getValues().forEach(([k,v])=>{
        const key = String(k||'').trim();
        const wd  = Number(v)||0;
        if (key && wd>0) map[key]=wd;
      });
      return map;
    }
    function _getWorkingDaysFor_(row, mHeaders, groupMap, cfg) {
      const wdyIdx = mHeaders.indexOf('Working Days per Year');
      const empWd = wdyIdx > -1 ? Number(row[wdyIdx] || 0) : 0;
      if (empWd > 0) return empWd;

      // First prefer Payroll Group
      const grpIdx = mHeaders.indexOf('PAYROLL GROUP');
      const grp = grpIdx > -1 ? String(row[grpIdx] || '').trim() : '';
      if (grp && groupMap[grp] > 0) return groupMap[grp];

      // Fallback: Tracking Category 1
      const entIdx = mHeaders.indexOf('TRACKING CATEGORY 1');
      const ent = entIdx > -1 ? String(row[entIdx] || '').trim() : '';
      if (ent && groupMap[ent] > 0) return groupMap[ent];

      return Number(cfg.WORKING_DAYS_PER_YEAR || 261);
    }

    /**
     * Returns distinct payroll groups from the Employee Masterfile import sheet
     * (reads the "Group" column in the linked source file defined in PAYROLL_SETTINGS).
     */

    /* ==========================
    * 7) HISTORY HELPERS
    * ========================== */
    function _loadTakenThisMonth_(hist, periodKey) {
  const lr = hist.getLastRow();
  const map = new Map();
  if (lr < 2) return map;

  const data = hist.getDataRange().getValues();
  const hdr  = data[0].map(h => String(h || '').trim());
  const rows = data.slice(1);

  // âœ… case-insensitive header indexes (your history headers can be EMPLOYEE ID / PERIOD)
  const periodIdx = hdr.findIndex(h => /^Period$/i.test(String(h || '').trim()));
  const empIdIdx  = hdr.findIndex(h => /^Employee ID$/i.test(String(h || '').trim()));

  // If these are missing, nothing will ever load (prevents r[-1] = undefined issues)
  if (periodIdx < 0 || empIdIdx < 0) return map;

  // âœ… donâ€™t accidentally â€œtakeâ€ meta columns if they happen to be numeric-looking
  const SKIP = new Set([
    'PERIOD', 'EMPLOYEE ID', 'EMPLOYEE NAME', 'PART',
    'FROM', 'TO', 'CREDITING DATE', 'PAYROLL MONTH',
    'WORKINGDAYSBASE USED', 'WORKINGDAYSBASEUSED'
  ]);

  const isNumericLike = (v) => {
    if (v === '' || v == null) return false;
    const n = Number(v);
    return Number.isFinite(n);
  };

  rows.forEach(r => {
    const per = String(r[periodIdx] || '').trim();
    // accept 2025-12, 2025-12-A, 2025-12-B
    if (!per.startsWith(String(periodKey))) return;

    const empId = String(r[empIdIdx] || '').trim();
    if (!empId) return;

    const current = map.get(empId) || {};
    hdr.forEach((h, i) => {
      const key = String(h || '').trim();
      const keyU = key.toUpperCase().replace(/\u00A0/g, ' ').trim();
      if (!keyU || SKIP.has(keyU)) return;

      const v = r[i];
      if (!isNumericLike(v)) return;

      const num = Number(v) || 0;
      if (num === 0) return;

      // store ABS month-to-date
      current[key] = (current[key] || 0) + Math.abs(num);
    });

    map.set(empId, current);
  });

  return map;
}


function _loadTakenThisMonthByPart_(hist, periodKey) {
  const lr = hist.getLastRow();
  const byA  = new Map();
  const byB  = new Map();
  const mtd  = new Map();
  if (lr < 2) return { A: byA, B: byB, MTD: mtd };

  const data = hist.getDataRange().getValues();
  const hdr  = data[0].map(h => String(h||'').trim());
  const rows = data.slice(1);

  const idxPeriod = hdr.findIndex(h => /^Period$/i.test(h));
  const idxEmpId  = hdr.findIndex(h => /^Employee ID$/i.test(h));
  const idxPart   = hdr.findIndex(h => /^Part$/i.test(h)); // optional

  if (idxPeriod < 0 || idxEmpId < 0) return { A: byA, B: byB, MTD: mtd };

  const SKIP = new Set([
    'PERIOD','EMPLOYEE ID','EMPLOYEE NAME','PART',
    'FROM','TO','CREDITING DATE','PAYROLL MONTH',
    'WORKINGDAYSBASE USED','WORKINGDAYSBASEUSED'
  ]);

  const isNumericLike = (v) => {
    if (v === '' || v == null) return false;
    const n = Number(v);
    return Number.isFinite(n);
  };

  const accum = (map, row) => {
    const empId = String(row[idxEmpId] || '').trim();
    if (!empId) return;

    const cur = map.get(empId) || {};
    hdr.forEach((h, i) => {
      const key = String(h || '').trim();
      const keyU = key.toUpperCase().replace(/\u00A0/g, ' ').trim();
      if (!keyU || SKIP.has(keyU)) return;

      const v = row[i];
      if (!isNumericLike(v)) return;

      const num = Number(v) || 0;
      if (num === 0) return;

      cur[key] = (cur[key] || 0) + Math.abs(num);
    });
    map.set(empId, cur);
  };

  rows.forEach(r => {
    const per = String(r[idxPeriod] || '').trim();
    if (!per.startsWith(String(periodKey))) return;

    // month-to-date always
    accum(mtd, r);

    // detect part
    let part = '';
    if (idxPart !== -1) {
      part = String(r[idxPart] || '').trim().toUpperCase();
    } else {
      if (/-A$/i.test(per)) part = 'A';
      if (/-B$/i.test(per)) part = 'B';
    }

    if (part === 'A') accum(byA, r);
    if (part === 'B') accum(byB, r);
  });

  return { A: byA, B: byB, MTD: mtd };
}

function _loadTakenThisMonthByPartSigned_(hist, periodKey) {
  const lr = hist.getLastRow();
  const byA  = new Map();
  const byB  = new Map();
  const mtd  = new Map();
  if (lr < 2) return { A: byA, B: byB, MTD: mtd };

  const data = hist.getDataRange().getValues();
  const hdr  = data[0].map(h => String(h||'').trim());
  const rows = data.slice(1);

  const idxPeriod = hdr.findIndex(h => /^Period$/i.test(h));
  const idxEmpId  = hdr.findIndex(h => /^Employee ID$/i.test(h));
  const idxPart   = hdr.findIndex(h => /^Part$/i.test(h)); // optional

  if (idxPeriod < 0 || idxEmpId < 0) return { A: byA, B: byB, MTD: mtd };

  const SKIP = new Set([
    'PERIOD','EMPLOYEE ID','EMPLOYEE NAME','PART',
    'FROM','TO','CREDITING DATE','PAYROLL MONTH',
    'WORKINGDAYSBASE USED','WORKINGDAYSBASEUSED'
  ]);

  const isNumericLike = (v) => {
    if (v === '' || v == null) return false;
    const n = Number(v);
    return Number.isFinite(n);
  };

  const accumSigned = (map, row) => {
    const empId = String(row[idxEmpId] || '').trim();
    if (!empId) return;

    const cur = map.get(empId) || {};
    hdr.forEach((h, i) => {
      const key = String(h || '').trim();
      const keyU = key.toUpperCase().replace(/\u00A0/g, ' ').trim();
      if (!keyU || SKIP.has(keyU)) return;

      const v = row[i];
      if (!isNumericLike(v)) return;

      const num = Number(v) || 0;
      if (num === 0) return;

      // âœ… SIGNED accumulate (NO Math.abs)
      cur[key] = (cur[key] || 0) + num;
    });
    map.set(empId, cur);
  };

  rows.forEach(r => {
    const per = String(r[idxPeriod] || '').trim();
    if (!per.startsWith(String(periodKey))) return;

    // month-to-date always
    accumSigned(mtd, r);

    // detect part
    let part = '';
    if (idxPart !== -1) {
      part = String(r[idxPart] || '').trim().toUpperCase();
    } else {
      if (/-A$/i.test(per)) part = 'A';
      if (/-B$/i.test(per)) part = 'B';
    }

    if (part === 'A') accumSigned(byA, r);
    if (part === 'B') accumSigned(byB, r);
  });

  return { A: byA, B: byB, MTD: mtd };
}


    function _getYtdOtherBenefits_(hist, empId) {
      const lr = hist.getLastRow();
      if (lr < 2) return 0;
      const year = String(new Date().getFullYear());
      const data = hist.getDataRange().getValues();
      const hdr = data[0];
      const rows = data.slice(1);
      const empIdIdx = hdr.indexOf('Employee ID');
      const periodIdx = hdr.indexOf('Period');
      
      let sum = 0;
      hdr.forEach((h, i) => {
        if (_isOtherBenefit_(h)) {
          rows.forEach(r => {
            if (String(r[empIdIdx]) === String(empId) && String(r[periodIdx]).startsWith(year + '-')) {
              sum += _n_(r[i]);
            }
          });
        }
      });
      return sum;
    }

    /* ==========================
    * 8) SHARED UTILS
    * ========================== */
    function _getComponentValueForPeriod_(name, monthlyValue, mode, partLabel, priorTaken = 0) {
        let targetValue = 0; 
        if (partLabel === 'A') {
            if (mode === 'split') targetValue = monthlyValue / 2;
            else if (mode === 'first') targetValue = monthlyValue;
        } else { 
            if (mode === 'split') targetValue = monthlyValue / 2;
            else if (mode === 'second') targetValue = monthlyValue;
        }
        return _max0_(targetValue - priorTaken);
    }
    function _safeRun_(fn){
      try { fn(); return true; }
      catch(e){ SpreadsheetApp.getUi().alert(`Error: ${e.message}\nFile: ${e.fileName}\nLine: ${e.lineNumber}`); return false; }
    }
    function _mustGetSheet_(ss, name){
      const sh = ss.getSheetByName(name);
      if (!sh) throw new Error(`Missing sheet: ${name}`);
      return sh;
    }
    function _findHeaderFuzzy_(headers, keywords, excludeIdx=[]) {
      const H = headers.map(h => String(h||'').trim()); 
      const K = keywords.map(k => String(k||'').trim());
      for (const k of K) {
        const i = H.indexOf(k);
        if (i!==-1 && !excludeIdx.includes(i)) return i;
      }
      const H_fuzzy = H.map(h => h.replace(/[\s-]/g,'').toLowerCase());
      const K_fuzzy = K.map(k => k.replace(/[\s-]/g,'').toLowerCase());
      for (const k of K_fuzzy) {
        const i = H_fuzzy.indexOf(k);
        if (i!==-1 && !excludeIdx.includes(i)) return i;
      }
      
      return -1;
    }
    function _prorateSegmentsByWDY_(segs, WDY, from, to){
      const base = WDY||261;
      let basic=0, allow=0;
      segs.forEach(s=>{
        const days = _daysBetweenInclusive_(s.from, s.to);
        basic += (Number(s.sal)*12/base)*days;
        allow += (Number(s.allow)*12/base)*days;
      });
      return { basicProrated:_r2_(basic), allowProrated:_r2_(allow) };
    }
    function _daysBetweenInclusive_(a,b){
      const A = new Date(a.getFullYear(), a.getMonth(), a.getDate());
      const B = new Date(b.getFullYear(), b.getMonth(), b.getDate());
      return Math.round((B-A)/86400000)+1;
    }
    function _fmtDate_(d){ return d ? Utilities.formatDate(d, Session.getScriptTimeZone()||'Asia/Manila', 'yyyy-MM-dd') : null; }
    function _safeDate_(v){ if (!v) return null; if (v instanceof Date && !isNaN(v)) return v; const t=new Date(v); return isNaN(t)?null:t; }
    function _stripTime(d) { if (!d) return null; return new Date(d.getFullYear(), d.getMonth(), d.getDate()); }
    function _toNumber_(v){ return Number(String(v||'').replace(/,/g,'')) || 0; }
    function _n_(v){ return Number(v)||0; }
    function _r2_(x){ 
      if (typeof x === 'string' || !isFinite(x)) return x;
      return Math.round((Number(x)+Number.EPSILON)*100)/100;
    }
    function _max0_(x){ return Math.max(0, Number(x)||0); }
    function _clamp_(x,min,max){ return Math.max(min||0, Math.min(max||x, x||0)); }

    // Case-insensitive numeric fetch (for History keys that may be UPPERCASED)
function _nCI_(obj, key){
  if (!obj) return 0;

  const rawKey = String(key || '').replace(/\u00A0/g, ' ').trim();
  if (!rawKey) return 0;

  const keys = Object.keys(obj);

  // 1) exact case-insensitive match
  const want = rawKey.toLowerCase();
  let hit = keys.find(k => String(k).replace(/\u00A0/g, ' ').trim().toLowerCase() === want);
  if (hit) return _n_(obj[hit]);

  // 2) normalized match (ignore spaces, dashes, punctuation)
  const norm = s => String(s || '')
    .replace(/\u00A0/g, ' ')
    .toUpperCase()
    .replace(/[^A-Z0-9]/g, '');
  const wantN = norm(rawKey);

  hit = keys.find(k => norm(k) === wantN);
  return hit ? _n_(obj[hit]) : 0;
}



function _buildComponentMap_(cfg) {
  const map = {};

  // Helper: set category with simple source-based priority
  function setCategory(name, category, source) {
    // CRITICAL: use the SAME normalization as _componentMapGet_
    const key = _normComponentKey_(name);
    const cat = String(category || '').trim();
    if (!key || !cat) return;

    const priority = {
      MASTER_HEADER: 1,
      RECURRING: 2,
      ADJUSTMENT_TYPES: 3,
      COMPONENT_MODES: 4,
    };

    const existing = map[key];
    if (existing) {
      const oldRank = priority[existing.source] || 0;
      const newRank = priority[source] || 0;
      if (oldRank >= newRank) {
        // keep higher- or same-priority mapping
        return;
      }
    }

    // Store original (display) name as well for the Component Manager UI
    map[key] = {
      name: String(name || '').trim(),
      category: cat,
      source: source || ''
    };
  }


  // 0) Masterfile headers for name-based inference only
  let masterHeaders = [];
  try {
    if (cfg && cfg.SOURCE_SS_ID && cfg.MASTER_SHEET_NAME) {
      const masterSS = SpreadsheetApp.openById(cfg.SOURCE_SS_ID);
      const masterSheet = masterSS.getSheetByName(cfg.MASTER_SHEET_NAME);
      if (masterSheet) {
        masterHeaders = masterSheet
          .getRange(1, 1, 1, masterSheet.getLastColumn())
          .getValues()[0]
          .map(h => String(h || '').trim());
      }
    }
  } catch (err) {
    Logger.log('ComponentMap: unable to read masterfile headers: ' + err);
  }

  // 1) Start with inferred categories from masterfile header names
  masterHeaders.forEach(h => {
    const inferred = _inferCategory_(h);
    if (inferred) {
      setCategory(h, inferred, 'MASTER_HEADER');
    }
  });

  // 2) Overlay: PAYROLL_COMPONENT_MODES (manual overrides)
  try {
    const ss = SpreadsheetApp.getActive();
    const settingsSheet = ss.getSheetByName('PAYROLL_COMPONENT_MODES');
    if (settingsSheet && settingsSheet.getLastRow() > 1) {
      const vals = settingsSheet
        .getRange(2, 1, settingsSheet.getLastRow() - 1, settingsSheet.getLastColumn())
        .getValues();

      const headers = settingsSheet
        .getRange(1, 1, 1, settingsSheet.getLastColumn())
        .getValues()[0]
        .map(h => String(h || '').trim());

      const nameIdx = _findHeaderFuzzy_(headers, [
        'Component Name',
        'Header',
        'Name',
        'ADJUSTMENT NAME',
      ]);
      const catIdx  = _findHeaderFuzzy_(headers, [
        'Payroll Category',
        'Category',
        'PAYROLL CATEGORY',
      ]);

      if (nameIdx > -1 && catIdx > -1) {
        vals.forEach(r => {
          const compName = String(r[nameIdx] || '').trim();
          const cat      = String(r[catIdx]  || '').trim();
          if (!compName || !cat) return;
          setCategory(compName, cat, 'COMPONENT_MODES');
        });
      }
    }
  } catch (err) {
    Logger.log('ComponentMap: error reading PAYROLL_COMPONENT_MODES: ' + err);
  }

  // 3) Overlay: ADJUSTMENT_TYPES in Inputs spreadsheet (name â†’ category)
  try {
    if (cfg && cfg.INPUTS_SS_ID) {
      const inputsSS  = SpreadsheetApp.openById(cfg.INPUTS_SS_ID);
      const typeSheet = inputsSS.getSheetByName('ADJUSTMENT_TYPES');
      if (typeSheet && typeSheet.getLastRow() > 1) {
        const headers = typeSheet
          .getRange(1, 1, 1, typeSheet.getLastColumn())
          .getValues()[0]
          .map(h => String(h || '').trim());

        const nameIdx = _findHeaderFuzzy_(headers, [
          'Adjustment Name',
          'Name',
          'Description',
          'Type',
          'ADJUSTMENT NAME',
        ]);
        const catIdx  = _findHeaderFuzzy_(headers, [
          'Payroll Category',
          'Category',
          'PAYROLL CATEGORY',
        ]);

        if (nameIdx > -1 && catIdx > -1) {
          const vals = typeSheet
            .getRange(2, 1, typeSheet.getLastRow() - 1, typeSheet.getLastColumn())
            .getValues();

          vals.forEach(row => {
            const name = String(row[nameIdx] || '').trim();
            const cat  = String(row[catIdx]  || '').trim();
            if (!name || !cat) return;
            setCategory(name, cat, 'ADJUSTMENT_TYPES');
          });
        }
      }
    }
  } catch (err) {
    Logger.log('ComponentMap: error reading ADJUSTMENT_TYPES: ' + err);
  }

  // 4) Overlay from Recurring Adjustments sheet (where you tagged De Minimis)
  try {
    if (cfg && cfg.SOURCE_SS_ID) {
      const sourceSS = SpreadsheetApp.openById(cfg.SOURCE_SS_ID);

      const recSheet =
        sourceSS.getSheetByName('Recurring Adjustments') ||
        sourceSS.getSheetByName('Recurring Adjustment')  ||
        sourceSS.getSheetByName('ADJUST_SCHEDULE');

      if (recSheet && recSheet.getLastRow() > 1) {
        const headers = recSheet
          .getRange(1, 1, 1, recSheet.getLastColumn())
          .getValues()[0]
          .map(h => String(h || '').trim());

        const nameIdx = _findHeaderFuzzy_(headers, [
          'Adjustment Name',
          'ADJUSTMENT NAME',
          'Description',
          'Type',
        ]);
        const catIdx  = _findHeaderFuzzy_(headers, [
          'Payroll Category',
          'PAYROLL CATEGORY',
          'Category',
        ]);

        if (nameIdx > -1 && catIdx > -1) {
          const vals = recSheet
            .getRange(2, 1, recSheet.getLastRow() - 1, recSheet.getLastColumn())
            .getValues();

          vals.forEach(row => {
            const name = String(row[nameIdx] || '').trim();
            const cat  = String(row[catIdx]  || '').trim();
            if (!name || !cat) return;
            setCategory(name, cat, 'RECURRING');
          });
        }
      }
    }
  } catch (err) {
    Logger.log('ComponentMap: error reading Recurring Adjustments categories: ' + err);
  }

  return map;
}


    function _classifyComponent_(name, componentMap) {
  if (!name) return '';
  // Use normalized lookup (handles NBSP, punctuation, & vs AND, etc.)
  const cat = _componentMapGet_(componentMap, name);
  if (cat) return cat;

  // Only if mapping truly misses, fall back to inference
  const up = _normComponentKey_(name);
  return _inferCategoryFromHeader_(up) || '';
}




function _inferCategory_(name) {
  const n = String(name || '').toUpperCase();

  // ðŸ”¹ 13th Month / Other Benefits
  if (/13(TH)?\s*MONTH|13TH\s*MO(NTH)?|OTHER\s+BENEFIT|BONUS/i.test(n)) {
    return '13th Month Pay and Other Benefits';
  }

  // Net-only adders
  if (/(^|\s)ADD(ITION)?(\s*TO\s*NET)?($|\s)|NET[-\s]*ONLY|NET\s*ADD/i.test(n)) {
    return 'Addition';
  }

  // Basic Pay
  if (/BASIC|SALARY ADJ|RETRO PAY/i.test(n)) return 'Basic Pay Related';

  // Taxable Earnings (OT, Holiday, etc)
  if (/ALLOWANCE|OT|OVERTIME|COMMISSION|INCENTIVE|HOLIDAY|REST DAY|NIGHT DIFFERENTIAL/i.test(n)) {
    return 'Taxable Earning';
  }

  // ðŸ”¹ CRITICAL FIX: Explicitly catch De Minimis BEFORE generic non-taxable
  if (/DEMINIMIS|DE\s*MINIMIS/i.test(n)) {
    return 'Non-Taxable Earning - De Minimis';
  }

  // Other Non-Taxable
  if (/NON.?TAX|REIMBURSE|NTAX/i.test(n)) {
    return 'Non-Taxable Earning - Other';
  }

  // Deductions
  if (/DEDUCTION|LOAN|ADVANCE|CHARGE|CALAMITY|SSS|HDMF|PAG.?IBIG|HMO|WITHHOLDING/i.test(n)) {
    return 'Deduction';
  }

  return 'Other';
}

function _getPriorTakenForRun_(takenMap, takenByPt, empId, key, partLabel) {
  const STAT_KEYS = new Set([
    'SSS EE MC','SSS EE MPF','SSS ER MC','SSS ER MPF','SSS EC',
    'PHILHEALTH EE','PHILHEALTH ER',
    'PAG-IBIG EE','PAG-IBIG ER'
  ]);

  const keyStr = String(key || '');
  const kU = keyStr.trim().toUpperCase();

  const safeMTDObj = () =>
    (takenMap && typeof takenMap.get === 'function') ? (takenMap.get(empId) || {}) : {};

  const nFromObj = (obj) =>
    (typeof _nCI_ === 'function') ? (Number(_nCI_(obj, keyStr)) || 0) : (Number(obj[keyStr]) || 0);

  const part = String(partLabel || '').trim().toUpperCase();

  // âœ… If NOT A/B (MONTHLY, SPECIAL, etc) â†’ always use month-to-date for netting
  if (part !== 'A' && part !== 'B') {
    return nFromObj(safeMTDObj());
  }

  // âœ… Statutory caps: always month-to-date so B = Month - A works
  if (STAT_KEYS.has(kU)) {
    return nFromObj(safeMTDObj());
  }

  // âœ… Non-statutory: only subtract already-posted SAME part (A vs B)
  const partMapObj =
    (takenByPt && takenByPt[part] && typeof takenByPt[part].get === 'function')
      ? (takenByPt[part].get(empId) || {})
      : {};

  return nFromObj(partMapObj);
}

    /* ===================================
    * 9) NEW SETUP & HELPER FUNCTIONS
    * =================================== */
    function setupColumnOrderSheet_() {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      let sh = ss.getSheetByName('COLUMN_ORDER');
      if (!sh) sh = ss.insertSheet('COLUMN_ORDER');
      sh.clear();
      sh.getRange('A1').setValue('Column Name').setFontWeight('bold');

      let dynamicColumns = [];
      try {
        const cfg = _readSettings_();
        if (cfg.INPUTS_SS_ID) {
          const inputsSS = SpreadsheetApp.openById(cfg.INPUTS_SS_ID);
          const inputsSheet = inputsSS.getSheetByName('Inputs');
          if (inputsSheet && inputsSheet.getLastRow() > 1) {
            const descriptions = inputsSheet.getRange(2, 3, inputsSheet.getLastRow() - 1, 1).getValues().flat();
            dynamicColumns = [...new Set(descriptions)];
          }
        }
      } catch (e) {
        Logger.log("Could not fetch dynamic columns during setup: " + e.message);
      }
      
      const masterfileColumns = [
        'NON- TAXABLE ALLOWANCE', 'DEMINIMIS ALLOWANCE', 'MONTHLY TAXABLE ALLOWANCE', 'SSS LOAN', 'SSS CALAMITY LOAN', 
        'HDMF LOAN', 'HDMF CALAMITY LOAN', 'HMO DEDUCTION', 'OTHER DEDUCTIONS'
      ];
      dynamicColumns = [...new Set([...dynamicColumns, ...masterfileColumns])];


      const otKeywords = ['PAY', 'OT', 'OVERTIME'];
      const absenceKeywords = ['ABSENCE', 'TARDINESS'];
      const deductionKeywords = ['LOAN', 'DEDUCTION', 'ADVANCE', 'CHARGE', 'DEDUK', 'CALAMITY'];

      const dynamicAbsences = dynamicColumns.filter(h => absenceKeywords.some(k => h.toUpperCase().includes(k))).sort();
      const dynamicOvertimes = dynamicColumns.filter(h => otKeywords.some(k => h.toUpperCase().includes(k))).sort();
      const dynamicDeductions = dynamicColumns.filter(h => deductionKeywords.some(k => h.toUpperCase().includes(k))).sort();
      const dynamicOtherEarnings = dynamicColumns.filter(h => 
          !dynamicAbsences.includes(h) && 
          !dynamicOvertimes.includes(h) && 
          !dynamicDeductions.includes(h)
      ).sort();

            const finalOrder = [
        'Employee ID', 'Employee Name', 'Period', 'From', 'To', 'Payroll Month', 'Remarks',
        'BASIC PAY',
        ...dynamicAbsences,
        'Allowance', 'NON-TAXABLE ALLOWANCE', 'DEMINIMIS ALLOWANCE', 'MONTHLY TAXABLE ALLOWANCE',
        ...dynamicOvertimes,
        ...dynamicOtherEarnings,
        'Gross Pay',
        'SSS EE MC','SSS EE MPF', 'PhilHealth EE', 'Pag-IBIG EE',
        'Taxable Income',
        'Withholding Tax',
        ...dynamicDeductions,
        'Net Pay',
        'Tracking Category 1','Payroll Group','Tracking Category 2',
        'SSS ER MC','SSS ER MPF', 'SSS EC', 'PhilHealth ER', 'Pag-IBIG ER'
      ];

      
      sh.getRange(2, 1, finalOrder.length, 1).setValues(finalOrder.map(h => [h]));
      sh.autoResizeColumn(1);
      SpreadsheetApp.getActive().toast('âœ… Column Order sheet is ready. Rearrange rows to customize output.', 'Setup Complete', 5);
    }

    function _loadColumnOrder_() {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      const sh = ss.getSheetByName('COLUMN_ORDER');
      if (!sh || sh.getLastRow() < 2) {
        setupColumnOrderSheet_();
        const newSh = ss.getSheetByName('COLUMN_ORDER');
        return newSh.getRange(2, 1, newSh.getLastRow() - 1, 1).getValues().flat().map(h => String(h).trim()).filter(Boolean);
      }
      return sh.getRange(2, 1, sh.getLastRow() - 1, 1)
  .getValues()
  .flat()
  .map(h => String(h).trim())
  .filter(Boolean)
  .filter(h => !/^(SSS EE|SSS ER)$/i.test(h));

    }

    function setupEmployeeOverridesSheet_() {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      const sh = ss.getSheetByName('EMPLOYEE_MODE_OVERRIDES') || ss.insertSheet('EMPLOYEE_MODE_OVERRIDES');
      sh.clear();
      sh.getRange('A1:D1').setValues([['Employee Name', 'Employee ID', 'Component Name', 'Deduction Mode']]).setFontWeight('bold');
      sh.setFrozenRows(1);

      try {
        const cfg = _readSettings_();
        if (!cfg.SOURCE_SS_ID) throw new Error("Employee Masterfile ID / Link is not set in PAYROLL_SETTINGS.");
        const sourceSS = SpreadsheetApp.openById(cfg.SOURCE_SS_ID);
        const master = _mustGetSheet_(sourceSS, cfg.MASTER_SHEET_NAME);
        const headers = master.getRange(1, 1, 1, master.getLastColumn()).getValues()[0];
        const nameColIdx = _findHeaderFuzzy_(headers, ['Employee Name', 'Name']);
        const idColIdx = _findHeaderFuzzy_(headers, ['Employee ID', 'Emp ID']);
        
        if (nameColIdx !== -1 && idColIdx !== -1) {
          let helperSheet = ss.getSheetByName('_EmployeeDataCache');
          if (!helperSheet) {
            helperSheet = ss.insertSheet('_EmployeeDataCache');
            helperSheet.hideSheet();
          }
          helperSheet.clear();
          helperSheet.getRange('A1:B1').setValues([['Employee ID', 'Employee Name']]);

          const masterData = master.getRange(2, 1, master.getLastRow() - 1, master.getLastColumn()).getValues();
          const idNamePairs = masterData.map(row => [row[idColIdx], row[nameColIdx]]).filter(pair => pair[1]); 
          
          if (idNamePairs.length > 0) {
            helperSheet.getRange(2, 1, idNamePairs.length, 2).setValues(idNamePairs);
            
            const localNamesRange = helperSheet.getRange(2, 2, idNamePairs.length, 1);
            const rule = SpreadsheetApp.newDataValidation().requireValueInRange(localNamesRange, true).setAllowInvalid(false).build();
            sh.getRange('A2:A' + sh.getMaxRows()).setDataValidation(rule);
          }
        }
      } catch (e) {
        SpreadsheetApp.getUi().alert(`Could not create employee dropdown. Please check settings. Error: ${e.message}`);
      }

      const compSheet = ss.getSheetByName('PAYROLL_COMPONENT_MODES');
      if (compSheet && compSheet.getLastRow() > 1) {
        const compRange = compSheet.getRange(2, 1, compSheet.getLastRow() - 1, 1);
        const rule = SpreadsheetApp.newDataValidation().requireValueInRange(compRange, true).setAllowInvalid(false).build();
        sh.getRange('C2:C' + sh.getMaxRows()).setDataValidation(rule);
      }

      const modeRule = SpreadsheetApp.newDataValidation().requireValueInList(['split', 'first', 'second'], true).build();
      sh.getRange('D2:D' + sh.getMaxRows()).setDataValidation(modeRule);

      sh.getRange('B:B').setNumberFormat('@'); 
      sh.autoResizeColumns(1, 4);

      SpreadsheetApp.getActive().toast('âœ… Employee Overrides sheet is ready.', 'Setup Complete', 5);
    }

    //----------------------------------------------------------
    // PROGRESSIVE PAYROLL EXECUTION (Live Progress + ETA)
    //----------------------------------------------------------
    function runPayrollProgressive(form) {
  try {
    _resetProgress_();
    _progress(0, "Phase 1/4: Loading settings & source data...", "--");

    const rawCode = form && form.payrollCode;
    Logger.log('runPayrollProgressive payrollCode from dialog: ' + JSON.stringify(rawCode));

    const code = String(rawCode || '').trim().toUpperCase();

    let ok;
    if (code === 'A' || code === 'B') {
      ok = _runPayrollCore_(form);
    } else if (code === 'MONTHLY' || code === 'M') {
      ok = _runPayrollMonthly_(form);
    } else {
      ok = _runPayrollSpecial_(form);
    }

    // Safety: ensure UI can close even if a runner forgets to set 100
    const p = getProgress();
    if (!p || Number(p.percent) < 100) {
      _progress(100, ok ? "âœ… Payroll completed successfully!" : "âš ï¸ Completed with warnings.", "0s");
    }

    return ok;
  } catch (err) {
    _progress(100, "âŒ Error: " + (err && err.message ? err.message : err), "--");
    return false;
  }
}

    function _resetProgress_() {
      const props = PropertiesService.getScriptProperties();
      props.deleteProperty('progress');
    }

    /**
     * Universal Payroll Sheet Formatter
     * Applies to both Computation and History sheets
     * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet
     * @param {boolean} includeTotals - set true for computation sheets
     */
    function formatPayrollSheetUnified_(sheet, includeTotals = false) {
      if (!sheet) return;
      const lr = sheet.getLastRow();
      const lc = sheet.getLastColumn();
      if (lr < 1 || lc < 2) return;

      // --- Read headers and force uppercase ---
      const headers = sheet.getRange(1, 1, 1, lc).getValues()[0].map(h => String(h || '').trim());
      const headersUpper = headers.map(h => h.toUpperCase());
      sheet.getRange(1, 1, 1, lc).setValues([headersUpper]);

      

      // --- Hide gridlines ---
      sheet.setHiddenGridlines(true);

      // --- Header styling ---
      const headerRange = sheet.getRange(1, 1, 1, lc);
      headerRange
        .setFontWeight('bold')
        .setWrap(true)
        .setHorizontalAlignment('center')
        .setVerticalAlignment('middle')
        .setBackground('#1a237e')       // âœ… dark blue header
        .setFontColor('#ffffff')        // âœ… white text
        .setFontFamily('Segoe UI')
        .setFontSize(10);
      sheet.setRowHeight(1, 30);

      // --- Date formatting ---
      const dateLabels = ['FROM', 'TO', 'CREDITING DATE'];
      dateLabels.forEach(label => {
        const c = headersUpper.indexOf(label);
        if (c >= 0) sheet.getRange(2, c + 1, lr - 1, 1).setNumberFormat('yyyy-mm-dd');
      });
      const pmIdx = headersUpper.indexOf('PAYROLL MONTH');
      if (pmIdx >= 0) sheet.getRange(2, pmIdx + 1, lr - 1, 1).setNumberFormat('mmmm yyyy');

      

      // --- Numeric columns start immediately AFTER PAYROLL MONTH ---
let numStartIdx = (pmIdx >= 0 ? pmIdx + 1 : -1);

// If PAYROLL MONTH is missing or is the last column, fallback to legacy BASIC PAY anchor (if present)
if (numStartIdx === -1 || numStartIdx >= lc) {
  const bpIdx = headersUpper.indexOf('BASIC PAY');
  if (bpIdx >= 0) numStartIdx = bpIdx;
}


      // --- Accounting format from first numeric column onward ---
if (numStartIdx !== -1) {
  const startCol = numStartIdx + 1;
  const numRange = sheet.getRange(2, startCol, Math.max(lr - 1, 1), lc - startCol + 1);
  numRange.setNumberFormat('#,##0.00_);(#,##0.00)').setHorizontalAlignment('right');
}


// --- Consistent column width based on longest numeric value ---
if (numStartIdx !== -1) {
  const numStart = numStartIdx + 1;
  const numData = sheet.getRange(2, numStart, lr - 1, lc - numStart + 1).getDisplayValues();
  let longest = 0;
  numData.forEach(row => row.forEach(v => {
    const len = String(v || '').length;
    if (len > longest) longest = len;
  }));
  const width = Math.min(140, Math.max(90, longest * 7 + 25));
  for (let c = numStart; c <= lc; c++) sheet.setColumnWidth(c, width);
}


      // --- Auto-resize Employee columns ---
      const idIdx = headersUpper.indexOf('EMPLOYEE ID');
      const nameIdx = headersUpper.indexOf('EMPLOYEE NAME');
      if (idIdx >= 0) sheet.autoResizeColumn(idIdx + 1);
      if (nameIdx >= 0) sheet.autoResizeColumn(nameIdx + 1);

      // --- Freeze header + employee name ---
      sheet.setFrozenRows(1);
      sheet.setFrozenColumns(nameIdx + 1 > 0 ? nameIdx + 1 : 2);

if (includeTotals && numStartIdx !== -1 && lr >= 2) {
  const totalRow = lr + 1;
  sheet.insertRowAfter(lr);
  const startCol = numStartIdx + 1;
  const totals = [];
  for (let c = 1; c <= lc; c++) {
    if (c >= startCol) {
      const colLetter = columnLetter_(c);
      totals.push(`=SUM(${colLetter}2:${colLetter}${lr})`);
    } else totals.push('');
  }
  sheet.getRange(totalRow, 1, 1, lc)
    .setFormulas([totals])
    .setFontWeight('bold')
    .setHorizontalAlignment('right');
  sheet.getRange(totalRow, startCol, 1, lc - startCol + 1)
    .setNumberFormat('#,##0.00_);(#,##0.00)');
  sheet.getRange(totalRow, 1).setValue('TOTALS');
}


      Logger.log(`âœ… Formatting applied to: ${sheet.getName()}`);
    }

    /** Helper for totals */
    function columnLetter_(col) {
      let temp = '';
      let letter = '';
      while (col > 0) {
        temp = (col - 1) % 26;
        letter = String.fromCharCode(temp + 65) + letter;
        col = (col - temp - 1) / 26;
      }
      return letter;
    }


    /** Helper: column number â†’ Excel letter */
    function columnLetter_(n) {
      let s = "";
      while (n > 0) {
        const m = (n - 1) % 26;
        s = String.fromCharCode(65 + m) + s;
        n = Math.floor((n - m) / 26);
      }
      return s;
    }

    function showSettingsCenter() {
      const html = HtmlService.createTemplateFromFile('SettingsCenter')
      .evaluate()
        .setWidth(520)
        .setHeight(640);
      SpreadsheetApp.getUi().showModalDialog(html, 'Payroll Settings Center');
    }


function loadAllSettings_() {
  const props = _clientSettingsProps_().getProperties();
  const cfg = _readSettings_();
  const compMap = _buildComponentMap_(cfg);
  const compList = Object.entries(compMap).map(([name, info]) => ({
    name,
    category: info.category || '',
    source: info.source || '',
    mode: info.mode || ''
  }));

  return {
    general: props,
    components: compList,
    contributions: {
      PH_RATE: props.PH_RATE || '0.05',
      PH_MIN_BASE: props.PH_MIN_BASE || '10000',
      PH_MAX_BASE: props.PH_MAX_BASE || '100000',
      PAGIBIG_EE_RATE: props.PAGIBIG_EE_RATE || '0.02',
      PAGIBIG_ER_RATE: props.PAGIBIG_ER_RATE || '0.02',
      PAGIBIG_MAX_BASE: props.PAGIBIG_MAX_BASE || '10000'
    }
  };
}

function saveGeneralSettings_(data) {
  const props = _clientSettingsProps_();
  Object.entries(data).forEach(([k, v]) => props.setProperty(k, v || ''));
  return true;
}

    function setupSystemSheets_() {
      setupEmployeeOverridesSheet_();
      setupColumnOrderSheet_();
      return true;
    }

    /* =======================================================
    * PAYROLL COMPONENT MANAGER BACKEND
    * ======================================================= */

    function loadComponentMap() {
  const cfg = _readSettings_();
  const map = _buildComponentMap_(cfg);
  const compModes = _loadComponentModes_();

  return Object.keys(map).map(k => {
    const rec = map[k];
    const name = rec.name || k;   // fall back to key if name not set
    return {
      name: name,
      category: rec.category || 'Other',
      mode: compModes.get(name) || 'split',
      source: rec.source || 'Masterfile/Inputs'
    };
  });
}


    /**
     * Saves updated component categories and modes from the UI.
     * @param {Array} comps - Array of {name, category, mode, source}
     */
    function saveComponentManagerSettings(comps) {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      const sh = ss.getSheetByName('PAYROLL_COMPONENT_MODES') || ss.insertSheet('PAYROLL_COMPONENT_MODES');
      sh.clear();
      sh.getRange(1, 1, 1, 3).setValues([['Component', 'Category', 'Mode']]).setFontWeight('bold');

      const rows = comps.map(c => [c.name, c.category, c.mode]);
      if (rows.length > 0) {
        sh.getRange(2, 1, rows.length, 3).setValues(rows);
      }

      SpreadsheetApp.getActive().toast(`âœ… ${rows.length} components saved to PAYROLL_COMPONENT_MODES.`, 'Component Manager', 5);
    }


    function saveComponentManagerSettings_(comps) {
      return saveComponentManagerSettings(comps);
    }

    /**
     * Sends live updates (percent, message, eta) to the HTML dialog
     */
    function _progress(percent, message, eta) {
      // Store current progress status in ScriptProperties
      const props = PropertiesService.getScriptProperties();
      props.setProperty('progress', JSON.stringify({ percent, message, eta }));
    }

    function getProgress() {
      const props = PropertiesService.getScriptProperties();
      const progress = props.getProperty('progress');
      return progress ? JSON.parse(progress) : null;
    }

    function _resetProgress_() {
      const props = PropertiesService.getScriptProperties();
      props.deleteProperty('progress');
    }

    /**
     * Protects a payroll computation sheet.
     * - Locks the sheet for everyone except the script owner (you) and optional extra editors.
     * - Allows the script to keep renaming/formatting/posting because it runs as you.
     */
    function protectComputationSheet_(sheet, extraEditorsEmails = []) {
      try {
        // Remove existing protections on this sheet (avoid stacking)
        const protections = sheet.getProtections(SpreadsheetApp.ProtectionType.SHEET) || [];
        protections.forEach(p => { try { p.remove(); } catch (e) {} });

        const me = Session.getActiveUser().getEmail();
        const prot = sheet.protect()
          .setDescription('ðŸ”’ Protected: Payroll computation output')
          .setWarningOnly(false); // true = warning only; false = hard protection

        // Keep only you + explicitly allowed editors
        const editors = new Set([me, ...extraEditorsEmails.filter(Boolean)]);
        prot.removeEditors(prot.getEditors());
        if (SpreadsheetApp.getActive().getEditors) {
          // Optional: if the file has editors, we don't automatically re-add them.
          // We keep protection tight by default.
        }
        prot.addEditors([...editors]);

        // Optional: allow editing a small area (e.g., remarks) â€“ comment out if not needed
        // const unprotected = sheet.getRange('A1:A1');
        // const rangeProt = sheet.protect();
        // rangeProt.setUnprotectedRanges([unprotected]);

        Logger.log(`ðŸ”’ Protected sheet "${sheet.getName()}" for ${[...editors].join(', ')}`);
      } catch (e) {
        Logger.log('âš ï¸ protectComputationSheet_ error: ' + e.message);
      }
    }

    /**
     * Protects all sheets in the linked Inputs / Adjustments file.
     */
    function _lockAdjustmentsFile_() {
  // DISABLED: do not lock/protect Inputs/Adjustments sheets
  return;
}

function _unlockAdjustmentsFile_() {
  // DISABLED: do not unlock/unprotect Inputs/Adjustments sheets
  return;
}

    /**
 * YEAR-TO-DATE (YTD) AGGREGATOR â€” Canonical Order + Preservation
 * - Uses latest computation sheet's header as canonical column order.
 * - Writes YTD columns in that order; history-only columns are appended at the end.
 * - Preserves all values by realigning to the new order.
 */
function generateYearToDate(silent = false) {
  // DISABLED: Year_to_Date sheet is no longer maintained.
  return;
}


/**
 * Returns the header row of the most recent payroll computation sheet.
 * Strategy:
 * - Prefer the active sheet if it looks like a computation (has Employee ID, Employee Name).
 * - Else scan sheets whose names look like payroll outputs (YYYY-MM-<part> or end with "(Posted)"),
 *   pick the rightmost (assuming your _arrangeSheets_ puts them chronologically), and read its header.
 * - Fallback: empty array.
 */
function _getCanonicalCompHeaders_(ss) {
  const looksLikeComp = (sh) => {
    if (!sh) return false;
    const lc = sh.getLastColumn();
    if (!lc) return false;
    const hdr = sh.getRange(1,1,1,lc).getValues()[0].map(h => String(h||'').trim());
    const hasId  = hdr.some(h => /^Employee ID$/i.test(h));
    const hasNm  = hdr.some(h => /^Employee Name$/i.test(h));
    return hasId && hasNm;
  };

  // 1) Active sheet if computation
  try {
    const active = ss.getActiveSheet();
    if (looksLikeComp(active)) {
      const lc = active.getLastColumn();
      return active.getRange(1,1,1,lc).getValues()[0].map(h => String(h||'').trim());
    }
  } catch(e){}

  // 2) Scan likely computation sheets
  const candidates = ss.getSheets().filter(s => {
    const n = s.getName();
    return /\d{4}-\d{2}-[A-Z]+/i.test(n) || /\(Posted\)$/i.test(n);
  });

  // Prefer the rightmost of candidates (arranged chronologically by _arrangeSheets_)
  if (candidates.length) {
    const sh = candidates[candidates.length - 1];
    if (looksLikeComp(sh)) {
      const lc = sh.getLastColumn();
      return sh.getRange(1,1,1,lc).getValues()[0].map(h => String(h||'').trim());
    }
  }

  return [];
}



    /** Helper: Convert column number to letter (A,B,C...) */
    function columnToLetter_(column) {
      let temp, letter = '';
      while (column > 0) {
        temp = (column - 1) % 26;
        letter = String.fromCharCode(temp + 65) + letter;
        column = (column - temp - 1) / 26;
      }
      return letter;
    }

    /** Protect the Year_to_Date sheet (except script access) */
    function protectYearToDateSheet_(sheet) {
  // DISABLED: Year_to_Date is no longer used.
  return;
}

    /**
     * Keeps payroll file organized automatically.
     * - PAYROLL_HISTORY â†’ always 1st
     * - Year_to_Date â†’ always 2nd
     * - Payroll computation sheets sorted chronologically (YYYY-MM-[A/B/SPECIAL])
     */
    function _arrangeSheets_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheets = ss.getSheets();

  const hist = ss.getSheetByName('PAYROLL_HISTORY');

  // --- Step 1: Move History to the far left
  let idx = 1;
  if (hist) {
    ss.setActiveSheet(hist);
    ss.moveActiveSheet(idx++);
  }

  // --- Step 2: Detect computation sheets by name pattern
  const payrollSheets = sheets
    .filter(s => {
      const n = s.getName();
      return (
        n !== 'PAYROLL_HISTORY' &&
        /\d{4}-\d{2}-[A-Z]+/i.test(n)
      );
    })
    .map(s => {
      const name = s.getName();
      const m = name.match(/(\d{4})-(\d{2})-([A-Z]+)/);
      if (!m) return { sheet: s, order: 999999 };
      const year = parseInt(m[1], 10);
      const month = parseInt(m[2], 10);
      const part = m[3];
      const partOrder = { 'A': 1, 'B': 2, 'C': 3, 'SPECIAL': 9 };
      const order = year * 1000 + month * 10 + (partOrder[part] || 5);
      return { sheet: s, order };
    })
    .sort((a, b) => a.order - b.order);

  // --- Step 3: Move each computation sheet in sorted order
  payrollSheets.forEach(({ sheet }) => {
    ss.setActiveSheet(sheet);
    ss.moveActiveSheet(idx++);
  });

  // --- Step 4: Reset active sheet to Payroll History (for consistency)
  if (hist) ss.setActiveSheet(hist);

  Logger.log('âœ… Sheets organized: PAYROLL_HISTORY â†’ Computations chronologically.');
}


    /** Returns unique Entity values from the linked Masterfile. */
    /** Returns unique Entity values from the linked Masterfile. */
function getEntities() {
  try {
    const cfg = _readSettings_();
if (!cfg.SOURCE_SS_ID) throw new Error('Missing/invalid Employee Masterfile (SOURCE_SS_ID) in Settings.');

const masterId = cfg.SOURCE_SS_ID;
const prefName = cfg.MASTER_SHEET_NAME || 'Masterfile Import';


    const ss = SpreadsheetApp.openById(masterId);

    // 1) Try preferred sheet first
    const primary = ss.getSheetByName(prefName);
    let entities  = primary ? _entitiesFromSheet_(primary) : [];

    // 2) Fallback: scan all sheets for an "Entity" column
    if (!entities.length) {
      ss.getSheets().forEach(sh => {
        if (sh.getName() === prefName) return;
        if (!entities.length) entities = _entitiesFromSheet_(sh);
      });
    }

    // 3) Finalize list: add ALL at top
    entities = [...new Set(entities)].filter(Boolean).sort((a, b) => a.localeCompare(b));
    return ['ALL', ...entities];

  } catch (err) {
    Logger.log('getEntities error: ' + err.message);
    return ['ALL']; // keep UI usable
  }
}


    /** Returns unique Payroll Groups for a given Entity from the Masterfile. */
/** Returns unique Payroll Groups for a given Entity from the Masterfile. */
function getPayrollGroupsByEntity(entity) {
  try {
    const cfg = _readSettings_();
if (!cfg.SOURCE_SS_ID) throw new Error('Missing/invalid Employee Masterfile (SOURCE_SS_ID) in Settings.');

const masterId = cfg.SOURCE_SS_ID;                 // already extracted ID
const prefName = cfg.MASTER_SHEET_NAME || 'Masterfile Import';

    const wantedEntity  = String(entity || '').trim().toUpperCase();
    const ss            = SpreadsheetApp.openById(masterId);

    // Helper to pull groups for an entity from a single sheet
        const groupsFromSheet = (sh) => {
      const data = sh.getDataRange().getValues();
      if (data.length < 2) return [];

      const headers = data[0].map(h => String(h || '').trim());
const dims    = _resolveTrackingColumns_(headers);
const idxEntity = dims.dim1Idx;
const idxGroup  = _findHeaderFuzzy_(headers, ['Payroll Group','PAYROLL GROUP','Group','Group Name','Team']);
if (idxEntity === -1 || idxGroup === -1) return [];



      const out = new Set();
      for (let i = 1; i < data.length; i++) {
        const ent = String(data[i][idxEntity] || '').trim().toUpperCase();
        const grp = String(data[i][idxGroup]  || '').trim();
        if (!grp) continue;
        if (!wantedEntity || wantedEntity === 'ALL' || ent === wantedEntity) out.add(grp);
      }
      return Array.from(out);
    };

    // 1) Preferred sheet
    const primary = ss.getSheetByName(prefName);
    let groups    = primary ? groupsFromSheet(primary) : [];

    // 2) Fallback: scan all sheets if needed
    if (!groups.length) {
      ss.getSheets().forEach(sh => {
        if (sh.getName() === prefName) return;
        groups = groups.concat(groupsFromSheet(sh));
      });
    }

    // 3) Unique + sorted + include ALL
    groups = [...new Set(groups)].filter(Boolean).sort((a, b) => a.localeCompare(b));
    return ['ALL', ...groups];

  } catch (err) {
    Logger.log('getPayrollGroupsByEntity error: ' + err.message);
    return ['ALL']; // keep UI usable
  }
}

/**
 * Check if Masterfile has non-zero/non-blank values in "Computed Basic Pay"
 * for the employees included in the current dialog selection (Entity + Payroll Groups).
 *
 * Returns:
 *  { hasValues:boolean, count:number, sampleEmployeeIds:string[], sheetName:string, headerName:string }
 */
function checkMasterfileComputedBasicPay(form) {
  const cfg = _readSettings_();
  if (!cfg.SOURCE_SS_ID) throw new Error('Missing/invalid Employee Masterfile (SOURCE_SS_ID) in Settings.');

  const masterSS = SpreadsheetApp.openById(cfg.SOURCE_SS_ID);
  const masterSh = _mustGetSheet_(masterSS, cfg.MASTER_SHEET_NAME);

  const allRows = masterSh.getDataRange().getValues();
  if (!allRows || allRows.length < 2) {
    return { hasValues: false, count: 0, sampleEmployeeIds: [], sheetName: masterSh.getName(), headerName: '' };
  }

  const rawHeaders = allRows[0].map(h => String(h || '').trim());

  // Same Entity + Payroll Group filtering approach used by core runner
  const entityVal = String((form && form.entity) || '').trim().toUpperCase();

  const normalizeGroups = (g) => {
    if (Array.isArray(g)) return g;
    return String(g || '')
      .split(/[\n,;|]/g)
      .map(s => s.trim())
      .filter(Boolean);
  };

  const rawGroupList = normalizeGroups((form && form.payrollGroups) || []);
  let selectedGroups = new Set(rawGroupList.map(g => String(g).trim().toUpperCase()));
  if (selectedGroups.size > 1 && selectedGroups.has('ALL')) selectedGroups.delete('ALL');
  const isAllGroups = selectedGroups.size === 0;

  const dims = _resolveTrackingColumns_(rawHeaders);
  const entityIdx = dims.dim1Idx;

  const groupIdx = _findHeaderFuzzy_(rawHeaders, [
    'Payroll Group',
    'PAYROLL GROUP',
    'Group',
    'Group Name'
  ]);

  // Employee ID index (for sample reporting)
  const empIdIdx = _findHeaderFuzzy_(rawHeaders, ['Employee ID', 'Emp ID', 'ID']);

  // Computed Basic Pay column (fuzzy + fallback scan)
  let computedIdx = _findHeaderFuzzy_(rawHeaders, [
    'Computed Basic Pay',
    'COMPUTED BASIC PAY',
    'Computed Basic',
    'BASIC PAY (COMPUTED)',
    'ComputedBP'
  ]);

  if (computedIdx === -1) {
    const hdrU = rawHeaders.map(h => String(h || '').trim().toUpperCase());
    computedIdx = hdrU.findIndex(h => h.includes('COMPUTED') && h.includes('BASIC') && h.includes('PAY'));
  }

  if (computedIdx === -1) {
    // Column not present -> nothing to warn about
    return { hasValues: false, count: 0, sampleEmployeeIds: [], sheetName: masterSh.getName(), headerName: '' };
  }

  const headerName = rawHeaders[computedIdx] || 'Computed Basic Pay';

  const hasNonZero = (v) => {
    if (v == null) return false;
    if (typeof v === 'number') return Math.abs(v) > 1e-9;
    const s0 = String(v).trim();
    if (!s0) return false;

    // parse numbers like "1,234.56" or "(1,234.56)"
    let s = s0;
    let neg = false;
    if (s.startsWith('(') && s.endsWith(')')) {
      neg = true;
      s = s.slice(1, -1);
    }
    s = s.replace(/,/g, '');
    const n = parseFloat(s);
    if (isFinite(n)) return Math.abs((neg ? -n : n)) > 1e-9;

    // Non-empty non-numeric -> treat as â€œhas valueâ€
    return true;
  };

  let count = 0;
  const sampleEmployeeIds = [];

  for (let i = 1; i < allRows.length; i++) {
    const r = allRows[i];

    // Entity match (ALL/blank means no restriction)
    let entMatch = true;
    if (entityIdx !== -1) {
      const ent = String(r[entityIdx] || '').trim().toUpperCase();
      entMatch = !entityVal || entityVal === 'ALL' || ent === entityVal;
    }

    if (!entMatch) continue;

    // Group match
    if (!isAllGroups) {
      if (groupIdx === -1) continue; // if dialog picked groups but master has no group col, treat as no match
      const grp = String(r[groupIdx] || '').trim().toUpperCase();
      if (!grp) continue;
      if (!selectedGroups.has(grp)) continue;
    }

    const v = r[computedIdx];
    if (hasNonZero(v)) {
      count++;
      if (sampleEmployeeIds.length < 10 && empIdIdx !== -1) {
        const id = String(r[empIdIdx] || '').trim();
        if (id) sampleEmployeeIds.push(id);
      }
    }
  }

  return {
    hasValues: count > 0,
    count,
    sampleEmployeeIds,
    sheetName: masterSh.getName(),
    headerName
  };
}

/**
 * Clear "Computed Basic Pay" values in Masterfile for the employees included
 * in the current dialog selection (Entity + Payroll Groups).
 *
 * Returns:
 *  { clearedCount:number, sheetName:string, headerName:string }
 */
function clearMasterfileComputedBasicPay(form) {
  const cfg = _readSettings_();
  if (!cfg.SOURCE_SS_ID) throw new Error('Missing/invalid Employee Masterfile (SOURCE_SS_ID) in Settings.');

  const masterSS = SpreadsheetApp.openById(cfg.SOURCE_SS_ID);
  const masterSh = _mustGetSheet_(masterSS, cfg.MASTER_SHEET_NAME);

  const allRows = masterSh.getDataRange().getValues();
  if (!allRows || allRows.length < 2) {
    return { clearedCount: 0, sheetName: masterSh.getName(), headerName: '' };
  }

  const rawHeaders = allRows[0].map(h => String(h || '').trim());

  const entityVal = String((form && form.entity) || '').trim().toUpperCase();

  const normalizeGroups = (g) => {
    if (Array.isArray(g)) return g;
    return String(g || '')
      .split(/[\n,;|]/g)
      .map(s => s.trim())
      .filter(Boolean);
  };

  const rawGroupList = normalizeGroups((form && form.payrollGroups) || []);
  let selectedGroups = new Set(rawGroupList.map(g => String(g).trim().toUpperCase()));
  if (selectedGroups.size > 1 && selectedGroups.has('ALL')) selectedGroups.delete('ALL');
  const isAllGroups = selectedGroups.size === 0;

  const dims = _resolveTrackingColumns_(rawHeaders);
  const entityIdx = dims.dim1Idx;

  const groupIdx = _findHeaderFuzzy_(rawHeaders, [
    'Payroll Group',
    'PAYROLL GROUP',
    'Group',
    'Group Name'
  ]);

  let computedIdx = _findHeaderFuzzy_(rawHeaders, [
    'Computed Basic Pay',
    'COMPUTED BASIC PAY',
    'Computed Basic',
    'BASIC PAY (COMPUTED)',
    'ComputedBP'
  ]);

  if (computedIdx === -1) {
    const hdrU = rawHeaders.map(h => String(h || '').trim().toUpperCase());
    computedIdx = hdrU.findIndex(h => h.includes('COMPUTED') && h.includes('BASIC') && h.includes('PAY'));
  }

  if (computedIdx === -1) {
    return { clearedCount: 0, sheetName: masterSh.getName(), headerName: '' };
  }

  const headerName = rawHeaders[computedIdx] || 'Computed Basic Pay';

  const hasNonZero = (v) => {
    if (v == null) return false;
    if (typeof v === 'number') return Math.abs(v) > 1e-9;
    const s0 = String(v).trim();
    if (!s0) return false;

    let s = s0;
    let neg = false;
    if (s.startsWith('(') && s.endsWith(')')) {
      neg = true;
      s = s.slice(1, -1);
    }
    s = s.replace(/,/g, '');
    const n = parseFloat(s);
    if (isFinite(n)) return Math.abs((neg ? -n : n)) > 1e-9;

    return true;
  };

  // Collect 1-based row numbers in the sheet to clear (header row is 1)
  const rowsToClear = [];

  for (let i = 1; i < allRows.length; i++) {
    const r = allRows[i];

    let entMatch = true;
    if (entityIdx !== -1) {
      const ent = String(r[entityIdx] || '').trim().toUpperCase();
      entMatch = !entityVal || entityVal === 'ALL' || ent === entityVal;
    }
    if (!entMatch) continue;

    if (!isAllGroups) {
      if (groupIdx === -1) continue;
      const grp = String(r[groupIdx] || '').trim().toUpperCase();
      if (!grp) continue;
      if (!selectedGroups.has(grp)) continue;
    }

    if (hasNonZero(r[computedIdx])) {
      rowsToClear.push(i + 1); // i=1 is sheet row 2
    }
  }

  if (!rowsToClear.length) {
    return { clearedCount: 0, sheetName: masterSh.getName(), headerName };
  }

  // Clear in contiguous batches
  rowsToClear.sort((a, b) => a - b);

  const col = computedIdx + 1;
  let clearedCount = 0;

  let start = rowsToClear[0];
  let prev = rowsToClear[0];

  const flush = (sRow, eRow) => {
    const num = (eRow - sRow) + 1;
    masterSh.getRange(sRow, col, num, 1).clearContent();
    clearedCount += num;
  };

  for (let k = 1; k < rowsToClear.length; k++) {
    const rowNum = rowsToClear[k];
    if (rowNum === prev + 1) {
      prev = rowNum;
      continue;
    }
    flush(start, prev);
    start = rowNum;
    prev = rowNum;
  }
  flush(start, prev);

  return { clearedCount, sheetName: masterSh.getName(), headerName };
}


/**
 * Returns display labels for:
 * - dim1 (Tracking Category 1 / Entity / whatever you renamed it to)
 * - dim2 (Tracking Category 2)
 * - Payroll Group
 * Used by the HTML dialog so labels match the Masterfile.
 */
function getDimensionLabels() {
  try {
    const cfg = _readSettings_();
    if (!cfg.SOURCE_SS_ID) throw new Error('Missing SOURCE_SS_ID in settings.');

    const masterSS = SpreadsheetApp.openById(cfg.SOURCE_SS_ID);
    const master   = _mustGetSheet_(masterSS, cfg.MASTER_SHEET_NAME);
    const headers  = master
      .getRange(1, 1, 1, master.getLastColumn())
      .getValues()[0]
      .map(h => String(h || '').trim());

    const dims = _resolveTrackingColumns_(headers);

    return {
      dim1Label: dims.dim1Label,
      dim2Label: dims.dim2Label,
      groupLabel: 'Payroll Groups'
    };
  } catch (e) {
    Logger.log('getDimensionLabels error: ' + e.message);
    return {
      dim1Label: 'Tracking Category 1',
      dim2Label: 'Tracking Category 2',
      groupLabel: 'Payroll Groups'
    };
  }
}




    /* ---------- helpers (safe to reuse your existing ones) ---------- */

function _entitiesFromSheet_(sh) {
  const data = sh.getDataRange().getValues();
  if (data.length < 2) return [];
  const headers = data[0].map(h => String(h||'').trim());
  const dims = _resolveTrackingColumns_(headers);
  const idx = dims.dim1Idx;
  if (idx === -1) return [];
  const set = new Set();
  for (let i = 1; i < data.length; i++) {
    const v = String(data[i][idx] || '').trim();
    if (v) set.add(v);
  }
  return Array.from(set);
}


function _parsePercentOrNumber_(v) {
  const s = String(v || '').trim();
  if (!s) return 0;
  // strip commas and percent
  const n = Number(s.replace(/[, %]/g, ''));
  if (!isFinite(n)) return 0;
  // If someone entered 5 or 5% â†’ 0.05; if 0.05 â†’ 0.05
  return n > 1 ? n / 100 : n;
}

function _canonicalSysKey_(name) {
  const norm = String(name || '')
    .trim()
    .toUpperCase()
    .replace(/[\s\-]+/g, ' '); // ignore spaces / hyphens / case

  switch (norm) {
    case 'SSS EE MC':      return 'SSS EE MC';
case 'SSS EE MPF':     return 'SSS EE MPF';

case 'SSS ER MC':      return 'SSS ER MC';
case 'SSS ER MPF':     return 'SSS ER MPF';

    case 'SSS EC':         return 'SSS EC';

    case 'PHILHEALTH EE':  return 'PhilHealth EE';
    case 'PHILHEALTH ER':  return 'PhilHealth ER';

    case 'PAG IBIG EE':
    case 'PAG-IBIG EE':
    case 'PAGIBIG EE':     return 'Pag-IBIG EE';

    case 'PAG IBIG ER':
    case 'PAG-IBIG ER':
    case 'PAGIBIG ER':     return 'Pag-IBIG ER';
  }

  // --- Withholding tax: allow fuzzy / variants ---
  // bare / simple forms
  if (norm === 'WITHHOLDING TAX' ||
      norm === 'WITHHOLDING' ||
      norm === 'WTAX' ||
      norm === 'W TAX' ||
      norm === 'W/TAX') {
    return 'Withholding Tax';
  }

  // Anything that contains both WITHHOLDING and TAX, e.g.
  // "WITHHOLDING TAX ADJUSTMENT", "ADJ WITHHOLDING TAX", etc.
  if (norm.indexOf('WITHHOLDING') !== -1 && norm.indexOf('TAX') !== -1) {
    return 'Withholding Tax';
  }

  return null;
}


function _isSystemComponentName_(name) {
  return !!_canonicalSysKey_(name);
}


    /**
     * Fuzzy header finder (case-insensitive; ignores spaces/dashes).
     * You already have a version; keep one copy only.
     */
    function _findHeaderFuzzy_(headers, keywords, excludeIdx=[]) {
      const H = headers.map(h => String(h||'').trim());
      for (const k of keywords) {
        const i = H.findIndex(h => h.toLowerCase() === String(k).toLowerCase());
        if (i !== -1 && !excludeIdx.includes(i)) return i;
      }
      const norm = s => String(s).replace(/[\s-]/g,'').toLowerCase();
      const Hn = H.map(norm);
      for (const k of keywords.map(norm)) {
        const i = Hn.indexOf(k);
        if (i !== -1 && !excludeIdx.includes(i)) return i;
      }
      return -1;
    }

// Store dimension mapping in Document Properties so we can
// rename the header text later without changing the script.
const KEY_DIM_CACHE = 'DIMENSION_COLUMN_CACHE_JSON';


function _resolveTrackingColumns_(headers) {
  // Always detect from the current header row â€“ no index caching.
  const H = (headers || []).map(h => String(h || '').trim());
  const docProps = PropertiesService.getDocumentProperties();
  const norm = s => String(s || '').trim().toUpperCase();

  let dim1Idx = -1;
  let dim2Idx = -1;

  // ðŸ”¹ Masterfile pattern:
  //    Col A = EMPLOYEE ID
  //    Col B = STATUS
  //    Col C = CONTRACT TYPE
  //    Col D = Tracking Category 1 (whatever it's renamed to)
  //    Col E = Tracking Category 2 (whatever it's renamed to)
  const looksLikeMaster =
    H.length >= 5 &&
    norm(H[0]) === 'EMPLOYEE ID' &&
    norm(H[1]) === 'STATUS' &&
    norm(H[2]) === 'CONTRACT TYPE';

  if (looksLikeMaster) {
    // âœ… For MASTERFILE: always use fixed columns D and E
    dim1Idx = 3; // column D (0-based)
    dim2Idx = 4; // column E (0-based)
  } else {
    // âœ… For other sheets (view sheets, etc.): keep fuzzy matching
    //    so they still work even if their layout is slightly different.
    dim1Idx = _findHeaderFuzzy_(H, [
      'Tracking Category 1',
      'Client',
      'CLIENT'
    ]);

    dim2Idx = _findHeaderFuzzy_(H, [
      'Tracking Category 2',
      'Cost Center',
      'COST CENTER',
      'Project',
      'PROJECT'
    ]);
  }

  const fallback1 = 'Tracking Category 1';
  const fallback2 = 'Tracking Category 2';

  const dim1Label = dim1Idx >= 0 && H[dim1Idx] ? H[dim1Idx] : fallback1;
  const dim2Label = dim2Idx >= 0 && H[dim2Idx] ? H[dim2Idx] : fallback2;

  // Let the HTML dialog + other logic read the labels from Script Properties
  docProps.setProperty('DIM1_LABEL', dim1Label);
docProps.setProperty('DIM2_LABEL', dim2Label);


  return { dim1Idx, dim1Label, dim2Idx, dim2Label };
}


// DEBUG: dumps config + masterfile headers + dimension resolution
function DEBUG_dumpConfigAndHeaders() {
  try {
    const cfg = _readSettings_();
    Logger.log('[DEBUG] cfg = ' + JSON.stringify(cfg, null, 2));

    if (!cfg || !cfg.SOURCE_SS_ID) {
      Logger.log('[DEBUG] MISSING SOURCE_SS_ID in cfg');
      return;
    }

    const masterSS = SpreadsheetApp.openById(cfg.SOURCE_SS_ID);
    Logger.log('[DEBUG] masterSS name = ' + masterSS.getName());

    const master = masterSS.getSheetByName(cfg.MASTER_SHEET_NAME);
    if (!master) {
      Logger.log('[DEBUG] MISSING MASTER SHEET: ' + cfg.MASTER_SHEET_NAME);
      return;
    }

    const headers = master
      .getRange(1, 1, 1, master.getLastColumn())
      .getValues()[0]
      .map((h, i) => `${i}:${String(h || '').trim()}`);

    Logger.log('[DEBUG] Masterfile headers = ' + headers.join(' | '));

    // Call the same function the engine should be using
    const dims = _resolveTrackingColumns_(
      master.getRange(1, 1, 1, master.getLastColumn()).getValues()[0]
    );
    Logger.log('[DEBUG] _resolveTrackingColumns_ result = ' + JSON.stringify(dims, null, 2));

  } catch (e) {
    Logger.log('[DEBUG] ERROR in DEBUG_dumpConfigAndHeaders: ' + e.message + '\n' + e.stack);
  }
}


function resetDimensionMapping() {
  const props = PropertiesService.getDocumentProperties();
  props.deleteProperty(KEY_DIM_CACHE);
  Logger.log('Dimension column cache cleared. Next run will re-detect.');
}


function _getAgeInYears_(birthDate, asOfDate) {
  if (!birthDate) return null;
  const d = (birthDate instanceof Date && !isNaN(birthDate)) ? birthDate : new Date(birthDate);
  if (!d || isNaN(d)) return null;
  const today = asOfDate || new Date();
  let age = today.getFullYear() - d.getFullYear();
  const m = today.getMonth() - d.getMonth();
  if (m < 0 || (m === 0 && today.getDate() < d.getDate())) age--;
  return age;
}

/**************************************************
 * BIR 1601-C (Part II â€“ Computation of Tax)
 * -----------------------------------------
 * - Uses PAYROLL_HISTORY for amounts
 * - Uses Masterfile (via Settings Center) for MWE flag
 * - Aggregates per Payroll Month (YYYY-MM)
 * - Stores JSON workpaper in Script Properties
 *   under key: BIR1601C_LAST_WORKPAPER_JSON
 **************************************************/

/* =================================================================
 * BIR 1601-C (Part II â€“ Computation of Tax) - GRANULAR FIX
 * ================================================================= */

function showBir1601CDialog() {
  const html = HtmlService.createTemplateFromFile('Bir1601CDialog')
  .evaluate()
    .setWidth(520)
    .setHeight(420);
  SpreadsheetApp.getUi().showModalDialog(html, ' ');
}

/**
 * REPLACEMENT: Exports 1601-C to sheet.
 * Updated headers and numbering to strictly match the official BIR 1601-C form.
 * Includes Lines 21, 22, 23, 24 sequence.
 */
function _exportBir1601CWorkpaperToSheet_(wp, optRows) {
  if (!wp) throw new Error('BIR1601C workpaper is missing.');
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheetName = 'BIR1601C ' + wp.month;
  let sh = ss.getSheetByName(sheetName);
  if (!sh) sh = ss.insertSheet(sheetName);
  sh.clear();
  sh.setHiddenGridlines(true);

  const b = wp.base;
  const n = (v) => Number(v) || 0;

  // --- Calculations for Form Logic ---
  const valLine14 = n(b.line14);
  
  // Total Non-Taxable (Sum of 15, 16, 17, 18, 19, 20)
  const valLine21 = 
    n(b.line15) + n(b.line16) + n(b.line17) + n(b.line18) + n(b.line19) + n(b.line20);

  // Line 22: Total Taxable Compensation
  const valLine22 = Math.max(0, valLine14 - valLine21);

  // Line 23: Taxable comp not subject to w/tax (e.g. employees < 250k who are not MWEs)
  // Currently defaulting to 0 as script doesn't separate this bucket explicitly
  const valLine23 = 0; 

  // Line 24: Net Taxable Compensation
  const valLine24 = Math.max(0, valLine22 - valLine23);

  const rows = optRows || [
    ['Line', 'Description', 'Amount', 'Notes'],
    
    // 14
    ['14', 'Total Amount of Compensation', valLine14,
      'Sum of all earnings columns (excluding Gross Pay total)'],
      
    // 15
    ['15', 'Statutory Minimum Wage for Minimum Wage Earners (MWEs)', n(b.line15),
      'Basic Pay if MWE = Yes'],
      
    // 16
    ['16', 'Holiday Pay, Overtime Pay, Night Shift Differential Pay, Hazard Pay (for MWEs only)', n(b.line16),
      'Overtime/Holiday if MWE = Yes'],
      
    // 17
    ['17', '13th Month Pay and Other Benefits', n(b.line17),
      'Non-taxable portion of 13th month pay and other benefits (within 90k cap)'],
      
    // 18
    ['18', 'De Minimis Benefits', n(b.line18),
      'Category: Non-taxable earning - de minimis'],
      
    // 19
    ['19', 'SSS, GSIS, PHIC, HDMF Mandatory Contributions & Union Dues (employeeâ€™s share only)', n(b.line19),
      'SSS, PhilHealth, HDMF (EE Share Only)'],
      
    // 20
    ['20', 'Other Non-Taxable Compensation (specify)', n(b.line20),
      'Category: Non-taxable earning - other'],
      
    // 21 (Total Non-Taxable)
    ['21', 'Total Non-Taxable Compensation (Sum of Items 15 to 20)', valLine21,
      'Sum of Lines 15, 16, 17, 18, 19, 20'],
      
    // 22 (Total Taxable)
    ['22', 'Total Taxable Compensation (Item 14 Less Item 21)', valLine22,
      'Line 14 minus Line 21'],

    // 23 (Less: Exempt Taxable)
    ['23', 'Less: Taxable compensation not subject to withholding tax', valLine23,
      'For employees (other than MWEs) receiving P250,000 & below for the year'],

    // 24 (Net Taxable)
    ['24', 'Net Taxable Compensation (Item 22 Less Item 23)', valLine24,
      'Line 22 minus Line 23'],
      
    ['', '', '', ''],
    
    // Internal Check (No Line Number to avoid conflict with official Line 23)
    ['Memo', 'Internal Check: Computed Tax Due', n(b.line23), 
     'System calculated tax based on tables (for reference)'],

    // 25 (Tax Withheld)
    ['25', 'Total Taxes Withheld', n(b.line25),
      'Actual Withholding Tax deducted from employees (PAYROLL_HISTORY)']
  ];

  sh.getRange(1, 1, rows.length, 4).setValues(rows);
  
  // Formatting
  sh.getRange(1, 1, 1, 4).setFontWeight('bold').setBackground('#efefef');
  sh.getRange(2, 3, rows.length - 1, 1).setNumberFormat('#,##0.00');
  sh.autoResizeColumns(1, 4);
   sh.setHiddenGridlines(true);
  return sh;
}
/**
 * REPLACEMENT: Writes per-row debug for 1601-C into hidden sheet _DEBUG_1601C.
 * Updated headers to strictly match Lines 14-25 breakdown.
 */
function _writeBir1601CDebugSheet_(wp) {
  const detail = wp.detail || [];
  if (!detail.length) return;

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sh = ss.getSheetByName('_DEBUG_1601C');
  
  // Always verify headers or recreate if missing
  if (!sh) {
    sh = ss.insertSheet('_DEBUG_1601C');
    sh.appendRow([
      'Timestamp',
      'Payroll Month',
      'Emp ID',
      'Employee Name',
      'Is MWE?',
      'Line 14 (Total Comp)',
      'Line 15 (MWE Basic)',
      'Line 16 (MWE Overtime)',
      'Line 17 (Taxable 13th)',
      'Line 18 (De Minimis)',
      'Line 19 (Statutory EE)',
      'Line 20 (Other Non-Tax)',
      'Line 25 (Act. Wtax)'
    ]);
    sh.setFrozenRows(1);
    sh.hideSheet();
  } else {
    // Clean up old debug data
    if (sh.getLastRow() > 1) {
       sh.getRange(2, 1, sh.getLastRow() - 1, sh.getLastColumn()).clearContent();
    }
    // Reset Headers to be safe
    sh.getRange("A1:M1").setValues([[
      'Timestamp', 'Payroll Month', 'Emp ID', 'Employee Name', 'Is MWE?',
      'Line 14 (Total Comp)', 'Line 15 (MWE Basic)', 'Line 16 (MWE Overtime)',
      'Line 17 (Taxable 13th)', 'Line 18 (De Minimis)', 
      'Line 19 (Statutory EE)', 'Line 20 (Other Non-Tax)', 'Line 25 (Act. Wtax)'
    ]]);
  }

  const now = new Date();
  const rows = detail.map(d => [
    now,
    wp.month,
    d.empId || '',
    d.empName || '',
    d.isMwe ? 'YES' : 'NO',
    d.line14 || 0,
    d.line15 || 0,
    d.line16 || 0,
    d.line17 || 0,
    d.line18 || 0,
    d.line19 || 0,
    d.line20 || 0,
    d.line25 || 0
  ]);

  sh.getRange(2, 1, rows.length, rows[0].length).setValues(rows);
}

function generateBir1601CFromDialog(form) {
  if (!form || !form.month) {
    throw new Error('Payroll month is required.');
  }

  var monthStr = String(form.month).trim();
  if (!/^\d{4}-\d{2}$/.test(monthStr)) {
    throw new Error('Invalid month format. Use YYYY-MM (e.g. 2025-11).');
  }

  // Match the manualInputs structure used in _buildBir1601CWorkpaperForMonth_
  var manualInputs = {
    line26: form.line26,
    line28: form.line28,
    line29: form.line29,
    line32: form.line32,
    line33: form.line33,
    line34: form.line34
  };

  // This is your existing builder
  var workpaper = _buildBir1601CWorkpaperForMonth_(monthStr, manualInputs);

  // This is your existing exporter (debug / reference sheet)
  _exportBir1601CWorkpaperToSheet_(workpaper);

  // You can extend later to also create CSV/XLSX/PDF here.
  return {
    month: workpaper.month,
    generatedAt: workpaper.generatedAt || new Date().toISOString(),
    sheetName: 'BIR 1601-C ' + workpaper.month
  };
}


function _buildBir1601CFileFromRows_(rows, output, baseFilename) {
  // ... (Keep existing download logic if needed, or rely on sheet export) ...
  return null; 
}

function generateBir1601CReport(form) {
  // Redirect to the main generator logic
  return generateBir1601CFromDialog(form);
}



function _buildBir1601CRows_(wp) {
  const b = wp.base || {};

  function n(v) { return Number(v) || 0; }

  const valLine14 = n(b.line14);
  const valLine15 = n(b.line15);
  const valLine16 = n(b.line16);
  const valLine17 = n(b.line17);
  const valLine18 = n(b.line18);
  const valLine19 = n(b.line19);
  const valLine20 = n(b.line20);
  
  // Computed Tax (System) vs Actual Withheld (History)
  const valComputedTax = n(b.line23); 
  const valLine25 = n(b.line25);

  const valLine21 = valLine15 + valLine16 + valLine17 + valLine18 + valLine19 + valLine20;
  const valLine22 = Math.max(0, valLine14 - valLine21);
  const valLine23 = 0; // Default 0 for "Taxable comp not subject to tax"
  const valLine24 = Math.max(0, valLine22 - valLine23);

  const rows = [];
  rows.push(['Line', 'Description', 'Amount', 'Notes']);

  rows.push(['14', 'Total Amount of Compensation', valLine14,
    'Sum of all earnings columns (excluding Gross Pay total)']);
    
  rows.push(['15', 'Statutory Minimum Wage for Minimum Wage Earners (MWEs)', valLine15,
    'Basic Pay if MWE = Yes']);
    
  rows.push(['16', 'Holiday Pay, Overtime Pay, Night Shift Differential Pay, Hazard Pay (for MWEs only)', valLine16,
    'Overtime/Holiday if MWE = Yes']);
    
  rows.push(['17', '13th Month Pay and Other Benefits', valLine17,
    'Non-taxable portion of 13th month pay and other benefits (within 90k cap)']);
    
  rows.push(['18', 'De Minimis Benefits', valLine18,
    'Category: Non-taxable earning - de minimis']);
    
  rows.push(['19', 'SSS, GSIS, PHIC, HDMF Mandatory Contributions & Union Dues (employeeâ€™s share only)', valLine19,
    'SSS, PhilHealth, HDMF (EE Share Only)']);
    
  rows.push(['20', 'Other Non-Taxable Compensation (specify)', valLine20,
    'Category: Non-taxable earning - other']);
    
  rows.push(['21', 'Total Non-Taxable Compensation (Sum of Items 15 to 20)', valLine21,
    'Sum of Lines 15 to 20']);
    
  rows.push(['22', 'Total Taxable Compensation (Item 14 Less Item 21)', valLine22,
    'Line 14 minus Line 21']);

  rows.push(['23', 'Less: Taxable compensation not subject to withholding tax', valLine23,
    'For employees (other than MWEs) receiving P250,000 & below for the year']);

  rows.push(['24', 'Net Taxable Compensation (Item 22 Less Item 23)', valLine24,
    'Line 22 minus Line 23']);
    
  rows.push(['', '', 0, '']);

  rows.push(['Memo', 'Internal Check: Computed Tax', valComputedTax,
    'System computed tax (reference only)']);
    
  rows.push(['25', 'Total Taxes Withheld', valLine25,
    'Actual Withholding Tax from PAYROLL_HISTORY']);

  return rows;
}
/**
 * Builds an in-memory file from rows for download via HTML:
 *  - output = 'csv' | 'xlsx' | 'pdf'
 * Returns {fileName, mimeType, contentBase64}
 */
function _buildBir1601CFileFromRows_(rows, output, baseFilename) {
  output = String(output || 'csv').toLowerCase();

  // Always have a CSV representation (needed for CSV downloads)
  function makeCsv(rows) {
    return rows.map(r => r.map(v => {
      v = (v === null || v === undefined) ? '' : String(v);
      if (/[",\n]/.test(v)) {
        v = '"' + v.replace(/"/g, '""') + '"';
      }
      return v;
    }).join(',')).join('\r\n');
  }

  if (output === 'csv') {
    const csv = makeCsv(rows);
    return {
      fileName: baseFilename + '.csv',
      mimeType: 'text/csv',
      contentBase64: Utilities.base64Encode(csv, Utilities.Charset.UTF_8),
    };
  }

  // For XLSX/PDF: create a temporary sheet, export via UrlFetchApp, then delete
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const temp = ss.insertSheet('TMP_1601C_' + Date.now());
  temp.getRange(1, 1, rows.length, rows[0].length).setValues(rows);

  const ssId = ss.getId();
  const gid = temp.getSheetId();
  const token = ScriptApp.getOAuthToken();

  let formatParam, mimeType, ext;
  if (output === 'xlsx') {
    formatParam = 'xlsx';
    mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
    ext = '.xlsx';
  } else { // pdf
    formatParam = 'pdf';
    mimeType = 'application/pdf';
    ext = '.pdf';
  }

  const url = 'https://docs.google.com/spreadsheets/d/' + ssId +
    '/export?format=' + formatParam +
    '&gid=' + gid +
    '&size=letter' +
    '&portrait=true' +
    '&fitw=true' +
    '&sheetnames=false' +
    '&printtitle=false' +
    '&pagenum=UNDEFINED' +
    '&gridlines=false' +
    '&fzr=FALSE';

  const resp = UrlFetchApp.fetch(url, {
    headers: { Authorization: 'Bearer ' + token },
    muteHttpExceptions: true,
  });

  ss.deleteSheet(temp);

  if (resp.getResponseCode() !== 200) {
    throw new Error('Failed to export 1601-C ' + output.toUpperCase() + ': ' + resp.getContentText());
  }

  return {
    fileName: baseFilename + ext,
    mimeType: mimeType,
    contentBase64: Utilities.base64Encode(resp.getContent()),
  };
}

function _buildPayrollRegisterRowsForMonth_(monthStr) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const hist = ss.getSheetByName('PAYROLL_HISTORY');
  if (!hist) return null;

  const values = hist.getDataRange().getValues();
  if (!values || values.length < 1) return null;

  const headers = values[0].map(h => String(h || '').trim());
  const rows = values.slice(1);

  const idxPayrollMonth = headers.indexOf('Payroll Month');
  const idxPeriod = headers.indexOf('Period');

  function toMonthKey(s) {
    s = String(s || '').trim();
    if (!s) return '';
    const m = s.match(/^(\d{4})[-\/](\d{1,2})/);
    if (m) {
      const y = Number(m[1]);
      const mo = Number(m[2]);
      if (y && mo >= 1 && mo <= 12) {
        return y + '-' + ('0' + mo).slice(-2);
      }
    }
    return '';
  }

  let monthRows = [];
  if (idxPayrollMonth > -1) {
    monthRows = rows.filter(r => toMonthKey(r[idxPayrollMonth]) === monthStr);
  } else if (idxPeriod > -1) {
    const year = monthStr.slice(0, 4);
    const month = monthStr.slice(5, 7);
    const prefix = year + '-' + month;
    monthRows = rows.filter(r => String(r[idxPeriod] || '').trim().indexOf(prefix) === 0);
  } else {
    monthRows = [];
  }

  // Always return headers even if no rows match (so Excel still gets the sheet)
  return [headers].concat(monthRows);
}


/**
 * Very simple payroll register per Payroll Month.
 * Creates/refreshes sheet "Payroll Register â€“ YYYY-MM" filtered from PAYROLL_HISTORY.
 */
function _exportPayrollRegisterForMonth_(monthStr) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const hist = ss.getSheetByName('PAYROLL_HISTORY');
  if (!hist) return;

  const values = hist.getDataRange().getValues();
  if (!values.length) return;

  const headers = values[0].map(h => String(h || '').trim());
  const rows = values.slice(1);

  const idxPayrollMonth = headers.indexOf('Payroll Month');
  const idxPeriod = headers.indexOf('Period');

  function toMonthKey(s) {
    s = String(s || '').trim();
    if (!s) return '';
    const m = s.match(/^(\d{4})[-\/](\d{1,2})/);
    if (m) {
      const y = Number(m[1]);
      const mo = Number(m[2]);
      if (y && mo >= 1 && mo <= 12) {
        return y + '-' + ('0' + mo).slice(-2);
      }
    }
    return '';
  }

  let monthRows;
  if (idxPayrollMonth > -1) {
    monthRows = rows.filter(r => toMonthKey(r[idxPayrollMonth]) === monthStr);
  } else if (idxPeriod > -1) {
    const year = monthStr.slice(0,4);
    const month = monthStr.slice(5,7);
    const prefix = year + '-' + month;
    monthRows = rows.filter(r => String(r[idxPeriod] || '').trim().indexOf(prefix) === 0);
  } else {
    return;
  }

  if (!monthRows || !monthRows.length) return;

  const sheetName = 'Payroll Register â€“ ' + monthStr;
  let sh = ss.getSheetByName(sheetName);
  if (!sh) sh = ss.insertSheet(sheetName); else sh.clear();

  const out = [headers].concat(monthRows);
  sh.getRange(1, 1, out.length, out[0].length).setValues(out);
sh.setFrozenRows(1);
sh.setHiddenGridlines(true);

}

/**
 * BIR 1601-C (Part II) workpaper.
 * STRICTLY uses component categories (Masterfile + Inputs),
 * but also falls back to header name to catch "De Minimis" etc.
 */
function _buildBir1601CWorkpaperForMonth_(monthStr, manualInputs) {
  const ss   = SpreadsheetApp.getActiveSpreadsheet();
  const hist = ss.getSheetByName('PAYROLL_HISTORY');
  if (!hist) throw new Error('PAYROLL_HISTORY sheet not found.');

  const values = hist.getDataRange().getValues();
  if (values.length < 2) throw new Error('PAYROLL_HISTORY is empty.');

  const header = values[0].map(h => String(h || '').trim());
  const rows   = values.slice(1).filter(r => r.some(v => v !== '' && v != null));

  // --- 1. Load Component Mappings (Masterfile + Inputs/Adjustments) ---
  const cfg     = _readSettings_();
const compMap = _buildComponentMap_(cfg);
const mweMap  = _getMweFlagMap_();
const contractTypeMap = _getContractTypeMapFor1601C_();


  // YTD for 13th-month / other-benefits 90k cap
  const year                 = Number(monthStr.split('-')[0]);
  const ytdOtherBenefitsMap  = _loadYtdOtherBenefitsMap_(hist, year, compMap);
  const OTHER_BENEFITS_CAP   = 90000;

const hasSssEeBreakdown = header.some(h => {
  const up = String(h || '').trim().toUpperCase();
  return up === 'SSS EE MC' || up === 'SSS EE MPF';
});


  // --- 2. Map Columns â†’ 1601-C Buckets ---
  const colMap = header.map(h => {
    const rawName = String(h || '').trim();
    const up      = rawName.toUpperCase();

    // Identity / totals we NEVER want to sum again
    if ([
      'EMPLOYEE ID',
      'EMPLOYEE NAME',
      'PERIOD',
      'PAYROLL MONTH',
      'GROSS PAY',
      'NET PAY',
      'TOTAL',
      'TOTALS',
      'TAXABLE INCOME',
      'TAXABLE INCOME (FINAL)'
    ].indexOf(up) !== -1) {
      return null;
    }

    // Statutory EE columns â†’ Line 19
// Prefer SSS breakdown columns (MC/MPF). If breakdown exists, ignore "SSS EE" to avoid double-count.
if (/^SSS\s*EE$/i.test(up) && hasSssEeBreakdown) return null;

if (/^SSS\s*EE\s*(MC|MPF)$/i.test(up)) return 'STATUTORY_EE';

if (/^(PHILHEALTH|PAG-IBIG|HDMF|PAGIBIG)\s*EE$/i.test(up)) return 'STATUTORY_EE';

    // Withholding tax
    if (/^(WITHHOLDING TAX|WTAX)$/i.test(up)) {
      return 'WTAX';
    }

    // Category from map (Masterfile + Inputs / Recurring Adjustments)
    let cat = (_classifyComponent_(rawName, compMap) || '')
      .toLowerCase()
      .replace(/\s+/g, ' ')
      .trim();

    // If category missing / "other", fall back to header-based guess
    if (!cat || cat === 'other') {
      if (/DEMINIMIS|DE\s*MINIMIS/i.test(up)) {
        cat = 'non-taxable earning - de minimis';
      } else if (/NON.?TAX|NONTAX/i.test(up)) {
        cat = 'non-taxable earning - other';
      } else if (/13TH|BONUS|OTHER\s+BENEFIT/i.test(up)) {
        cat = '13th month pay and other benefits';
      } else if (/BASIC|SALARY/i.test(up)) {
        cat = 'basic pay related';
      } else if (/ALLOWANCE|OT|OVERTIME|HOLIDAY|NIGHT|ND/i.test(up)) {
        cat = 'taxable earning';
      }
    }
    // ADDITION items (e.g., reimbursements) are net-only and must NOT be counted as compensation in 1601-C
if (cat === 'addition' || /REIMBURSE/i.test(up)) return null;


    const isNonTaxish =
      /non[-\s]?tax/i.test(cat) ||
      /NON.?TAX|NONTAX/i.test(up);

    const hasDeMinimis =
      /de\s*minimis/i.test(cat) ||
      /DEMINIMIS|DE\s*MINIMIS/i.test(up);

    // --- FINAL bucket decisions ---

    // Line 18: De Minimis (priority)
    if (isNonTaxish && hasDeMinimis ||
        cat === 'non-taxable earning - de minimis') {
      return 'DEMINIMIS';
    }

    // Line 20: Other Non-Taxable
    if (isNonTaxish ||
        cat === 'non-taxable earning' ||
        cat === 'non-taxable earning - other') {
      return 'OTHER_NONTAX';
    }

    // Line 17 source: 13th month / other benefits
    if (cat.indexOf('13th') !== -1 ||
        cat.indexOf('other benefit') !== -1 ||
        cat.indexOf('13th month pay') !== -1 ||
        /13TH|BONUS/i.test(up)) {
      return '13TH_OTHER';
    }

    // Overtime / night diff / holiday (for MWE line 16)
    if (cat.indexOf('taxable earning') === 0 &&
        /(OT|OVERTIME|NIGHT|HOLIDAY|ND)/i.test(up)) {
      return 'OVERTIME_HOLIDAY';
    }

    // Basic Pay (Line 14 + MWE Line 15)
    if (cat.indexOf('basic pay related') === 0 ||
        cat.indexOf('basic') === 0 ||
        up === 'BASIC PAY') {
      return 'BASIC_RELATED';
    }

    // General taxable earning â†’ still part of Line 14
    if (cat.indexOf('taxable earning') === 0 ||
        /ALLOWANCE/i.test(up)) {
      return 'TAXABLE_EARNING';
    }

    // Loans / pure deductions etc. are ignored for 1601-C compensation
    return 'IGNORE';
  });

  const idxEmpId        = _idxHeader_(header, 'Employee ID');
  const idxEmpName      = _idxHeader_(header, 'Employee Name');
  const idxPeriod       = _idxHeader_(header, 'Period');
  const idxPayrollMonth = _idxHeader_(header, 'Payroll Month');

  // --- 3. Filter Rows for the requested Payroll Month ---
  const normalizeMonth = (val) => {
    if (val instanceof Date) {
      return Utilities.formatDate(val, ss.getSpreadsheetTimeZone(), 'yyyy-MM');
    }
    const s = String(val || '').trim();
    if (/^\d{4}-\d{2}/.test(s)) return s.substring(0, 7);
    return '';
  };

  const monthRows = rows.filter(r => {
    let key = idxPayrollMonth > -1 ? normalizeMonth(r[idxPayrollMonth]) : '';
    if (!key && idxPeriod > -1) key = normalizeMonth(r[idxPeriod]);
    return key === monthStr;
  });

  if (!monthRows.length) {
    throw new Error('No data found for ' + monthStr + ' in PAYROLL_HISTORY.');
  }

  // --- 4. Summation Logic per employee ---
  let totalLine14 = 0;
  let totalLine15 = 0;
  let totalLine16 = 0;
  let totalLine17 = 0;
  let totalLine18 = 0;
  let totalLine19 = 0;
  let totalLine20 = 0;
  let totalLine25 = 0;
  let calculatedTaxDueTotal = 0;

  const detail = [];

  monthRows.forEach(r => {
  const empId = String(r[idxEmpId] || '').trim();
  if (!empId) return;

  // âœ… FILTER: Exclude non-employees based on Masterfile CONTRACT TYPE
  const ct = String(contractTypeMap.get(empId) || '').trim().toUpperCase();
  // - blank / missing contract type â†’ treated as Employee (included)
  // - anything explicitly not EMPLOYEE â†’ excluded
  if (ct && ct !== 'EMPLOYEE') return;

  const empName = idxEmpName > -1 ? r[idxEmpName] : '';
  const isMwe   = mweMap.get(empId);


    let rowBasic          = 0;
    let rowOT             = 0;
    let rowTaxableGeneral = 0;
    let row13thTotal      = 0;
    let rowDeminimis      = 0;
    let rowStatutory      = 0;
    let rowOtherNontax    = 0;
    let rowWtax           = 0;

    r.forEach((val, c) => {
      const type = colMap[c];
      const v    = Number(val) || 0;
      if (!type || v === 0) return;

      if (type === 'WTAX')             rowWtax       += Math.abs(v);
      if (type === 'STATUTORY_EE')     rowStatutory  += Math.abs(v);
      if (type === 'BASIC_RELATED')    rowBasic      += v;
      if (type === 'OVERTIME_HOLIDAY') rowOT         += v;
      if (type === 'TAXABLE_EARNING')  rowTaxableGeneral += v;
      if (type === '13TH_OTHER')       row13thTotal  += v;
      if (type === 'DEMINIMIS')        rowDeminimis  += v;
      if (type === 'OTHER_NONTAX')     rowOtherNontax += v;
    });

    // --- Line 17 Logic: Calculate NON-TAXABLE vs TAXABLE 13th Month / Other Benefits ---
    const ytdTotal = ytdOtherBenefitsMap.get(empId) || 0; 
    const ytdPrior = Math.max(0, ytdTotal - row13thTotal); 
    const remainingExempt = Math.max(0, OTHER_BENEFITS_CAP - ytdPrior);

    // Portion of this run's 13th/other benefits that is NON-TAXABLE (within 90k cap)
    const nonTaxable13th = Math.min(row13thTotal, remainingExempt);

    // Portion that is TAXABLE (still part of line 14, but NOT in "total non-taxable")
    const taxable13th = Math.max(0, row13thTotal - nonTaxable13th);

    // --- Line 14: Total Compensation (FULL amount, including non-taxable) ---
    const rowLine14 = rowBasic
                    + rowOT
                    + rowTaxableGeneral
                    + row13thTotal
                    + rowDeminimis
                    + rowOtherNontax;

    // --- Line 15: MWE Basic ---
    const rowLine15 = isMwe ? rowBasic : 0;

    // --- Line 16: MWE OT ---
    const rowLine16 = isMwe ? rowOT : 0;

    // --- Line 17: NON-TAXABLE PORTION of 13th month pay and other benefits ---
    const rowLine17 = nonTaxable13th;

    // --- Line 23/25: Tax Due / Withholding ---
    const rowTaxDue = rowWtax;

    // Accumulate totals
    totalLine14 += rowLine14;
    totalLine15 += rowLine15;
    totalLine16 += rowLine16;
    totalLine17 += rowLine17;
    totalLine18 += rowDeminimis;
    totalLine19 += rowStatutory;
    totalLine20 += rowOtherNontax;
    totalLine25 += rowWtax;
    calculatedTaxDueTotal += rowTaxDue;

    detail.push({
      empId, empName, isMwe,
      line14: rowLine14,
      line15: rowLine15,
      line16: rowLine16,
      line17: rowLine17,
      line18: rowDeminimis,
      line19: rowStatutory,
      line20: rowOtherNontax,
      line25: rowWtax
    });

  });

  // --- 5. Consolidate base + manual inputs ---
  const b = {};
  b.line14 = totalLine14;
  b.line15 = totalLine15;
  b.line16 = totalLine16;
  b.line17 = totalLine17;
  b.line18 = totalLine18;
  b.line19 = totalLine19;
  b.line20 = totalLine20;
  b.line23 = calculatedTaxDueTotal;
  b.line25 = totalLine25;
    // Total non-taxable = 15 + 16 + 17 + 18 + 19 + 20
  b.totalNonTaxable =
    b.line15 +
    b.line16 +
    b.line17 +
    b.line18 +
    b.line19 +
    b.line20;


  const m      = manualInputs || {};
  const line30 = (Number(m.line32) || 0) + (Number(m.line33) || 0) + (Number(m.line34) || 0);
  const line31 = (Number(m.line29) || 0) + line30;

  const workpaper = {
    month: monthStr,
    base: b,
    manualInputs: m,
    totals: { line30, line31 },
    detail: detail
  };

  PropertiesService.getDocumentProperties()
    .setProperty('BIR1601C_LAST_WORKPAPER_JSON', JSON.stringify(workpaper));

  _writeBir1601CDebugSheet_(workpaper);
  return workpaper;
}

function _exportBir1601CWorkpaperToSheet_(wp, optRows) {
  if (!wp) throw new Error('BIR1601C workpaper is missing.');
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheetName = 'BIR 1601-C ' + wp.month;
  let sh = ss.getSheetByName(sheetName);
  if (!sh) sh = ss.insertSheet(sheetName);
  sh.clear();

  const b = wp.base;
  const m = wp.manualInputs;
  const t = wp.totals;
  const n = (v) => Number(v) || 0;

  // Total Non-Taxable (Sum of 15, 16, 17, 18, 19, 20)
  const totalNonTaxable =
    n(b.line15) +
    n(b.line16) +
    n(b.line17) +
    n(b.line18) +
    n(b.line19) +
    n(b.line20);

  // Net taxable compensation = Line 14 âˆ’ total non-taxable
  const taxableCompForForm = Math.max(0, n(b.line14) - totalNonTaxable);

  const rows = optRows || [
    ['Line', 'Description', 'Amount', 'Notes'],
    ['14', 'Total Compensation', n(b.line14),
      'Sum of all earnings columns (excluding Gross Pay total)'],
    ['15', 'Less: MWE Basic Pay', n(b.line15),
      'Basic Pay if MWE = Yes'],
    ['16', 'Less: MWE Overtime', n(b.line16),
      'Overtime/Holiday if MWE = Yes'],
    ['17', 'Non-taxable 13th month pay and other benefits', n(b.line17),
      'Non-taxable portion of 13th month pay and other benefits (within 90k cap)'],
    ['18', 'Less: De Minimis Benefits', n(b.line18),
      'Category: Non-taxable earning - de minimis'],
    ['19', 'Less: Statutory Contributions', n(b.line19),
      'SSS, PhilHealth, HDMF (EE Share Only)'],
    ['20', 'Less: Other Non-Taxable', n(b.line20),
      'Category: Non-taxable earning - other'],
    ['', 'Total Non-Taxable', totalNonTaxable,
      'Sum of Lines 15, 16, 17, 18, 19, 20'],
    ['', 'Net Taxable Compensation', taxableCompForForm,
      'Line 14 - Total Non-Taxable'],
    ['', '', '', ''],
    ['23', 'Tax Due', n(b.line23), 'Computed Tax'],
    ['25', 'Tax Withheld', n(b.line25),
      'Actual Withholding Tax from History'],
    ['26', 'Less: Remitted Prev Return', n(m.line26),
      'Manual Input'],
    ['28', 'Add/Less: Adjustment', n(m.line28),
      'Manual Input'],
    ['29', 'Tax Still Due / (Overremitted)', n(m.line29),
      'Manual Input'],
    ['32', 'Surcharge', n(m.line32), 'Manual Input'],
    ['33', 'Interest', n(m.line33), 'Manual Input'],
    ['34', 'Compromise', n(m.line34), 'Manual Input'],
    ['30', 'Total Penalties', n(t.line30),
      'Sum of 32, 33, 34'],
    ['31', 'Total Amount Payable', n(t.line31),
      'Line 29 + Line 30'],
  ];

  sh.getRange(1, 1, rows.length, 4).setValues(rows);
  sh.getRange(1, 1, 1, 4).setFontWeight('bold').setBackground('#efefef');
  sh.getRange(2, 3, rows.length - 1, 1).setNumberFormat('#,##0.00');
  sh.autoResizeColumns(1, 4);
  return sh;
}


/**
 * REPLACEMENT: Writes per-row debug for 1601-C into hidden sheet _DEBUG_1601C.
 * Updated headers to strictly match Lines 14-25 breakdown.
 */
function _writeBir1601CDebugSheet_(wp) {
  const detail = wp.detail || [];
  if (!detail.length) return;

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sh = ss.getSheetByName('_DEBUG_1601C');
  
  // Always verify headers or recreate if missing
  if (!sh) {
    sh = ss.insertSheet('_DEBUG_1601C');
    sh.appendRow([
      'Timestamp',
      'Payroll Month',
      'Emp ID',
      'Employee Name',
      'Is MWE?',
      'Line 14 (Total Comp)',
      'Line 15 (MWE Basic)',
      'Line 16 (MWE Overtime)',
      'Line 17 (Taxable 13th)',
      'Line 18 (De Minimis)',
      'Line 19 (Statutory EE)',
      'Line 20 (Other Non-Tax)',
      'Line 25 (Act. Wtax)'
    ]);
    sh.setFrozenRows(1);
    sh.hideSheet();
  }

  const now = new Date();
  const rows = detail.map(d => [
    now,
    wp.month,
    d.empId || '',
    d.empName || '',
    d.isMwe ? 'YES' : 'NO',
    d.line14 || 0,
    d.line15 || 0,
    d.line16 || 0,
    d.line17 || 0,
    d.line18 || 0,
    d.line19 || 0,
    d.line20 || 0,
    d.line25 || 0
  ]);

  sh.getRange(sh.getLastRow() + 1, 1, rows.length, rows[0].length).setValues(rows);
}
/**
 * Called from BIR1601CDialog.html via google.script.run.
 * form = {
 *   month: 'YYYY-MM',
 *   line26: number,
 *   line28: number,
 *   line29: number,
 *   line32: number,
 *   line33: number,
 *   line34: number
 * }
 */
function generateBir1601CFromDialog(form) {
  if (!form || !form.month) {
    throw new Error('Payroll month is required.');
  }

  var monthStr = String(form.month).trim();
  if (!/^\d{4}-\d{2}$/.test(monthStr)) {
    throw new Error('Invalid month format. Use YYYY-MM (e.g. 2025-11).');
  }

  // Match the manualInputs structure used in _buildBir1601CWorkpaperForMonth_
  var manualInputs = {
    line26: form.line26,
    line28: form.line28,
    line29: form.line29,
    line32: form.line32,
    line33: form.line33,
    line34: form.line34
  };

  // This is your existing builder
  var workpaper = _buildBir1601CWorkpaperForMonth_(monthStr, manualInputs);

  // This is your existing exporter (debug / reference sheet)
  _exportBir1601CWorkpaperToSheet_(workpaper);

  // You can extend later to also create CSV/XLSX/PDF here.
  return {
    month: workpaper.month,
    generatedAt: workpaper.generatedAt || new Date().toISOString()
  };
}


/**
 * REPLACEMENT: Main Entry point from Dialog.
 * - Generates Google Sheet Workpaper.
 * - Optionally generates Excel download (CSV/PDF removed).
 */
function generateBir1601CReport(form) {
  try {
    const monthStr = String(form.month || '').trim();
    if (!/^\d{4}-\d{2}$/.test(monthStr)) {
      throw new Error('Invalid Payroll Month. Use YYYY-MM (e.g. 2025-11).');
    }

    // Manual inputs defaulting to 0 since UI inputs are hidden
    const manualInputs = {
      line26: 0, line28: 0, line29: 0,
      line32: 0, line33: 0, line34: 0,
    };

    // 1. Build Data Object
    const workpaper = _buildBir1601CWorkpaperForMonth_(monthStr, manualInputs);

    // 2. Build Row Arrays (Line 14-25)
    const rows = _buildBir1601CRows_(workpaper);

    // 3. Create/Refresh the internal Google Sheet tab
    const sheet = _exportBir1601CWorkpaperToSheet_(workpaper, rows);

    // 4. Optional: Generate Excel Download
        let download = null;
    if (form.downloadExcel) {
      const sheetName1601c = sheet ? sheet.getName() : ('BIR 1601-C ' + workpaper.month);

      let registerRows = null;
      let registerSheetName = null;
      if (form.includeRegister) {
        registerRows = _buildPayrollRegisterRowsForMonth_(workpaper.month);
        registerSheetName = 'Payroll Register â€“ ' + workpaper.month;
      }

      download = _generateBir1601CExcel_(
        rows,
        'BIR 1601-C Part II - ' + workpaper.month,
        sheetName1601c,
        registerRows,
        registerSheetName
      );
    }


    return {
      ok: true,
      message: 'BIR 1601-C generated for ' + workpaper.month +
        (download ? ' (Excel ready)' : ''),
      download: download,
      sheetName: sheet ? sheet.getName() : '',
      month: workpaper.month,
    };
  } catch (err) {
    return { ok: false, message: String(err && err.message || err) };
  }
}

/**
 * NEW FUNCTION: Generates Excel file specifically.
 * FIX INCLUDED: Adds SpreadsheetApp.flush() to prevent "no content" / empty file errors.
 */
function _generateBir1601CExcel_(rows1601c, baseFilename, sheetName1601c, registerRows, registerSheetName) {
  const token = ScriptApp.getOAuthToken();
  const tmp = SpreadsheetApp.create('TMP_EXPORT_1601C_' + Date.now());
  const tmpId = tmp.getId();

  try {
    // Ensure we control sheet names
    const sheets = tmp.getSheets();
    const sh1601c = sheets && sheets.length ? sheets[0] : tmp.insertSheet();
    sh1601c.setName(sheetName1601c || 'BIR 1601-C');
    sh1601c.clear();
    sh1601c.setHiddenGridlines(true);

    // Write 1601C rows
    if (rows1601c && rows1601c.length && rows1601c[0] && rows1601c[0].length) {
      sh1601c.getRange(1, 1, rows1601c.length, rows1601c[0].length).setValues(rows1601c);
      sh1601c.getRange(1, 1, 1, 4).setFontWeight('bold').setBackground('#efefef');
      if (rows1601c.length > 1) {
        sh1601c.getRange(2, 3, rows1601c.length - 1, 1).setNumberFormat('#,##0.00');
      }
      sh1601c.autoResizeColumns(1, 4);
    }

    // Optional: add Payroll Register as 2nd sheet in the SAME XLSX
    if (registerRows && registerRows.length && registerRows[0] && registerRows[0].length) {
      const shReg = tmp.insertSheet(registerSheetName || 'Payroll Register');
      shReg.clear();
      shReg.setHiddenGridlines(true);

      shReg.getRange(1, 1, registerRows.length, registerRows[0].length).setValues(registerRows);
      shReg.setFrozenRows(1);
      shReg.getRange(1, 1, 1, registerRows[0].length).setFontWeight('bold').setBackground('#efefef');
      shReg.autoResizeColumns(1, registerRows[0].length);
    }

    SpreadsheetApp.flush();

    // Export entire temp spreadsheet as XLSX (multi-sheet)
    const url = 'https://docs.google.com/spreadsheets/d/' + tmpId +
      '/export?format=xlsx' +
      '&size=letter' +
      '&portrait=true' +
      '&fitw=true' +
      '&gridlines=false';

    const resp = UrlFetchApp.fetch(url, {
      headers: { Authorization: 'Bearer ' + token },
      muteHttpExceptions: true,
    });

    if (resp.getResponseCode() !== 200) {
      throw new Error('Failed to export Excel: ' + resp.getContentText());
    }

    return {
      fileName: baseFilename + '.xlsx',
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      contentBase64: Utilities.base64Encode(resp.getContent()),
    };

  } finally {
    // Cleanup temp spreadsheet file
    try {
      DriveApp.getFileById(tmpId).setTrashed(true);
    } catch (e) {}
  }
}

/**************************************************
 * STATUTORY REPORTS (SSS / PhilHealth / Pag-IBIG)
 * - Uses PAYROLL_HISTORY
 * - Aggregates per calendar month (Period prefix YYYY-MM)
 * - Direct download as CSV, Excel, or PDF (no Drive file kept)
 **************************************************/

function showStatutoryReportsDialog() {
  const html = HtmlService
    .createTemplateFromFile('StatutoryReportsDialog')
    .evaluate()
    .setWidth(420)
    .setHeight(420);
  SpreadsheetApp.getUi().showModalDialog(html, ' ');
}

/**
 * REPLACEMENT: Statutory Reports Generator
 * - Supports Google Sheet Export
 * - Supports Excel Download
 * - Removes CSV/PDF
 */
function generateStatutoryReport(form) {
  try {
    if (!form || !form.month) {
      throw new Error('Please select a Payroll Month (YYYY-MM).');
    }

    var monthStr = String(form.month).trim(); // e.g. "2025-11"
    var parts = monthStr.split('-');
    if (parts.length !== 2) throw new Error('Invalid month format.');
    
    var year = parts[0];
    var month = parts[1];
    var monthIdx = Number(month) - 1;
    var monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
    var labelFull = monthNames[monthIdx] + ' ' + year;

    var ss = SpreadsheetApp.getActiveSpreadsheet();
    var tz = ss.getSpreadsheetTimeZone() || 'Asia/Manila';
    var histSheet = ss.getSheetByName('PAYROLL_HISTORY');
    
    if (!histSheet) throw new Error('PAYROLL_HISTORY sheet not found.');
    var values = histSheet.getDataRange().getValues();
    if (values.length < 2) throw new Error('PAYROLL_HISTORY has no data.');

    var header = values[0].map(function (h) { return String(h || '').trim(); });
    var dataRows = values.slice(1).filter(function (r) {
      return r.some(function (v) { return v !== '' && v != null; });
    });

    // Helper to find column index
    function idxOf(name) {
      var target = String(name || '').toUpperCase();
      for (var i = 0; i < header.length; i++) {
        if (String(header[i] || '').toUpperCase() === target) return i;
      }
      return -1;
    }

    // --- Column Mapping ---
    var idxPeriod = idxOf('Period');
    var idxPayrollMonth = idxOf('Payroll Month');
    var idxEmpId = idxOf('Employee ID');
    var idxEmpName = idxOf('Employee Name');

    if (idxEmpId === -1 || idxEmpName === -1) throw new Error('Missing Employee ID/Name columns.');

    var idxSssEe = idxOf('SSS EE MC');
    var idxSssEeMpf = idxOf('SSS EE MPF');
    var idxSssEr = idxOf('SSS ER MC');
    var idxSssErMpf = idxOf('SSS ER MPF');
    var idxSssEc = idxOf('SSS EC');
    var idxPhEe = idxOf('PhilHealth EE');
    var idxPhEr = idxOf('PhilHealth ER');
    var idxPiEe = (idxOf('Pag-IBIG EE') > -1) ? idxOf('Pag-IBIG EE') : idxOf('HDMF EE');
    var idxPiEr = (idxOf('Pag-IBIG ER') > -1) ? idxOf('Pag-IBIG ER') : idxOf('HDMF ER');
    var idxSssLoan = idxOf('SSS LOAN');
    var idxSssCalamity = idxOf('SSS CALAMITY LOAN');
    var idxPiLoan = (idxOf('HDMF LOAN') > -1) ? idxOf('HDMF LOAN') : idxOf('Pag-IBIG LOAN');
    var idxPiCalamity = (idxOf('HDMF CALAMITY LOAN') > -1) ? idxOf('HDMF CALAMITY LOAN') : idxOf('Pag-IBIG CALAMITY LOAN');

    // --- Filter Rows by Month ---
    var monthRows = dataRows.filter(function(r) {
      var pMonth = r[idxPayrollMonth];
      var pPeriod = r[idxPeriod];
      
      // Try Payroll Month Column First
      if (idxPayrollMonth > -1 && pMonth) {
        var s = String(pMonth).trim();
        if (Object.prototype.toString.call(pMonth) === '[object Date]') {
           return Utilities.formatDate(pMonth, tz, 'yyyy-MM') === monthStr;
        }
        if (s.indexOf(year) > -1 && s.toUpperCase().indexOf(monthNames[monthIdx].toUpperCase().substring(0,3)) > -1) {
           return true;
        }
      }
      
      // Fallback to Period Prefix
      if (idxPeriod > -1 && pPeriod) {
        return String(pPeriod).indexOf(monthStr) === 0;
      }
      return false;
    });

    if (monthRows.length === 0) throw new Error('No data found for ' + labelFull);

    // --- Settings & Masterfile Lookup ---
    var mfInfo = _getMasterfileNumberMap_();
    var mfMap = mfInfo.map;

    // --- Inputs ---
    var wantSSS = !!form.sss;
    var wantPH = !!form.philhealth;
    var wantPI = !!form.pagibig;
    var wantSSSLoans = !!form.sssLoans;
    var wantPILoans = !!form.pagibigLoans;

    if (!wantSSS && !wantPH && !wantPI && !wantSSSLoans && !wantPILoans) {
      throw new Error('Select at least one report type.');
    }

    // --- Aggregation ---
    function n(v) { return Number(v) || 0; }
    function absn(v) { return Math.abs(n(v)); }

    var perEmp = {};

    monthRows.forEach(function(r) {
      var id = String(r[idxEmpId] || '').trim();
      var name = String(r[idxEmpName] || '').trim();
      if (!id && !name) return;
      
      var k = id + '||' + name;
      if (!perEmp[k]) {
        perEmp[k] = { 
          id: id, name: name, 
          sssEe:0, sssEeMpf:0, sssEr:0, sssErMpf:0, sssEc:0,
          phEe:0, phEr:0,
          piEe:0, piEr:0,
          sssLoan:0, sssCalamity:0, piLoan:0, piCalamity:0
        };
      }
      var o = perEmp[k];
      if(idxSssEe > -1) o.sssEe += absn(r[idxSssEe]);
      if(idxSssEeMpf > -1) o.sssEeMpf += absn(r[idxSssEeMpf]);
      if(idxSssEr > -1) o.sssEr += n(r[idxSssEr]);
      if(idxSssErMpf > -1) o.sssErMpf += n(r[idxSssErMpf]);
      if(idxSssEc > -1) o.sssEc += n(r[idxSssEc]);
      
      if(idxPhEe > -1) o.phEe += absn(r[idxPhEe]);
      if(idxPhEr > -1) o.phEr += n(r[idxPhEr]);
      
      if(idxPiEe > -1) o.piEe += absn(r[idxPiEe]);
      if(idxPiEr > -1) o.piEr += n(r[idxPiEr]);
      
      if(idxSssLoan > -1) o.sssLoan += absn(r[idxSssLoan]);
      if(idxSssCalamity > -1) o.sssCalamity += absn(r[idxSssCalamity]);
      if(idxPiLoan > -1) o.piLoan += absn(r[idxPiLoan]);
      if(idxPiCalamity > -1) o.piCalamity += absn(r[idxPiCalamity]);
    });

    // --- Build Header & Rows ---
    var outHeader = ['Employee ID', 'Employee Name'];
    
    if (wantSSS) {
       if (mfInfo.hasSss) outHeader.push('SSS Number');
       outHeader.push('SSS EE MC', 'SSS EE MPF', 'SSS ER MC', 'SSS ER MPF', 'SSS EC', 'SSS Total');
       outHeader.push(''); // spacer
    }
    if (wantPH) {
       if (mfInfo.hasPh) outHeader.push('PhilHealth Number');
       outHeader.push('PH EE', 'PH ER', 'PH Total');
       outHeader.push(''); // spacer
    }
    if (wantPI) {
       if (mfInfo.hasPi) outHeader.push('Pag-IBIG Number');
       outHeader.push('PI EE', 'PI ER', 'PI Total');
       outHeader.push(''); // spacer
    }
    if (wantSSSLoans) outHeader.push('SSS Loan', 'SSS Calamity');
    if (wantPILoans) outHeader.push('Pag-IBIG Loan', 'Pag-IBIG Calamity');

    // --- Identify EE/ER/Total columns for Accounting format ---
    // Adjust this set as needed if you want to include/exclude columns.
    var accountingHeaderSet = {
      'SSS EE MC': true,
      'SSS EE MPF': true,
      'SSS ER MC': true,
      'SSS ER MPF': true,
      'SSS EC': true,
      'SSS Total': true,
      'PH EE': true,
      'PH ER': true,
      'PH Total': true,
      'PI EE': true,
      'PI ER': true,
      'PI Total': true,
      'SSS Loan': true,
      'SSS Calamity': true,
      'Pag-IBIG Loan': true,
      'Pag-IBIG Calamity': true
    };

    var accountingCols = []; // 1-based column indices
    for (var c = 0; c < outHeader.length; c++) {
      var hName = String(outHeader[c] || '');
      if (accountingHeaderSet[hName]) {
        accountingCols.push(c + 1);
      }
    }

    // Generate Body Rows
    var rows = [];
    rows.push(outHeader);

    // Sort Keys
    var keys = Object.keys(perEmp).sort();
    
    // Totals Object
    var grandTotal = new Array(outHeader.length).fill(0);
    grandTotal[0] = 'TOTAL';
    grandTotal[1] = '';

    keys.forEach(function(k) {
  var d = perEmp[k];

  // âœ… Skip employees with zero amounts across ALL selected stat/loan sections
  var anyAmt = 0;
  if (wantSSS)      anyAmt += (d.sssEe||0) + (d.sssEeMpf||0) + (d.sssEr||0) + (d.sssErMpf||0) + (d.sssEc||0);
  if (wantPH)       anyAmt += (d.phEe||0) + (d.phEr||0);
  if (wantPI)       anyAmt += (d.piEe||0) + (d.piEr||0);
  if (wantSSSLoans) anyAmt += (d.sssLoan||0) + (d.sssCalamity||0);
  if (wantPILoans)  anyAmt += (d.piLoan||0) + (d.piCalamity||0);
  if ((Number(anyAmt) || 0) === 0) return;

  var mf = mfMap[d.id] || {};
  var r = [d.id, d.name];

      var colIdx = 2;

      function addVal(val) {
        r.push(val);
        if (typeof val === 'number') grandTotal[colIdx] = (Number(grandTotal[colIdx]) || 0) + val;
        colIdx++;
      }
      function addStr(str) {
        r.push(str);
        grandTotal[colIdx] = ''; // No total for ID numbers / spacers
        colIdx++;
      }

      if (wantSSS) {
        if (mfInfo.hasSss) addStr(mf.sssNo || '');
        addVal(d.sssEe); 
        addVal(d.sssEeMpf); 
        addVal(d.sssEr); 
        addVal(d.sssErMpf); 
        addVal(d.sssEc);
        addVal(d.sssEe + d.sssEeMpf + d.sssEr + d.sssErMpf + d.sssEc); // Total
        addStr(''); // Spacer
      }
      if (wantPH) {
        if (mfInfo.hasPh) addStr(mf.phNo || '');
        addVal(d.phEe); 
        addVal(d.phEr);
        addVal(d.phEe + d.phEr); // Total
        addStr(''); // Spacer
      }
      if (wantPI) {
        if (mfInfo.hasPi) addStr(mf.piNo || '');
        addVal(d.piEe); 
        addVal(d.piEr);
        addVal(d.piEe + d.piEr); // Total
        addStr(''); // Spacer
      }
      if (wantSSSLoans) {
        addVal(d.sssLoan); 
        addVal(d.sssCalamity);
      }
      if (wantPILoans) {
        addVal(d.piLoan); 
        addVal(d.piCalamity);
      }
      rows.push(r);
    });

    // Add Totals Row
    rows.push(grandTotal);

    // Common accounting format (Accounting-style, 2 decimals)
    var accountingNumberFormat = '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)';

    // --- Export to Google Sheet ---
    var sheetName = '';
    if (form.exportToSheet) {
      sheetName = 'Statutory - ' + monthStr;
      var sh = ss.getSheetByName(sheetName);
      if (!sh) sh = ss.insertSheet(sheetName);
sh.clear();
sh.setHiddenGridlines(true); // âœ… hide gridlines
sh.getRange(1, 1, rows.length, rows[0].length).setValues(rows);


      // Header: bold, shaded, centered, wrapped
      var headerRange = sh.getRange(1, 1, 1, rows[0].length);
      headerRange
        .setFontWeight('bold')
        .setBackground('#efefef')
        .setHorizontalAlignment('center')
        .setWrap(true);

      // Total row bold
      sh.getRange(rows.length, 1, 1, rows[0].length).setFontWeight('bold');

      // Apply accounting format to EE/ER/Total columns (rows 2 to last)
      accountingCols.forEach(function(col) {
        sh.getRange(2, col, rows.length - 1, 1)
          .setNumberFormat(accountingNumberFormat)
          .setHorizontalAlignment('right');
      });

      sh.autoResizeColumns(1, rows[0].length);
    }

    // --- Export to Excel ---
    var download = null;
    if (form.downloadExcel) {
      download = _generateStatutoryExcel_(rows, 'Statutory_' + monthStr, accountingCols, accountingNumberFormat);
    }

    return {
      ok: true,
      message: 'Statutory report generated.',
      sheetName: sheetName,
      download: download
    };

  } catch (e) {
    return { ok: false, message: e.message };
  }
}


/**
 * Helper to generate Excel for statutory reports using the temp sheet + flush method
 */
function _generateStatutoryExcel_(rows, baseFilename, accountingCols, accountingNumberFormat) {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var temp = ss.insertSheet('TMP_STAT_' + Date.now());
  try {
    temp.setHiddenGridlines(true);
    temp.getRange(1, 1, rows.length, rows[0].length).setValues(rows);

    // Header formatting: bold, grey, centered, wrapped
    var headerRange = temp.getRange(1, 1, 1, rows[0].length);
    headerRange
      .setFontWeight('bold')
      .setBackground('#efefef')
      .setHorizontalAlignment('center')
      .setWrap(true);

    // Accounting format for EE/ER/Total columns, if provided
    if (accountingCols && accountingCols.length && accountingNumberFormat) {
      accountingCols.forEach(function(col) {
        temp.getRange(2, col, rows.length - 1, 1)
          .setNumberFormat(accountingNumberFormat)
          .setHorizontalAlignment('right');
      });
    }

    SpreadsheetApp.flush(); // Crucial flush

    var url = 'https://docs.google.com/spreadsheets/d/' + ss.getId() +
      '/export?format=xlsx&gid=' + temp.getSheetId() +
      '&size=letter&portrait=false&fitw=true&gridlines=false';

    var resp = UrlFetchApp.fetch(url, {
      headers: { Authorization: 'Bearer ' + ScriptApp.getOAuthToken() },
      muteHttpExceptions: true
    });

    if (resp.getResponseCode() !== 200) throw new Error('Excel generation failed.');

    return {
      fileName: baseFilename + '.xlsx',
      mimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      contentBase64: Utilities.base64Encode(resp.getContent())
    };
  } finally {
    ss.deleteSheet(temp);
  }
}

/** Simple HTML escaping for PDF table generation */
function _escapeHtml_(s) {
  return String(s)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function _getMasterfileNumberMap_() {
  // Use Settings Center config
  const cfg = _readSettings_();
  if (!cfg || !cfg.SOURCE_SS_ID) {
    throw new Error(
      'Masterfile is not linked. Please open Settings Center and set the Masterfile source file.'
    );
  }

  // Open the Masterfile spreadsheet via URL/ID saved in settings
  const sourceSS = SpreadsheetApp.openById(cfg.SOURCE_SS_ID);
  const mfName = cfg.MASTER_SHEET_NAME || 'Masterfile Import';

  // This helper already exists in your file
  const mfSheet = _mustGetSheet_(sourceSS, mfName);

  const values = mfSheet.getDataRange().getValues();
  if (values.length < 2) {
    return {
      map: {},
      hasSss: false,
      hasPh: false,
      hasPi: false,
    };
  }

  const header = values[0].map(h => String(h || '').trim());

  function idxOf(name) {
    const target = String(name || '').toUpperCase();
    for (let j = 0; j < header.length; j++) {
      if (String(header[j] || '').toUpperCase() === target) return j;
    }
    return -1;
  }

  // Employee ID column on Masterfile
  let idxEmpId = idxOf('EMPLOYEE ID');
  if (idxEmpId === -1) idxEmpId = idxOf('EMP ID');
  if (idxEmpId === -1) {
    throw new Error(
      `Masterfile "${mfName}" is missing an "Employee ID" column.`
    );
  }

  // Numbers on Masterfile (exactly as you said: SSS / PAG-IBIG / PHILHEALTH)
  const idxSss = idxOf('SSS');

  let idxPi = idxOf('PAG-IBIG');
  if (idxPi === -1) idxPi = idxOf('HDMF'); // fallback, just in case

  let idxPh = idxOf('PHILHEALTH');
  if (idxPh === -1) idxPh = idxOf('PHIL HEALTH'); // loose variant

  const map = {};
  for (let r = 1; r < values.length; r++) {
    const row = values[r];
    const empId = String(row[idxEmpId] || '').trim();
    if (!empId) continue;

    const sssNo = idxSss > -1 ? String(row[idxSss] || '').trim() : '';
    const piNo  = idxPi  > -1 ? String(row[idxPi]  || '').trim() : '';
    const phNo  = idxPh  > -1 ? String(row[idxPh]  || '').trim() : '';

    map[empId] = {
      sssNo,
      piNo,
      phNo,
    };
  }

  return {
    map,
    hasSss: idxSss > -1,
    hasPh: idxPh > -1,
    hasPi: idxPi > -1,
  };
}

/**
 * DEEP DEBUG for withholding tax.
 * - Rebuilds the bracket search (same as _computeWithholdingTaxEx_)
 * - Logs which BIR row is hit (or not) and why tax ends up as 0.
 * Output sheet: _DEBUG_WTAX_DEEP (hidden)
 */
function _debugWithholdingTaxDeep_(opts) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheetName = '_DEBUG_WTAX_DEEP';
    let sh = ss.getSheetByName(sheetName);

    if (!sh) {
      sh = ss.insertSheet(sheetName);
      sh.appendRow([
        'Timestamp',
        'Period',
        'Part',
        'Employee ID',
        'Pay Frequency',
        'Mode',
        'isSemi',
        'Taxable (t)',
        'Matched row # (BIR_TABLE data row)',
        'exSemi',
        'maxSemi',
        'fixedSemi',
        'rateSemi',
        'exMonth',
        'maxMonth',
        'fixedMonth',
        'rateMonth',
        'Final Tax',
        'Reason'
      ]);
      sh.hideSheet();
    }

    const birTable = opts.birTable || [];
    const t = Number(opts.taxableIncome) || 0;
    const isSemi = !!opts.isSemi;

    let matchedIndex = -1;
    let matchedRow = null;

    for (let i = 0; i < birTable.length; i++) {
      const r = birTable[i];
      const ex = isSemi ? r.exSemi : r.exMonth;
      const mx = isSemi ? r.maxSemi : r.maxMonth;
      if (t > ex && t <= mx) {
        matchedIndex = i + 2; // +2: BIR_TABLE data starts on row 2
        matchedRow = r;
        break;
      }
    }

    let reason = '';
    if (!matchedRow) {
      reason = 'NO_BRACKET_FOUND';
    } else if (isSemi && matchedRow.rateSemi === 0 && matchedRow.fixedSemi === 0) {
      reason = 'SEMI_RATE_ZERO';
    } else if (!isSemi && matchedRow.rateMonth === 0 && matchedRow.fixedMonth === 0) {
      reason = 'MONTH_RATE_ZERO';
    } else if (Number(opts.finalTax) === 0) {
      reason = 'FINAL_TAX_IS_ZERO';
    } else {
      reason = 'OK';
    }

    sh.appendRow([
      new Date(),
      opts.periodLabel || '',
      opts.partLabel || '',
      opts.empId || '',
      opts.payFrequency || '',
      opts.mode || '',
      isSemi ? 'TRUE' : 'FALSE',
      t,
      matchedIndex,
      matchedRow ? matchedRow.exSemi : '',
      matchedRow ? matchedRow.maxSemi : '',
      matchedRow ? matchedRow.fixedSemi : '',
      matchedRow ? matchedRow.rateSemi : '',
      matchedRow ? matchedRow.exMonth : '',
      matchedRow ? matchedRow.maxMonth : '',
      matchedRow ? matchedRow.fixedMonth : '',
      matchedRow ? matchedRow.rateMonth : '',
      opts.finalTax != null ? opts.finalTax : '',
      reason
    ]);

    if (!sh.isSheetHidden()) sh.hideSheet();
  } catch (err) {
    Logger.log('DEBUG_WTAX_DEEP error: ' + err);
  }
}

/**
 * DEBUG: Dump BIR_TABLE as seen by Apps Script.
 * Run this manually from the Script Editor.
 */
function debug_BIR_TABLE() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const birSheet = ss.getSheetByName('BIR_TABLE');
  if (!birSheet) {
    throw new Error('No sheet named "BIR_TABLE" found.');
  }

  const bir = _loadBirTable_(birSheet);

  let dbg = ss.getSheetByName('_DEBUG_BIR');
  if (!dbg) {
    dbg = ss.insertSheet('_DEBUG_BIR');
  }
  dbg.clear();

  dbg.appendRow([
    'Data Row# (in BIR_TABLE)',
    'exSemi',
    'maxSemi',
    'fixedSemi',
    'rateSemi',
    'exMonth',
    'maxMonth',
    'fixedMonth',
    'rateMonth'
  ]);

  bir.forEach((r, i) => {
    dbg.appendRow([
      i + 2,         // data starts row 2
      r.exSemi,
      r.maxSemi,
      r.fixedSemi,
      r.rateSemi,
      r.exMonth,
      r.maxMonth,
      r.fixedMonth,
      r.rateMonth
    ]);
  });

  dbg.activate();
}

function _debugTaxableIncomeBreakdown_(opts) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheetName = '_DEBUG_TAXABLE';
    let sh = ss.getSheetByName(sheetName);

    if (!sh) {
      sh = ss.insertSheet(sheetName);
      sh.appendRow([
        'Timestamp',
        'Period',
        'Part',
        'Employee ID',
        'Pay Frequency',
        'Mode',
        'Basic-related (this run)',
        'Taxable-only (this run)',
        'Other benefits this run',
        'YTD other benefits BEFORE',
        'Taxable other benefits this run',
        'Taxable earnings BEFORE EE contribs',
        'SSS EE (actual)',
        'PhilHealth EE (actual)',
        'Pag-IBIG EE (actual)',
        'Taxable Income (final)'
      ]);
      sh.hideSheet();
    }

    sh.appendRow([
      new Date(),
      opts.periodLabel || '',
      opts.partLabel || '',
      opts.empId || '',
      opts.payFrequency || '',
      opts.mode || '',
      Number(opts.sumBasicRelated) || 0,
      Number(opts.sumTaxableOnly) || 0,
      Number(opts.otherBenefitsThisRun) || 0,
      Number(opts.ytdOtherBefore) || 0,
      Number(opts.taxableOtherBenefits) || 0,
      Number(opts.taxableEarningsBeforeContrib) || 0,
      Number(opts.sssEeActual) || 0,
      Number(opts.phEeActual) || 0,
      Number(opts.piEeActual) || 0,
      Number(opts.taxableIncomeForPeriod) || 0
    ]);

    if (!sh.isSheetHidden()) sh.hideSheet();
  } catch (e) {
    Logger.log('DEBUG_TAXABLE error: ' + e);
  }
}

/**
 * YTD Taxable Income by Employee ID for a given calendar year.
 * Looks at "Taxable Income" or "Taxable Income (final)" column in PAYROLL_HISTORY.
 */
function _loadYtdTaxableIncomeMap_(histSheet, year) {
  const map = new Map();
  if (!histSheet || histSheet.getLastRow() < 2) return map;

  const data = histSheet.getDataRange().getValues();
  const headers = data[0].map(h => String(h || '').trim());
  const rows = data.slice(1);

  const idxEmp   = headers.findIndex(h => /^Employee ID$/i.test(h));
  const idxPer   = headers.findIndex(h => /^Period$/i.test(h));
  const idxMonth = headers.findIndex(h => /^Payroll Month$/i.test(h));
  const idxTax   = headers.findIndex(h => /^Taxable Income(\s*\(final\))?$/i.test(h));

  if (idxEmp === -1 || idxTax === -1) return map;

  rows.forEach(r => {
    const empId = String(r[idxEmp] || '').trim();
    if (!empId) return;

    let rowYear = null;

    // Prefer "Payroll Month" if present (e.g., "Nov 2025")
    if (idxMonth > -1 && r[idxMonth]) {
      const s = String(r[idxMonth]);
      const m = s.match(/(\d{4})/);
      if (m) rowYear = Number(m[1]);
    }

    // Fallback to "Period" if needed (e.g., "2025-11-01 to 2025-11-15")
    if (rowYear == null && idxPer > -1 && r[idxPer]) {
      const s = String(r[idxPer]);
      const m = s.match(/^(\d{4})-/);
      if (m) rowYear = Number(m[1]);
    }

    if (rowYear !== year) return;

    const v = Number(r[idxTax]) || 0;
    if (!v) return;

    map.set(empId, (map.get(empId) || 0) + v);
  });

  return map;
}

/**
 * Return the annual marginal rate from BIR_TABLE annual columns
 * given an annual projected taxable income.
 */
function _lookupAnnualRateFor13th_(annualTaxable, birTable) {
  const t = Number(annualTaxable) || 0;
  if (!t || !birTable || !birTable.length) return 0;

  for (let i = 0; i < birTable.length; i++) {
    const row = birTable[i];
    const ex  = Number(row.exAnnual || 0);
    const max = (row.maxAnnual == null ? Infinity : Number(row.maxAnnual || 0));
    if (t > ex && t <= max) {
      const rate = Number(row.rateAnnual || 0);
      return isFinite(rate) ? rate : 0;
    }
  }
  return 0;
}

/**
 * Estimate projected ANNUAL regular taxable income (EXCLUDING 13th/other benefits).
 *
 * Convention:
 *  - `remainingCutoffs` is the number of cutoffs INCLUDING the current one.
 *  - Projected annual regular = YTD regular BEFORE this run
 *                               + regularThisRun * remainingCutoffsInclusive
 *
 * Used by 13th-month annualization to get the marginal rate.
 */
function _estimateAnnualProjectedTaxable_(
  empId,
  taxableRegularThisRun,
  payFrequency,
  ytdTaxableIncomeMap,
  debugInfo // optional: { empName, periodLabel, taxable13thThisRun }
) {
  const freq = String(payFrequency || '').toLowerCase();

  // How many cutoffs per year by frequency
  let cutoffsPerYear;
  if (freq.indexOf('semi') !== -1) {
    cutoffsPerYear = 24;
  } else if (freq.indexOf('month') !== -1) {
    cutoffsPerYear = 12;
  } else if (freq.indexOf('biweek') !== -1 || freq.indexOf('bi-week') !== -1) {
    cutoffsPerYear = 26;
  } else if (freq.indexOf('week') !== -1) {
    cutoffsPerYear = 52;
  } else {
    // default: semi-monthly
    cutoffsPerYear = 24;
  }

  const ytdRegularBeforeRun = Number(
    ytdTaxableIncomeMap && ytdTaxableIncomeMap.get(empId)
  ) || 0;

  const perCutoff = Number(taxableRegularThisRun) || 0;

  // Default assumption if we can't infer position in year:
  // treat this as the first relevant cutoff in projection.
  let remainingInclusive = cutoffsPerYear;

  if (perCutoff > 0 && ytdRegularBeforeRun > 0) {
    // Approximate how many cutoffs have been completed BEFORE this one.
    // We floor to be conservative (donâ€™t overproject).
    let completedBefore = Math.floor(ytdRegularBeforeRun / perCutoff + 1e-9);

    if (completedBefore < 0) completedBefore = 0;
    if (completedBefore > cutoffsPerYear - 1) {
      completedBefore = cutoffsPerYear - 1;
    }

    // âœ… "Remaining cutoffs" now means: this cutoff + all future cutoffs
    remainingInclusive = cutoffsPerYear - completedBefore;
  }

  // ðŸ”‘ Final projected annual REGULAR taxable:
  //   YTD (before this run) + (current-per-cutoff * remainingInclusive)
  const annualProjectedRegular =
    ytdRegularBeforeRun + perCutoff * remainingInclusive;

  // Optional: deep debug hook into _DEBUG_WTAX_ANNUAL
  if (debugInfo && typeof _debugAnnualProjection_ === 'function') {
    try {
      _debugAnnualProjection_({
        empId: empId || '',
        empName: debugInfo.empName || '',
        frequency: payFrequency || '',
        periodLabel: debugInfo.periodLabel || '',
        taxableRegularYtdBeforeRun: ytdRegularBeforeRun,
        taxableRegularThisRun: perCutoff,
        taxable13thThisRun: debugInfo.taxable13thThisRun || 0,
        remainingCutoffs: remainingInclusive,
        annualProjectedRegular: annualProjectedRegular,
        annualProjectedTotal:
          annualProjectedRegular + (debugInfo.taxable13thThisRun || 0)
      });
    } catch (e) {
      Logger.log('DEBUG annual projection error: ' + e);
    }
  }

  return annualProjectedRegular;
}

/**
 * MWE map for BIR1601C.
 * Uses Settings Center:
 *   - SOURCE_SS_ID  â†’ linked Masterfile spreadsheet
 *   - MASTER_SHEET_NAME â†’ sheet inside that file
 *
 * Returns Map<EmpID, true> where MWE column is Y / Yes / TRUE / 1 (any case).
 */
function _getMweFlagMap_() {
  var map = new Map();

  try {
    var cfg = (typeof _readSettings_ === 'function') ? _readSettings_() : null;
    if (!cfg || !cfg.SOURCE_SS_ID) {
      Logger.log('BIR1601C: SOURCE_SS_ID not configured in Settings Center.');
      return map;
    }

    var masterSheetName = cfg.MASTER_SHEET_NAME
      ? String(cfg.MASTER_SHEET_NAME).trim()
      : 'Masterfile Import';

    var sourceSS = SpreadsheetApp.openById(cfg.SOURCE_SS_ID);
    var sh = sourceSS.getSheetByName(masterSheetName);
    if (!sh) {
      Logger.log('BIR1601C: Masterfile sheet not found in source spreadsheet: ' + masterSheetName);
      return map;
    }

    var values = sh.getDataRange().getValues();
    if (!values.length) return map;

    var headers = values[0].map(function (h) { return String(h || '').trim(); });

    var idxEmpId = _idxHeader_(headers, 'Employee ID');
    var idxMwe   = _idxHeader_(headers, 'MWE'); // case-insensitive

    if (idxEmpId < 0 || idxMwe < 0) {
      Logger.log('BIR1601C: Masterfile missing Employee ID and/or MWE columns.');
      return map;
    }

    for (var r = 1; r < values.length; r++) {
      var row   = values[r];
      var empId = String(row[idxEmpId] || '').trim();
      if (!empId) continue;

      var flag  = String(row[idxMwe] || '').trim().toUpperCase();
      var isMwe = (flag === 'Y' || flag === 'YES' || flag === 'TRUE' || flag === '1');
      if (isMwe) {
        map.set(empId, true);
      }
    }
  } catch (e) {
    Logger.log('BIR1601C: Error building MWE flag map: ' + e);
  }

  return map;
}

/**
 * CONTRACT TYPE map for BIR1601C.
 * Uses Settings Center:
 *   - SOURCE_SS_ID        â†’ linked Masterfile spreadsheet
 *   - MASTER_SHEET_NAME   â†’ sheet inside that file
 *
 * Returns Map<EmpID, contractTypeString>.
 */
function _getContractTypeMapFor1601C_() {
  var map = new Map();

  try {
    var cfg = (typeof _readSettings_ === 'function') ? _readSettings_() : null;
    if (!cfg || !cfg.SOURCE_SS_ID) {
      Logger.log('BIR1601C: SOURCE_SS_ID not configured in Settings Center (contract type map).');
      return map;
    }

    var masterSheetName = cfg.MASTER_SHEET_NAME
      ? String(cfg.MASTER_SHEET_NAME).trim()
      : 'Masterfile Import';

    var sourceSS = SpreadsheetApp.openById(cfg.SOURCE_SS_ID);
    var sh = sourceSS.getSheetByName(masterSheetName);
    if (!sh) {
      Logger.log('BIR1601C: Masterfile sheet not found in source spreadsheet: ' + masterSheetName);
      return map;
    }

    var values = sh.getDataRange().getValues();
    if (!values.length) return map;

    var headers = values[0].map(function (h) { return String(h || '').trim(); });

    var idxEmpId = _idxHeader_(headers, 'Employee ID');
    var idxCt    = _idxHeader_(headers, 'CONTRACT TYPE');
    if (idxCt < 0) idxCt = _idxHeader_(headers, 'Contract Type'); // fallback

    if (idxEmpId < 0 || idxCt < 0) {
      Logger.log('BIR1601C: Masterfile missing Employee ID and/or CONTRACT TYPE columns.');
      return map;
    }

    for (var i = 1; i < values.length; i++) {
      var r = values[i];
      var empId = String(r[idxEmpId] || '').trim();
      if (!empId) continue;

      var ct = String(r[idxCt] || '').trim(); // keep raw; normalize later at use site
      map.set(empId, ct);
    }

  } catch (e) {
    Logger.log('BIR1601C: _getContractTypeMapFor1601C_ error: ' + e.message + '\n' + e.stack);
  }

  return map;
}


/**
 * Case-insensitive header index helper.
 * headers: array of header strings
 * name: header to look for (e.g. "Employee ID")
 */
function _idxHeader_(headers, name) {
  if (!headers || !headers.length) return -1;
  var target = String(name || '').toUpperCase();
  for (var i = 0; i < headers.length; i++) {
    if (String(headers[i] || '').toUpperCase() === target) return i;
  }
  return -1;
}

function showPostHistoryDialog() {
  const html = HtmlService.createTemplateFromFile('PostHistoryDialog')
  .evaluate()
    .setWidth(1040)
    .setHeight(480);
  SpreadsheetApp.getUi().showModalDialog(html, ' ');
}

function showPostHistorySummary(result) {
  result = result || {};
  const ui = SpreadsheetApp.getUi();

  const postedSheets      = result.postedSheets      || 0;
  const totalPostedRows   = result.totalPostedRows   || 0;
  const unpostedSheets    = result.unpostedSheets    || 0;
  const totalUnpostedRows = result.totalUnpostedRows || 0;

  let msg = 'Post / Unpost Payroll History\n\n';

  

  msg +=
    'Posted sheets:   ' + postedSheets   + ' (' + totalPostedRows   + ' rows)\n' +
    'Unposted sheets: ' + unpostedSheets + ' (' + totalUnpostedRows + ' rows)';

  if (result.skippedUnpost && result.skippedUnpost.length) {
    msg += '\n\nSkipped (no safe log found):\n - ' +
      result.skippedUnpost.join('\n - ');
  }

  ui.alert(msg);
}


function _getPostLogSheet_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const name = '_PAYROLL_POST_LOG';
  let sh = ss.getSheetByName(name);

  if (!sh) {
    sh = ss.insertSheet(name);
    sh.appendRow([
      'Sheet ID',           // 0
      'Sheet Name at Post', // 1
      'Posted Sheet Name',  // 2
      'History First Row',  // 3
      'History Last Row',   // 4
      'Row Count',          // 5
      'Posted At',          // 6
      'Unposted At'         // 7
    ]);
    sh.hideSheet();
  }

  return sh;
}

// ============================================================
// PAYSLIP INPUT SNAPSHOT (OT / Attendance / Variable Adj)
// - Stored in THIS payroll computation file upon POSTING
// - So payslip generation later is reproducible even if Inputs file changes
// ============================================================
const PAYSLIP_INPUT_SNAPSHOT_SHEET = '_PAYSLIP_INPUT_SNAPSHOT';
const PAYSLIP_INPUT_SNAPSHOT_INDEX_SHEET = '_PAYSLIP_INPUT_SNAPSHOT_INDEX';

function _ensurePayslipInputSnapshotSheets_(ss) {
  ss = ss || SpreadsheetApp.getActiveSpreadsheet();

  const DATA_HEADERS = [
    'Posted Sheet Name',
    'Posted Sheet ID',
    'Posted At',
    'PeriodKey',
    'Part',
    'Source Sheet',
    'Employee ID',
    'Employee Name',
    'Type',
    'Value',
    'Rate',
    'Hours',
    'Days',
    'Amount',
    'Description',
    'Payroll Category',
    'Adjustment Name'
  ];

  const INDEX_HEADERS = [
    'Posted Sheet Name',
    'Posted Sheet ID',
    'Posted At',
    'PeriodKey',
    'Part',
    'Rows Snapshotted'
  ];

  const sameHeaders_ = (have, want) => {
    if (!have || have.length < want.length) return false;
    for (let i = 0; i < want.length; i++) {
      if (String(have[i] || '').trim() !== String(want[i] || '').trim()) return false;
    }
    return true;
  };

  // --- Data sheet ---
  let sh = ss.getSheetByName(PAYSLIP_INPUT_SNAPSHOT_SHEET);
  if (!sh) sh = ss.insertSheet(PAYSLIP_INPUT_SNAPSHOT_SHEET);

  {
    const lc = Math.max(1, sh.getLastColumn() || 0, DATA_HEADERS.length);
    const have = sh.getRange(1, 1, 1, lc).getValues()[0];
    if (!sameHeaders_(have, DATA_HEADERS)) {
      sh.getRange(1, 1, 1, lc).clearContent();
      sh.getRange(1, 1, 1, DATA_HEADERS.length).setValues([DATA_HEADERS]);
    }
    try { sh.hideSheet(); } catch (e) {}
  }

  // --- Index sheet ---
  let ix = ss.getSheetByName(PAYSLIP_INPUT_SNAPSHOT_INDEX_SHEET);
  if (!ix) ix = ss.insertSheet(PAYSLIP_INPUT_SNAPSHOT_INDEX_SHEET);

  {
    const lc = Math.max(1, ix.getLastColumn() || 0, INDEX_HEADERS.length);
    const have = ix.getRange(1, 1, 1, lc).getValues()[0];
    if (!sameHeaders_(have, INDEX_HEADERS)) {
      ix.getRange(1, 1, 1, lc).clearContent();
      ix.getRange(1, 1, 1, INDEX_HEADERS.length).setValues([INDEX_HEADERS]);
    }
    try { ix.hideSheet(); } catch (e) {}
  }

  return { data: sh, index: ix };
}


function _inferPeriodKeyAndPartForSnapshot_(sheetName, srcHeaders, srcRows) {
  const norm = s => String(s || '').toLowerCase().replace(/\s+/g, '').trim();

  const H = (srcHeaders || []).map(h => String(h || '').trim());
  const Hn = H.map(norm);

  const idxByAliases = (aliases) => {
    const wants = (Array.isArray(aliases) ? aliases : [aliases]).map(norm);
    for (let i = 0; i < Hn.length; i++) if (wants.includes(Hn[i])) return i;
    // contains fallback
    for (let i = 0; i < Hn.length; i++) {
      for (const w of wants) if (Hn[i].indexOf(w) !== -1) return i;
    }
    return -1;
  };

  let periodKey = '';
  let part = '';

  const iPeriod =
    idxByAliases(['PeriodKey', 'Period Key', 'Payroll Month', 'Month', 'Period']);

  const iPart =
    idxByAliases(['Part', 'Payroll Part', 'Semi Part']);

  if (srcRows && srcRows.length) {
    const first = srcRows[0];

    if (iPeriod !== -1) {
      const v = first[iPeriod];
      periodKey = String(v || '').trim();
    }

    if (iPart !== -1) {
      const v = first[iPart];
      part = String(v || '').trim();
    }
  }

  // Fallbacks from sheet name
  if (!periodKey) {
    const m = String(sheetName || '').match(/(\d{4}-\d{2})/);
    if (m) periodKey = m[1];
  }
  if (!part) {
    const u = String(sheetName || '').toUpperCase();
    const m2 = u.match(/\b(A|B|M)\b/);
    if (m2) part = m2[1];
  }

  return { periodKey, part };
}

function _snapshotPayslipInputsUponPosting_(ss, postedName, postedSheetId, originalSheetName, srcHeaders, srcRows, cfg) {
  ss = ss || SpreadsheetApp.getActiveSpreadsheet();
  cfg = cfg || {};

  if (!cfg.INPUTS_SS_ID) {
    Logger.log('âš ï¸ Snapshot skipped: cfg.INPUTS_SS_ID is not set.');
    return { rows: 0 };
  }

  const sheets = _ensurePayslipInputSnapshotSheets_(ss);
  const snapSh = sheets.data;
  const idxSh  = sheets.index;

  const postedAt = new Date();
  const meta = _inferPeriodKeyAndPartForSnapshot_(originalSheetName, srcHeaders, srcRows);
  const periodKey = meta.periodKey || '';
  const part = meta.part || '';

  // Build employee set from posted payroll rows
  const H = (srcHeaders || []).map(h => String(h || '').trim());
  const empIdIdx = H.findIndex(h => /^Employee ID$/i.test(h));
  const empNmIdx = H.findIndex(h => /^Employee Name$/i.test(h));

  const normId = s => String(s ?? '')
    .toLowerCase()
    .replace(/\s+/g, '')
    .replace(/\u200B/g, '')
    .replace(/[-â€“â€”]/g, '-')
    .trim();

  const empSet = new Set();
  const empNameById = Object.create(null);

  (srcRows || []).forEach(r => {
    const rawId = empIdIdx === -1 ? '' : String(r[empIdIdx] || '').trim();
    const id = normId(rawId);
    if (!id) return;
    empSet.add(id);

    const nm = empNmIdx === -1 ? '' : String(r[empNmIdx] || '').trim();
    if (nm) empNameById[id] = nm;
  });

  if (!empSet.size) {
    Logger.log('âš ï¸ Snapshot skipped: no employees detected in posted rows.');
    return { rows: 0 };
  }

  // Helper parsers (robust header mapping similar to PayslipGenerator)
  const num = v => Number(String(v ?? '').replace(/[â‚±,()]/g, '').trim()) || 0;
  const normHeader = s => String(s ?? '')
    .toLowerCase()
    .replace(/\s+/g, '')
    .replace(/[^a-z0-9]/g, '');

  const aliasIdx = (headers, aliases) => {
    const HN = headers.map(normHeader);
    const want = (Array.isArray(aliases) ? aliases : [aliases]).map(normHeader);
    for (const w of want) {
      const i = HN.indexOf(w);
      if (i !== -1) return i;
    }
    return -1;
  };

  // Read Inputs file now (THIS is the â€œsnapshot momentâ€)
  const adjSS = SpreadsheetApp.openById(cfg.INPUTS_SS_ID);
  const srcSheets = ['Variable_Adjustments', 'Overtime', 'Absences_Tardiness'];

  const out = [];

  srcSheets.forEach(srcName => {
    const sh = adjSS.getSheetByName(srcName);
    if (!sh) return;

    const raw = sh.getDataRange().getValues();
    if (raw.length < 2) return;

    const headers = raw[0].map(h => String(h || '').trim());
    const IDX = {
      ID: aliasIdx(headers, ['employee id','emp id','employeeid','employee code','empcode','id']),
      NAME: aliasIdx(headers, ['employee name','name']),
      TYPE: aliasIdx(headers, ['type','ot type','adj type','category type']),
      VALUE: aliasIdx(headers, ['value','units','qty','no. of days','days','hours','hours/units','unit']),
      RATE: aliasIdx(headers, ['rate','hourly rate','daily rate','amount per unit','amount/day','amount/hour']),
      AMOUNT: aliasIdx(headers, ['amount','ot amount','value amount','amt','total','computed amount','net amount']),
      DESC: aliasIdx(headers, ['description','adjustment name','remarks','particulars','component','item']),
      CAT: aliasIdx(headers, ['payroll category','category','payrollcomponent','component group'])
    };

    raw.slice(1).forEach(r => {
      const idRaw = IDX.ID === -1 ? '' : r[IDX.ID];
      const empId = normId(idRaw);
      if (!empId) return;
      if (!empSet.has(empId)) return; // ONLY snapshot employees included in the posted run

      const typeText = IDX.TYPE === -1 ? '' : String(r[IDX.TYPE] || '').trim();

      const val = IDX.VALUE === -1 ? 0 : num(r[IDX.VALUE]);
      const rate = IDX.RATE === -1 ? 0 : num(r[IDX.RATE]);
      const amt = IDX.AMOUNT === -1 ? 0 : num(r[IDX.AMOUNT]);

      const desc = IDX.DESC === -1
        ? (typeText || srcName)
        : String(r[IDX.DESC] || typeText || '').trim();

      const cat = IDX.CAT === -1 ? '' : String(r[IDX.CAT] || '').trim();
      const empName = (IDX.NAME !== -1 ? String(r[IDX.NAME] || '').trim() : '') || empNameById[empId] || '';

      // Use same field schema PayslipGenerator expects
      out.push([
        postedName,
        postedSheetId,
        postedAt,
        periodKey,
        part,
        srcName,
        empId,
        empName,
        typeText,        // Type
        val,             // Value
        rate,            // Rate
        val,             // Hours (same column in your loader)
        val,             // Days  (same column in your loader)
        amt,             // Amount
        desc,            // Description
        cat,             // Payroll Category
        (IDX.DESC === -1 ? '' : String(r[IDX.DESC] || '').trim()) // Adjustment Name
      ]);
    });
  });

  // Remove any old snapshot rows for this posted sheet (prevents double counting if re-posted)
  try {
    const vr = snapSh.getDataRange().getValues();
    if (vr.length > 1) {
      const keep = [vr[0]];
      for (let i = 1; i < vr.length; i++) {
        const rowPosted = String(vr[i][0] || '').trim();
        if (rowPosted.toUpperCase() !== String(postedName).trim().toUpperCase()) keep.push(vr[i]);
      }
      if (keep.length !== vr.length) {
        snapSh.clear();
        snapSh.getRange(1, 1, keep.length, keep[0].length).setValues(keep);
      }
    }
  } catch (e) {
    Logger.log('âš ï¸ Snapshot dedupe failed (non-blocking): ' + e.message);
  }

  if (out.length) {
    snapSh.getRange(snapSh.getLastRow() + 1, 1, out.length, out[0].length).setValues(out);
  }

  // Index record
  try {
    idxSh.appendRow([postedName, postedSheetId, postedAt, periodKey, part, out.length]);
  } catch (e) {
    Logger.log('âš ï¸ Snapshot index write failed (non-blocking): ' + e.message);
  }

  Logger.log(`âœ… Payslip input snapshot saved for "${postedName}" rows=${out.length}`);
  return { rows: out.length };
}

function _deletePayslipInputSnapshotForPostedSheet_(ss, postedSheetName) {
  ss = ss || SpreadsheetApp.getActiveSpreadsheet();
  postedSheetName = String(postedSheetName || '').trim();
  if (!postedSheetName) return { deleted: 0 };

  const snapSh = ss.getSheetByName(PAYSLIP_INPUT_SNAPSHOT_SHEET);
  const idxSh  = ss.getSheetByName(PAYSLIP_INPUT_SNAPSHOT_INDEX_SHEET);

  const want = postedSheetName.toUpperCase();
  let deleted = 0;

  // --- delete from snapshot data sheet
  if (snapSh) {
    const v = snapSh.getDataRange().getValues();
    if (v.length > 1) {
      const header = v[0];
      const keep = [header];

      for (let r = 1; r < v.length; r++) {
        const rowPosted = String(v[r][0] || '').trim().toUpperCase(); // col A = Posted Sheet Name
        if (rowPosted === want) {
          deleted++;
        } else {
          keep.push(v[r]);
        }
      }

      if (keep.length !== v.length) {
        snapSh.clear();
        snapSh.getRange(1, 1, keep.length, header.length).setValues(keep);
      }
    }
  }

  // --- delete from snapshot index sheet
  if (idxSh) {
    const v2 = idxSh.getDataRange().getValues();
    if (v2.length > 1) {
      const header2 = v2[0];
      const keep2 = [header2];

      for (let r = 1; r < v2.length; r++) {
        const rowPosted = String(v2[r][0] || '').trim().toUpperCase(); // col A = Posted Sheet Name
        if (rowPosted !== want) keep2.push(v2[r]);
      }

      if (keep2.length !== v2.length) {
        idxSh.clear();
        idxSh.getRange(1, 1, keep2.length, header2.length).setValues(keep2);
      }
    }
  }

  Logger.log(`ðŸ§¹ Deleted payslip input snapshot for "${postedSheetName}" rows=${deleted}`);
  return { deleted };
}

function _postPayrollSheetToHistoryCore_(sheet, opts) {
  opts = opts || {};
  const refreshYtd = opts.refresh !== false; // default true
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = SpreadsheetApp.getUi();

  if (!sheet) {
    ui.alert('âš ï¸ No active sheet to post.');
    return { rows: 0 };
  }

  const sheetName = sheet.getName().trim();

  // âœ… Block if already posted
  if (sheetName.toUpperCase().endsWith('(POSTED)')) {
    ui.alert(`âš ï¸ "${sheetName}" has already been posted.`);
    return { rows: 0 };
  }

  // âœ… Validate headers
  const headerVals = sheet
    .getRange(1, 1, 1, sheet.getLastColumn())
    .getValues()[0]
    .map(h => String(h || '').trim());

  const hasEmpId = headerVals.some(h => /^Employee ID$/i.test(h));
  const hasEmpNm = headerVals.some(h => /^Employee Name$/i.test(h));
  if (!hasEmpId || !hasEmpNm) {
    ui.alert(
      `âš ï¸ "${sheetName}" does not look like a payroll computation output (missing Employee ID/Name headers).`
    );
    return { rows: 0 };
  }

  // âœ… Ensure all columns visible before posting
  sheet.showColumns(1, sheet.getMaxColumns());

  // âœ… History sheet (create if missing)
  const histSheet = _ensureHistorySheet_();
  const logSheet = _getPostLogSheet_();

  // âœ… Source rows (exclude totals/blank employees)
  const src = sheet.getDataRange().getValues();
  if (src.length < 2) {
    ui.alert(`âš ï¸ No payroll data found to post from "${sheetName}".`);
    return { rows: 0 };
  }

  const srcHeaders = src[0].map(h => String(h || '').trim());
  const srcRowsRaw = src.slice(1);

  const empIdIdx = srcHeaders.findIndex(h => /^Employee ID$/i.test(h));
  const empNmIdx = srcHeaders.findIndex(h => /^Employee Name$/i.test(h));

  const srcRows = srcRowsRaw.filter(r => {
    const empId = String(r[empIdIdx] || '').trim();
    const empNm = String(r[empNmIdx] || '').trim();
    return empId && empNm;
  });

  if (srcRows.length === 0) {
    ui.alert(`âš ï¸ No valid employee rows found to post from "${sheetName}".`);
    return { rows: 0 };
  }

  // ============================
  // ðŸ”§ Header alignment (case-insensitive)
  // ============================
  const histValues = histSheet.getDataRange().getValues();
  const histHasHeader = histValues.length > 0 && histValues[0].some(v => v !== '');
  const histHeaders = histHasHeader ? histValues[0].map(h => String(h || '').trim()) : [];

  const _norm = s => String(s || '').trim().toUpperCase();
  const _hasCI = (arr, v) => arr.some(x => _norm(x) === _norm(v));

  // Build target header: srcHeaders first, then history-only columns
  const extras = histHeaders.filter(h => !_hasCI(srcHeaders, h));
  const targetHeaders = [...srcHeaders, ...extras];

  // Remap row using CI header map
  const remapRow = (row, fromHeaders, toHeaders) => {
    const mapCI = new Map(fromHeaders.map((h, i) => [_norm(h), i]));
    return toHeaders.map(h => {
      const i = mapCI.get(_norm(h));
      return i !== undefined ? row[i] : '';
    });
  };

  // âœ… Rewrite PAYROLL_HISTORY to targetHeaders (preserve existing data)
  if (!histHasHeader || histHeaders.join('|') !== targetHeaders.join('|')) {
    let existingRows = [];
    if (histHasHeader && histValues.length > 1) {
      const oldRows = histValues.slice(1);
      existingRows = oldRows.map(r => remapRow(r, histHeaders, targetHeaders));
    }

    histSheet.clear();
    histSheet
      .getRange(1, 1, 1, targetHeaders.length)
      .setValues([targetHeaders])
      .setFontWeight('bold');

    if (existingRows.length) {
      histSheet
        .getRange(2, 1, existingRows.length, targetHeaders.length)
        .setValues(existingRows);
    }
  }

  // âœ… Append new rows realigned to targetHeaders
  const newRows = srcRows.map(r => remapRow(r, srcHeaders, targetHeaders));
  const insertStart = histSheet.getLastRow() + 1;
  histSheet
    .getRange(insertStart, 1, newRows.length, targetHeaders.length)
    .setValues(newRows);
  const insertEnd = insertStart + newRows.length - 1;

  // âœ… Rename sheet after successful posting
  const postedName = `${sheetName} (Posted)`;
  sheet.setName(postedName);



  // âœ… Log which rows belong to this sheet (for unposting)
  try {
    logSheet.appendRow([
      sheet.getSheetId(),
      sheetName,
      postedName,
      insertStart,
      insertEnd,
      newRows.length,
      new Date(),
      '' // Unposted At
    ]);
  } catch (err) {
    Logger.log('âš ï¸ Failed to write to _PAYROLL_POST_LOG: ' + err.message);
  }

  // âœ… SNAPSHOT Inputs (Variable_Adjustments / Overtime / Absences_Tardiness)
  // This guarantees payslips remain reproducible even if Inputs file changes later.
  try {
    const cfg = _readSettings_();
    _snapshotPayslipInputsUponPosting_(
      ss,
      postedName,
      sheet.getSheetId(),
      sheetName,      // original name (pre-posted)
      srcHeaders,
      srcRows,
      cfg
    );
  } catch (e) {
    Logger.log('âš ï¸ Payslip input snapshot failed (non-blocking): ' + e.message);
  }


  // âœ… Re-hide empty columns in computation sheet (visual cleanup)
  try {
    const range = sheet.getDataRange();
    const values = range.getValues();
    const headerRow = values[0];
    const body = values.slice(1);
    for (let c = 0; c < headerRow.length; c++) {
      const colVals = body.map(r => r[c]);
      const hasData = colVals.some(v => v !== '' && Number(v) !== 0);
      if (!hasData) sheet.hideColumns(c + 1);
    }
  } catch (err) {
    Logger.log('âš ï¸ Post-hide routine failed: ' + err.message);
  }

  // âœ… Format both sheets (history w/o totals; computation optionally with totals)
  try {
    // History (no totals)
    formatPayrollSheetUnified_(histSheet, false);

    // Computation â€” only add totals if not already present
    let includeTotals = true;
    const lr = sheet.getLastRow();
    const lc = sheet.getLastColumn();
    if (lr > 1 && lc > 1) {
      const lastRowVals = sheet
        .getRange(lr, 1, 1, lc)
        .getValues()[0]
        .map(String);
      if (lastRowVals.some(v => v.toUpperCase().includes('TOTAL'))) includeTotals = false;
    }
    formatPayrollSheetUnified_(sheet, includeTotals);
  } catch (err) {
    Logger.log('âš ï¸ Formatting failed (non-blocking): ' + err.message);
  }

  // âœ… Refresh YTD + tidy, if requested
  if (refreshYtd) {
    
    
    try {
      _arrangeSheets_();
    } catch (e) {
      Logger.log('_arrangeSheets_ failed: ' + e.message);
    }
  }

  ui.alert(
    `âœ… Posted ${newRows.length} employee rows to PAYROLL_HISTORY from "${sheetName}".`
  );

  return {
    rows: newRows.length,
    sheetName,
    postedName,
    firstRow: insertStart,
    lastRow: insertEnd
  };
}

function debugComponentMapBonus() {
  const ss  = SpreadsheetApp.getActiveSpreadsheet();
  const cfg = _readSettings_();

  const map = _buildComponentMap_(cfg);
  const key = 'BONUS';
  const rec = map[key];

  if (!rec) {
    Logger.log('No mapping for ' + key);
    return;
  }

  Logger.log(
    'BONUS => category=' + rec.category +
    ' | source=' + rec.source
  );
}
// Public alias (no underscore) so itâ€™s â€œvisibleâ€
function include(name) {
  return include_(name);
}

// Public alias (no underscore) so itâ€™s â€œvisibleâ€
function getBranding() {
  return getBranding_();
}

function include_(name) {
  return HtmlService.createTemplateFromFile(name).evaluate().getContent();
}

const NETPAY_DEFAULT_BRAND_LOGO_URL =
  'https://drive.google.com/uc?export=view&id=1bCGM8cziBH0oqbRqN7TPlTul-6ogvgVC';

function _extractDriveFileIdFromUrl_(s) {
  const str = String(s || '').trim();
  if (!str) return '';

  // If already a raw ID
  if (/^[a-zA-Z0-9_-]{10,}$/.test(str) && str.indexOf('http') !== 0) return str;

  // Common Drive patterns
  let m = str.match(/[?&]id=([a-zA-Z0-9_-]+)/i);
  if (m && m[1]) return m[1];

  m = str.match(/\/d\/([a-zA-Z0-9_-]+)/i);
  if (m && m[1]) return m[1];

  return '';
}

function _brandLogoUrlToDataUrl_(logoUrlOrId) {
  const fileId = _extractDriveFileIdFromUrl_(logoUrlOrId);
  if (!fileId) return '';

  const file = DriveApp.getFileById(fileId);
  const blob = file.getBlob();
  const mime = blob.getContentType() || 'image/png';
  const b64 = Utilities.base64Encode(blob.getBytes());
  return 'data:' + mime + ';base64,' + b64;
}


function getBranding_() {
  const props = PropertiesService.getScriptProperties();

  // Prefer saved value (setBrandLogoUrl_ writes this key)
  const saved = String(props.getProperty('NETPAY_BRAND_LOGO_URL') || '').trim();
  const raw = saved || NETPAY_DEFAULT_BRAND_LOGO_URL;

  // âœ… Convert Drive file to inline base64 to avoid broken images in dialogs
  const dataUrl = _brandLogoUrlToDataUrl_(raw);
  const finalLogo = dataUrl || raw;

  return {
    showBranding: true,
    toolName: 'Netpay PH',
    logoUrl: finalLogo
  };
}

function setBrandLogoUrl_(url) {
  const clean = String(url || '').trim();
  if (!clean) throw new Error('Missing logo URL.');
  PropertiesService.getScriptProperties().setProperty('NETPAY_BRAND_LOGO_URL', clean);
  return true;
}

function promptSetBrandLogoUrl_() {
  const ui = SpreadsheetApp.getUi();
  const res = ui.prompt(
    'https://drive.google.com/uc?export=view&id=1bCGM8cziBH0oqbRqN7TPlTul-6ogvgVC',
    'Paste the Drive image link (recommended format: https://drive.google.com/uc?export=view&id=FILE_ID):',
    ui.ButtonSet.OK_CANCEL
  );

  if (res.getSelectedButton() !== ui.Button.OK) return false;

  const url = String(res.getResponseText() || '').trim();
  if (!url) throw new Error('No URL provided.');

  return setBrandLogoUrl_(url);
}

// ===== Public aliases (EXPOSE THESE) =====
function setBrandLogoUrl(url) {
  return setBrandLogoUrl_(url);
}

function promptSetBrandLogoUrl() {
  return promptSetBrandLogoUrl_();
}


/**
 * DEBUG: Why Semi-Monthly B is still taking full-month statutories
 * - Scans PAYROLL_HISTORY for the month (periodKey like "2026-01")
 * - Sums statutory headers per employee for A / B / Month (RAW + ABS)
 * - If your loaders exist, also compares against:
 *     _loadTakenThisMonth_(hist, periodKey)
 *     _loadTakenThisMonthByPart_(hist, periodKey)
 * - Outputs to _DEBUG_SEMI_B_STAT (clears & rewrites)
 *
 * Usage (Apps Script editor):
 *   debugSemiBStatutories_('2026-01');                // all employees found in history for that month
 *   debugSemiBStatutories_('2026-01', 'EMP001');      // specific employee
 */
function debugSemiBStatutories(periodKey, empIdFilter) {
  const ss = SpreadsheetApp.getActive();

  // --- locate history sheet (do NOT change any existing logic) ---
  let hist = null;
  try {
    if (typeof _ensureHistorySheet_ === 'function') hist = _ensureHistorySheet_();
  } catch (e) {}
  if (!hist) {
    hist =
      ss.getSheetByName('PAYROLL_HISTORY') ||
      ss.getSheetByName('Payroll History') ||
      ss.getSheetByName('Payroll_History');
  }
  if (!hist) throw new Error('Cannot find PAYROLL_HISTORY sheet.');

  // --- helpers ---
  const norm = (s) => String(s == null ? '' : s).replace(/\u00A0/g, ' ').trim();
  const normKey = (s) => norm(s).toUpperCase().replace(/[^A-Z0-9]/g, '');
  const n = (x) => (Number(x) || 0);

  const findHeaderIdx = (headers, wanted) => {
    const wantN = normKey(wanted);
    for (let i = 0; i < headers.length; i++) {
      if (normKey(headers[i]) === wantN) return i;
    }
    return -1;
  };

  const findHeaderAny = (headers, candidates) => {
    for (const c of candidates) {
      const idx = findHeaderIdx(headers, c);
      if (idx > -1) return idx;
    }
    return -1;
  };

  const guessPartFromPeriodLabel = (periodLabel) => {
    const m = String(periodLabel || '').match(/(?:^|[-\s])(A|B|M|SPECIAL)\b/i);
    return m ? String(m[1]).toUpperCase() : '';
  };

  // --- read history data ---
  const data = hist.getDataRange().getValues();
  if (data.length < 2) throw new Error('PAYROLL_HISTORY is empty.');

  const headers = data[0].map(norm);

  const idxEmpId = findHeaderAny(headers, [
    'EMPLOYEE ID', 'Employee ID', 'EMP ID', 'ID'
  ]);
  const idxPeriod = findHeaderAny(headers, [
    'PERIOD', 'PAY PERIOD', 'PAYROLL PERIOD', 'PERIOD LABEL', 'PERIODKEY'
  ]);
  const idxPart = findHeaderAny(headers, [
    'PART', 'CUTOFF', 'CUT-OFF', 'SEMIMONTHLY PART'
  ]); // optional

  if (idxEmpId < 0) throw new Error('PAYROLL_HISTORY missing an Employee ID column.');
  if (idxPeriod < 0) throw new Error('PAYROLL_HISTORY missing a Period/Pay Period column.');

  // keys used by statutory cap enforcement in _computeStatutoryForPeriod_
  // (these must be the ones "taken(key)" can find):contentReference[oaicite:2]{index=2}
  const KEYS = [
    'SSS EE MC',
    'SSS EE MPF',
    'SSS ER MC',
    'SSS ER MPF',
    'SSS EC',
    'PhilHealth EE',
    'PhilHealth ER',
    'Pag-IBIG EE',
    'Pag-IBIG ER',
  ];

  const keyToCol = {};
  KEYS.forEach(k => {
    const idx = findHeaderIdx(headers, k);
    keyToCol[k] = idx; // -1 if missing (we will flag it)
  });

  // --- aggregate history sums per employee ---
  // store sums for A / B / M as { raw: {key:sum}, abs:{key:sum} }
  const agg = new Map(); // empId -> {A:{raw,abs}, B:{raw,abs}, M:{raw,abs}}
  const ensureAgg = (empId) => {
    if (!agg.has(empId)) {
      const blankBucket = () => ({ raw: {}, abs: {} });
      agg.set(empId, { A: blankBucket(), B: blankBucket(), M: blankBucket() });
    }
    return agg.get(empId);
  };

  const rows = data.slice(1);
  rows.forEach(r => {
    const empId = norm(r[idxEmpId]);
    if (!empId) return;
    if (empIdFilter && String(empIdFilter).trim() !== empId) return;

    const periodVal = norm(r[idxPeriod]);
    if (!periodVal) return;

    // match month: allow "2026-01", "2026/01", "2026-01-A", etc.
    const monthMatch = periodVal.includes(periodKey);
    if (!monthMatch) return;

    let part = '';
    if (idxPart > -1) part = String(r[idxPart] || '').trim().toUpperCase();
    if (!part) part = guessPartFromPeriodLabel(periodVal);
    if (part !== 'A' && part !== 'B') {
      // If history rows are stored as month-only, treat as "M"
      part = 'M';
    }

    const a = ensureAgg(empId);

    KEYS.forEach(k => {
      const c = keyToCol[k];
      if (c < 0) return; // missing header; weâ€™ll flag later
      const v = n(r[c]);
      // part bucket
      if (part === 'A' || part === 'B') {
        a[part].raw[k] = (a[part].raw[k] || 0) + v;
        a[part].abs[k] = (a[part].abs[k] || 0) + Math.abs(v);
      }
      // month bucket always accumulates
      a.M.raw[k] = (a.M.raw[k] || 0) + v;
      a.M.abs[k] = (a.M.abs[k] || 0) + Math.abs(v);
    });
  });

  // --- also pull what the runtime loaders think, if they exist ---
  let takenMap = null;
  let takenByPt = null;
  try {
    if (typeof _loadTakenThisMonth_ === 'function') takenMap = _loadTakenThisMonth_(hist, periodKey);
  } catch (e) {
    Logger.log('[DEBUG_SEMI_B_STAT] _loadTakenThisMonth_ threw: ' + e);
  }
  try {
    if (typeof _loadTakenThisMonthByPart_ === 'function') takenByPt = _loadTakenThisMonthByPart_(hist, periodKey);
  } catch (e) {
    Logger.log('[DEBUG_SEMI_B_STAT] _loadTakenThisMonthByPart_ threw: ' + e);
  }

  const getTaken = (obj, key) => {
    if (!obj) return null;
    try {
      if (typeof _nCI_ === 'function') return Number(_nCI_(obj, key)) || 0;
    } catch (e) {}
    // fallback: direct
    return Number(obj[key]) || 0;
  };

  // --- write debug output sheet ---
  const shName = '_DEBUG_SEMI_B_STAT';
  let dbg = ss.getSheetByName(shName);
  if (!dbg) dbg = ss.insertSheet(shName);
  dbg.clearContents();

  const out = [];
  out.push([
    'Timestamp',
    'periodKey',
    'Employee ID',
    'Component Key',
    'HIST_A_RAW',
    'HIST_A_ABS',
    'HIST_B_RAW',
    'HIST_B_ABS',
    'HIST_M_RAW',
    'HIST_M_ABS',
    'takenMap(key)',
    'takenByPt.A(key)',
    'takenByPt.B(key)',
    'priorTakenKeys(sample)',
    'FLAGS'
  ]);

  const now = new Date();
  const empIds = Array.from(agg.keys()).sort();

  empIds.forEach(empId => {
    const a = agg.get(empId);

    // if loaders exist, inspect their objects/keys
    const priorTakenObj = takenMap && typeof takenMap.get === 'function'
      ? (takenMap.get(empId) || {})
      : null;

    const priorAObj = takenByPt && takenByPt.A && typeof takenByPt.A.get === 'function'
      ? (takenByPt.A.get(empId) || {})
      : null;

    const priorBObj = takenByPt && takenByPt.B && typeof takenByPt.B.get === 'function'
      ? (takenByPt.B.get(empId) || {})
      : null;

    const priorKeys = priorTakenObj ? Object.keys(priorTakenObj).slice(0, 30).join(' | ') : '';

    KEYS.forEach(k => {
      const colMissing = keyToCol[k] < 0;

      const histAraw = n(a.A.raw[k]);
      const histAabs = n(a.A.abs[k]);
      const histBraw = n(a.B.raw[k]);
      const histBabs = n(a.B.abs[k]);
      const histMraw = n(a.M.raw[k]);
      const histMabs = n(a.M.abs[k]);

      const tMap = priorTakenObj ? getTaken(priorTakenObj, k) : null;
      const tA   = priorAObj ? getTaken(priorAObj, k) : null;
      const tB   = priorBObj ? getTaken(priorBObj, k) : null;

      const flags = [];
      if (colMissing) flags.push('HISTORY_HEADER_MISSING');
      if (histAabs > 0 && (tMap === 0 || tMap === null)) flags.push('TAKENMAP_ZERO_BUT_A_EXISTS');
      if (tMap != null && tMap < 0) flags.push('TAKENMAP_NEGATIVE');
      if (histMabs > 0 && (tMap === 0 || tMap === null)) flags.push('TAKENMAP_ZERO_BUT_MONTH_EXISTS');
      if (tA != null && tA < 0) flags.push('TAKEN_A_NEGATIVE');
      if (tB != null && tB < 0) flags.push('TAKEN_B_NEGATIVE');

      // helpful mismatch signal: loader vs history ABS for A
      if (tA != null && Math.abs(tA - histAabs) > 0.01) flags.push('TAKEN_A_NEQ_HIST_A_ABS');
      // helpful mismatch signal: loader vs history ABS for month
      if (tMap != null && Math.abs(Math.abs(tMap) - histMabs) > 0.01) flags.push('TAKENMAP_NEQ_HIST_M_ABS');

      out.push([
        now,
        periodKey,
        empId,
        k,
        histAraw,
        histAabs,
        histBraw,
        histBabs,
        histMraw,
        histMabs,
        tMap,
        tA,
        tB,
        priorKeys,
        flags.join(' | ')
      ]);
    });
  });

  dbg.getRange(1, 1, out.length, out[0].length).setValues(out);
  dbg.setFrozenRows(1);
  dbg.autoResizeColumns(1, out[0].length);

  // keep it visible by default (so you can inspect immediately)
  // if you want hidden: dbg.hideSheet();

  Logger.log(`[DEBUG_SEMI_B_STAT] Wrote ${out.length - 1} rows to ${shName}`);
}


/**
 * Pinpoint why Semi-B loses BASIC PAY / recurring adjustments and why deductions don't split.
 *
 * What it shows:
 *  - priorMTD (takenMap) vs priorA (takenByPt.A) for the SAME key
 *  - computed value for B if subtracting priorMTD (current behavior)
 *  - computed value for B if subtracting priorThisPart (should be 0 since B not posted yet)
 *
 * Run examples:
 *   debugPinpointSemiB_('2025-12', 'TH24-005', '2025-12-16', '2025-12-31');
 */
function debugPinpointSemiB(periodKey, empId, fromISO, toISO) {
  const ss = SpreadsheetApp.getActive();

  // --- Settings + linked files (same helpers used by generator) ---
  const cfg = (typeof _readSettings_ === 'function') ? _readSettings_() : null;
  if (!cfg) throw new Error('Missing _readSettings_() in this project.');

  const links = (typeof _openLinkedFiles_ === 'function') ? _openLinkedFiles_(cfg, ss) : null;
  if (!links || !links.sourceSS) throw new Error('Cannot open linked Source SS (check settings).');
  const sourceSS = links.sourceSS;

  // --- Sheets ---
  const hist = (typeof _ensureHistorySheet_ === 'function') ? _ensureHistorySheet_() : ss.getSheetByName('PAYROLL_HISTORY');
  if (!hist) throw new Error('Cannot find PAYROLL_HISTORY.');

  const masterSh =
    sourceSS.getSheetByName(cfg.MASTER_SHEET_NAME) ||
    sourceSS.getSheetByName('Masterfile Import') ||
    sourceSS.getSheetByName('Masterfile import');

  if (!masterSh) throw new Error('Cannot find Masterfile sheet in SOURCE SS.');

  // --- Load taken maps (what B uses) ---
  const takenMap = (typeof _loadTakenThisMonth_ === 'function') ? _loadTakenThisMonth_(hist, periodKey) : null;
  if (!takenMap) throw new Error('Missing _loadTakenThisMonth_() in this project.');

  const takenByPt = (typeof _loadTakenThisMonthByPart_ === 'function')
    ? _loadTakenThisMonthByPart_(hist, periodKey)
    : null;

  const priorMTD = takenMap.get(empId) || {};
  const priorA = (takenByPt && takenByPt.A && typeof takenByPt.A.get === 'function')
    ? (takenByPt.A.get(empId) || {})
    : {};

  // For Semi-B BEFORE posting B, "priorThisPart" should be 0 for everything.
  // This lets us show the delta caused by subtracting MTD (A) vs subtracting only current part.
  const priorThisPart = {}; // intentionally empty

  // --- Helper: case-insensitive numeric read like _nCI_ would do ---
  const nCI = (obj, key) => {
    if (!obj) return 0;
    const want = String(key || '').trim().toUpperCase();
    for (const k in obj) {
      if (String(k || '').trim().toUpperCase() === want) return Number(obj[k]) || 0;
    }
    return 0;
  };

  // --- Read master row ---
  const mData = masterSh.getDataRange().getValues();
  if (mData.length < 2) throw new Error('Masterfile sheet is empty.');
  const mHdr = mData[0].map(h => String(h || '').trim());
  const mHdrU = mHdr.map(h => h.toUpperCase());
  const idxEmp = mHdrU.indexOf('EMPLOYEE ID');
  if (idxEmp < 0) throw new Error('Masterfile missing "EMPLOYEE ID" header.');

  const row = mData.find((r, i) => i > 0 && String(r[idxEmp] || '').trim() === String(empId).trim());
  if (!row) throw new Error(`Employee ID not found in masterfile: ${empId}`);

  // --- Mode resolver (same logic) ---
  const getModeFor = (componentName) => {
    const key = String(componentName || '').trim();
    const override = cfg.employeeOverrides && cfg.employeeOverrides.get
      ? cfg.employeeOverrides.get(`${empId}-${key}`)
      : null;
    if (override) return String(override).toLowerCase();
    const m = cfg.componentModes && cfg.componentModes.get ? cfg.componentModes.get(key) : null;
    return String(m || 'split').toLowerCase();
  };

  // --- Semi-monthly B portion logic (mirrors _periodPortion_) ---
  const partLabel = 'B';
  const periodPortion = (monthly, mode) => {
    if (partLabel === 'A') {
      if (mode === 'split') return monthly / 2;
      if (mode === 'first') return monthly;
      if (mode === 'full') return monthly;
      return 0;
    }
    if (partLabel === 'B') {
      if (mode === 'split') return monthly / 2;
      if (mode === 'second') return monthly;
      if (mode === 'full') return monthly;
      return 0;
    }
    return monthly;
  };

  const r2 = (v) => Math.round((Number(v) || 0) * 100) / 100;

  // --- Choose which masterfile components to inspect ---
  // 1) Always inspect these:
  const WATCH = [
    'BASIC PAY',
    'NON-TAXABLE ALLOWANCE',
    'DEMINIMIS ALLOWANCE',
    'SSS LOAN',
    'HMO DEDUCTION'
  ];

  // 2) Also inspect anything that exists in priorMTD keys (because those are the ones subtracting to zero)
  Object.keys(priorMTD).forEach(k => {
    const kk = String(k || '').trim();
    if (kk && !WATCH.includes(kk)) WATCH.push(kk);
  });

  // Only keep those that exist as masterfile headers (weâ€™re debugging Masterfile pull here)
  const watchExisting = WATCH.filter(h => mHdrU.includes(String(h).toUpperCase()));

  // --- Build output: Masterfile pull impact ---
  const out = [];
  out.push([
    'Employee ID', 'PeriodKey', 'Part',
    'Header',
    'Masterfile Monthly Value',
    'Mode',
    'Target For B (monthlyâ†’portion)',
    'priorMTD (takenMap)',
    'priorA (takenByPt.A)',
    'priorThisPart (expected 0 before posting B)',
    'Computed If Subtract priorMTD (CURRENT BEHAVIOR)',
    'Computed If Subtract priorThisPart (WHAT YOU EXPECT FOR B)',
    'Notes'
  ]);

  watchExisting.forEach(header => {
    const idx = mHdrU.indexOf(String(header).toUpperCase());
    const raw = row[idx];

    // parse number like the generator does (_toNumber_)
    const monthlyVal = (typeof _toNumber_ === 'function')
      ? _toNumber_(raw)
      : (Number(String(raw).replace(/,/g, '')) || 0);

    const mode = getModeFor(header);
    const target = periodPortion(monthlyVal, mode);

    const pMTD = nCI(priorMTD, header);
    const pA = nCI(priorA, header);
    const pPart = nCI(priorThisPart, header);

    const computedCurrent = r2(target - pMTD);
    const computedExpected = r2(target - pPart);

    let notes = '';
    if (computedCurrent === 0 && computedExpected !== 0) notes = 'ZEROED because priorMTD includes A';
    if (String(header).toUpperCase() === 'BASIC PAY' && pMTD > 0) notes = 'BASIC PAY is being treated as month-to-date â€œalready takenâ€';

    out.push([
      empId, periodKey, partLabel,
      header,
      r2(monthlyVal),
      mode,
      r2(target),
      r2(pMTD),
      r2(pA),
      r2(pPart),
      computedCurrent,
      computedExpected,
      notes
    ]);
  });

  writeDebugSheet_(ss, '_DEBUG_SEMI_B_PINPOINT', out);

  // --- Build output: Recurring Adjustments impact (Masterfile "Recurring Adjustments" sheet) ---
  const rangeStart = fromISO ? new Date(fromISO) : null;
  const rangeEnd = toISO ? new Date(toISO) : null;

  const rec = (typeof _loadRecurringAdjustments_ === 'function')
    ? _loadRecurringAdjustments_(sourceSS, { partLabel, rangeStart, rangeEnd, periodKey, hist })
    : [];

  const recEmp = rec.filter(a => String(a.empId || '').trim() === String(empId).trim());

  const outAdj = [];
  outAdj.push([
    'Employee ID','PeriodKey','Part',
    'Adj Name','Adj Cat',
    'Adj Amt For This Run (already split/1st/2nd by loader)',
    'priorMTD (takenMap)',
    'priorA (takenByPt.A)',
    'Computed valueForRun = adjAmt - priorMTD (CURRENT)',
    'Computed if priorThisPart=0 (EXPECTED for B)',
    'What happened'
  ]);

  recEmp.forEach(a => {
    const name = String(a.name || '').trim();
    const amt = Number(a.amt) || 0;
    const cat = String(a.cat || '').trim();

    const pMTD = nCI(priorMTD, name);
    const pA = nCI(priorA, name);

    const current = r2(amt - pMTD);
    const expected = r2(amt - 0);

    let what = '';
    if (current === 0 && expected !== 0) what = 'DISAPPEARS because priorMTD includes A';
    if (Math.abs(pMTD) >= Math.abs(amt) && pMTD !== 0) what = what || 'priorMTD cancels this run';

    outAdj.push([
      empId, periodKey, partLabel,
      name, cat,
      r2(amt),
      r2(pMTD),
      r2(pA),
      current,
      expected,
      what
    ]);
  });

  writeDebugSheet_(ss, '_DEBUG_SEMI_B_PINPOINT_ADJ', outAdj);

  Logger.log(`[PINPOINT] Done. Check _DEBUG_SEMI_B_PINPOINT and _DEBUG_SEMI_B_PINPOINT_ADJ for ${empId}.`);
}

/**
 * DEBUG: Why BASIC PAY becomes 0 (netted by prior taken)
 * Writes:
 *  - _DEBUG_BASIC_PAY_NETTING (summary)
 *  - _DEBUG_BASIC_PAY_NETTING_HIST (matching PAYROLL_HISTORY rows)
 */
function DEBUG_BASIC_PAY_NETTING(empId, periodKey, partLabel) {
  empId = String(empId || '').trim();
  periodKey = String(periodKey || '').trim();
  partLabel = String(partLabel || '').trim().toUpperCase();

  if (!empId) throw new Error('DEBUG_BASIC_PAY_NETTING: empId is required');
  if (!periodKey) throw new Error('DEBUG_BASIC_PAY_NETTING: periodKey is required');
  if (partLabel !== 'A' && partLabel !== 'B' && partLabel !== 'SPECIAL') {
    throw new Error('DEBUG_BASIC_PAY_NETTING: partLabel must be A, B, or SPECIAL');
  }

  const cfg = _readSettings_();

  const sourceSS = SpreadsheetApp.openById(cfg.SOURCE_SS_ID);
  const mSh = sourceSS.getSheetByName(cfg.MASTER_SHEET_NAME);
  if (!mSh) throw new Error(`Missing Masterfile sheet: ${cfg.MASTER_SHEET_NAME}`);

  const mData = mSh.getDataRange().getValues();
  const mHdr = mData[0].map(h => String(h || '').trim());
  const mRows = mData.slice(1);

  const idxEmp = _findHeaderFuzzy_(mHdr, ['Employee ID','EMPLOYEE ID','Emp ID']);
  const idxName = _findHeaderFuzzy_(mHdr, ['Employee Name','EMPLOYEE NAME']);
  const idxBasic = _findHeaderFuzzy_(mHdr, ['BASIC PAY','Basic Pay','Basic']);
  const idxPB = _findHeaderFuzzy_(mHdr, ['Pay Basis','PAY BASIS']);

  if (idxEmp < 0) throw new Error('Missing Employee ID column in Masterfile');
  if (idxBasic < 0) throw new Error('Missing BASIC PAY column in Masterfile');
  if (idxPB < 0) throw new Error('Missing PAY BASIS column in Masterfile');

  const row = mRows.find(r => String(r[idxEmp] || '').trim() === empId);
  if (!row) throw new Error(`Employee not found in Masterfile: ${empId}`);

  const empName = idxName > -1 ? String(row[idxName] || '').trim() : '';
  const payBasis = String(row[idxPB] || '').trim().toUpperCase();
  const masterBasic = _toNumber_(row[idxBasic]) || 0;

  // Attendance
  const inputsSS = SpreadsheetApp.openById(cfg.INPUTS_SS_ID);
  const attSh = inputsSS ? inputsSS.getSheetByName('Attendance') : null;
  const attMap = _loadAttendanceDaysMap_(attSh);
  const daysWorked = _toNumber_(attMap.get(empId) || 0) || 0;

  // History
  const hist = _ensureHistorySheet_();
  const takenMap = _loadTakenThisMonth_(hist, periodKey);
  const takenByPt = _loadTakenThisMonthByPart_(hist, periodKey);

  const priorMTDObj = takenMap.get(empId) || {};
  const priorAObj = (takenByPt && takenByPt.A && typeof takenByPt.A.get === 'function')
    ? (takenByPt.A.get(empId) || {})
    : {};
  const priorBObj = (takenByPt && takenByPt.B && typeof takenByPt.B.get === 'function')
    ? (takenByPt.B.get(empId) || {})
    : {};

  const priorMTD = _nCI_(priorMTDObj, 'BASIC PAY');
  const priorA = _nCI_(priorAObj, 'BASIC PAY');
  const priorB = _nCI_(priorBObj, 'BASIC PAY');
  const priorThisPart = (partLabel === 'A') ? priorA : (partLabel === 'B') ? priorB : 0;

  // Expected nominal BASIC PAY for this run (without prior netting)
  const isDaily = (payBasis === 'DAILY');
  const nominal = isDaily ? (masterBasic * daysWorked) : masterBasic;

  // What your â€œprior takenâ€ protection will do
  const valueForRun = _r2_(nominal - priorThisPart);

  // Build summary
  const ss = SpreadsheetApp.getActiveSpreadsheet();

  const summary = [];
  summary.push(['Employee ID', empId]);
  summary.push(['Employee Name', empName]);
  summary.push(['PeriodKey', periodKey]);
  summary.push(['Part', partLabel]);
  summary.push(['PayBasis', payBasis]);
  summary.push(['Master BASIC PAY', _r2_(masterBasic)]);
  summary.push(['Attendance DaysWorked', _r2_(daysWorked)]);
  summary.push(['Nominal BASIC PAY this run (before prior)', _r2_(nominal)]);
  summary.push(['Prior BASIC PAY MTD (history)', _r2_(priorMTD)]);
  summary.push(['Prior BASIC PAY A (history)', _r2_(priorA)]);
  summary.push(['Prior BASIC PAY B (history)', _r2_(priorB)]);
  summary.push(['Prior BASIC PAY THIS PART (history)', _r2_(priorThisPart)]);
  summary.push(['Computed BASIC PAY valueForRun = nominal - priorThisPart', _r2_(valueForRun)]);
  summary.push(['Conclusion',
    (valueForRun === 0 && nominal !== 0 && priorThisPart !== 0)
      ? 'BASIC PAY is netted to ZERO because PAYROLL_HISTORY already has BASIC PAY for this periodKey+part.'
      : 'Not netted to zero (check other causes).'
  ]);

  writeDebugSheet_(ss, '_DEBUG_BASIC_PAY_NETTING', summary);

  // Build matching history rows (so you can SEE what is canceling)
  const histData = hist.getDataRange().getValues();
  const hHdr = histData[0].map(h => String(h || '').trim());
  const hRows = histData.slice(1);

  const idxHPer = hHdr.findIndex(h => /^Period$/i.test(h));
  const idxHEmp = hHdr.findIndex(h => /^Employee ID$/i.test(h));
  const idxHPart = hHdr.findIndex(h => /^Part$/i.test(h));
  const idxHBasic = hHdr.findIndex(h => String(h || '').trim().toUpperCase() === 'BASIC PAY');

  const outHist = [];
  outHist.push(['Period','Part','Employee ID','BASIC PAY','Row# in PAYROLL_HISTORY']);

  if (idxHPer > -1 && idxHEmp > -1 && idxHBasic > -1) {
    hRows.forEach((r, i) => {
      const per = String(r[idxHPer] || '').trim();
      const eid = String(r[idxHEmp] || '').trim();
      if (!per.startsWith(periodKey)) return;
      if (eid !== empId) return;

      const part = (idxHPart > -1) ? String(r[idxHPart] || '').trim() : '';
      const basic = _toNumber_(r[idxHBasic]) || 0;

      outHist.push([per, part, eid, _r2_(basic), i + 2]); // +2 because header row + 1-index
    });
  }

  writeDebugSheet_(ss, '_DEBUG_BASIC_PAY_NETTING_HIST', outHist);

  Logger.log(`[DEBUG_BASIC_PAY_NETTING] Done for ${empId} ${periodKey} ${partLabel}. Check _DEBUG_BASIC_PAY_NETTING + _DEBUG_BASIC_PAY_NETTING_HIST.`);
}


// Helper: write 2D array to sheet
function writeDebugSheet_(ss, name, values) {
  let sh = ss.getSheetByName(name);
  if (!sh) sh = ss.insertSheet(name);
  sh.clearContents();
  sh.getRange(1,1,values.length,values[0].length).setValues(values);
  sh.setFrozenRows(1);
  sh.autoResizeColumns(1, values[0].length);
}

function _isMonthlyCapCatchUpKey_(key) {
  const k = String(key || '').trim().toUpperCase();

  // ONLY the monthly-capped items that should do "remaining in B"
  return (
    k === 'SSS EE MC' ||
    k === 'SSS EE MPF' ||
    k === 'SSS ER MC' ||
    k === 'SSS ER MPF' ||
    k === 'SSS EC' ||
    k === 'PHILHEALTH EE' ||
    k === 'PHILHEALTH ER' ||
    k === 'PAG-IBIG EE' ||
    k === 'PAG-IBIG ER'
    // Add withholding tax here ONLY if you truly intend B to be "month remaining" (usually NO)
  );
}

/**
 * For catch-up keys: use ABS priorMTD (month-to-date taken).
 * For everything else: return 0 so B does NOT get canceled/doubled.
 */
function _priorTakenForThisComponent_(priorMTD, componentKey) {
  if (!_isMonthlyCapCatchUpKey_(componentKey)) return 0;
  return Math.abs(_nCI_(priorMTD || {}, componentKey));
}

/**
 * DEBUG: Why BASIC PAY is 0 (especially for Semi A) and sanity-check days worked + mode.
 *
 * Run:
 *   DEBUG_EMP_BASIC_SSS("2026-01-A", "EC003");
 *   DEBUG_EMP_BASIC_SSS("2026-01-A", "EC013");
 *   DEBUG_EMP_BASIC_SSS("2026-01-A", "EC032");
 */
function DEBUG_EMP_BASIC_SSS(periodKey, empId) {
  if (!periodKey) throw new Error("DEBUG_EMP_BASIC_SSS: periodKey required (e.g. 2026-01-A).");
  if (!empId) throw new Error("DEBUG_EMP_BASIC_SSS: empId required (e.g. EC003).");

  const norm = (s) => String(s || "").trim().toUpperCase();
  const toNum = (v) => {
    if (v === null || v === undefined || v === "") return 0;
    if (typeof v === "number") return v;
    const s = String(v).replace(/,/g, "").trim();
    const n = Number(s);
    return isNaN(n) ? NaN : n;
  };

  const parsePeriod = (k) => {
    const m = String(k).trim().match(/^(\d{4})-(\d{2})(?:-([AB]))?$/i);
    if (!m) throw new Error('DEBUG_EMP_BASIC_SSS: periodKey must look like "YYYY-MM-A" or "YYYY-MM-B" or "YYYY-MM".');
    return {
      payrollMonthKey: `${m[1]}-${m[2]}`,
      partLabel: (m[3] ? String(m[3]).toUpperCase() : "")
    };
  };

  const findCol = (headers, names) => {
    const up = headers.map(h => norm(h));
    for (const n of names) {
      const i = up.indexOf(norm(n));
      if (i > -1) return i;
    }
    return -1;
  };

  const findRowByEmpId = (vals, empIdUpper, idIdx) => {
    for (let r = 1; r < vals.length; r++) {
      if (norm(vals[r][idIdx]) === empIdUpper) return { r, row: vals[r] };
    }
    return null;
  };

  const { partLabel } = parsePeriod(periodKey);
  const empIdU = norm(empId);

  // âœ… This exists in PAYROLLGENERATOR.TXT and includes componentModes + employeeOverrides
  const cfg = _readSettings_();
  const componentModes = cfg.componentModes || new Map();
  const employeeOverrides = cfg.employeeOverrides || new Map();

  const activeSS = SpreadsheetApp.getActiveSpreadsheet();
  const files = _openLinkedFiles_(cfg, activeSS);
  const sourceSS = files.sourceSS;
  const inputsSS = files.inputsSS;

  // ---- MASTERFILE ----
  const masterSh = sourceSS.getSheetByName(cfg.MASTER_SHEET_NAME);
  if (!masterSh) throw new Error("DEBUG_EMP_BASIC_SSS: master sheet not found: " + cfg.MASTER_SHEET_NAME);

  const mVals = masterSh.getDataRange().getValues();
  if (mVals.length < 2) throw new Error("DEBUG_EMP_BASIC_SSS: masterfile has no data rows.");

  const mHeaders = mVals[0] || [];
  const idxEmp = findCol(mHeaders, ["Employee ID", "Emp ID"]);
  if (idxEmp < 0) throw new Error('DEBUG_EMP_BASIC_SSS: "Employee ID" not found in masterfile.');

  const mf = findRowByEmpId(mVals, empIdU, idxEmp);
  if (!mf) throw new Error("DEBUG_EMP_BASIC_SSS: employee not found in masterfile: " + empIdU);

  const idxPayBasis = findCol(mHeaders, ["Pay Basis", "PAY BASIS"]);
  const idxBasic = findCol(mHeaders, ["Basic Pay", "BASIC PAY"]);
  const idxCompBasic = findCol(mHeaders, ["Computed Basic Pay", "COMPUTED BASIC PAY"]);

  const payBasis = idxPayBasis > -1 ? String(mf.row[idxPayBasis] || "") : "";
  const isDailyPayBasis = norm(payBasis) === "DAILY";

  const rawBasic = idxBasic > -1 ? toNum(mf.row[idxBasic]) : NaN;
  const computedBasic = idxCompBasic > -1 ? toNum(mf.row[idxCompBasic]) : 0;
  const overrideBasic = (!isNaN(computedBasic) && computedBasic > 0) ? computedBasic : 0;

  // ---- MODE RESOLUTION (matches your fileâ€™s settings sheets) ----
  const compKey = "BASIC PAY";
  const empOverrideKey = `${empIdU}-${compKey}`;
  const ovMode = String(employeeOverrides.get(empOverrideKey) || "").trim().toLowerCase();
  const baseMode = String(componentModes.get(compKey) || "split").trim().toLowerCase();
  const mode = (ovMode && ["split","first","second","full"].includes(ovMode)) ? ovMode : baseMode;

  // Expected BASIC PAY for Semi A/B when NOT DAILY
  const baseMonthly = (overrideBasic > 0 ? overrideBasic : (isNaN(rawBasic) ? 0 : rawBasic));
  let expectedNonDaily = baseMonthly;
  if (partLabel === "A" || partLabel === "B") {
    if (mode === "full") expectedNonDaily = baseMonthly;
    else if (mode === "split") expectedNonDaily = baseMonthly / 2;
    else if (mode === "first") expectedNonDaily = (partLabel === "A" ? baseMonthly : 0);
    else if (mode === "second") expectedNonDaily = (partLabel === "B" ? baseMonthly : 0);
    else expectedNonDaily = baseMonthly / 2;
  }

  // ---- ATTENDANCE DAYS WORKED (if DAILY) ----
  let daysWorked = null;
  if (inputsSS) {
    const attSh = inputsSS.getSheetByName("Attendance");
    if (attSh && attSh.getLastRow() >= 2) {
      const aVals = attSh.getDataRange().getValues();
      const aHeaders = aVals[0] || [];
      const aEmp = findCol(aHeaders, ["Employee ID", "Emp ID"]);
      const aDays = findCol(aHeaders, ["Days Worked", "Days"]);
      if (aEmp > -1 && aDays > -1) {
        for (let r = 1; r < aVals.length; r++) {
          if (norm(aVals[r][aEmp]) === empIdU) {
            daysWorked = toNum(aVals[r][aDays]);
            break;
          }
        }
      }
    }
  }

  // ---- HISTORY CHECK (confirm â€œno priorâ€) ----
  let hasBasicPayInHistorySamePart = false;
  const histSh = activeSS.getSheetByName("PAYROLL_HISTORY");
  if (histSh && histSh.getLastRow() >= 2) {
    const hVals = histSh.getDataRange().getValues();
    const hHeaders = hVals[0] || [];
    const hEmp = findCol(hHeaders, ["Employee ID", "Emp ID"]);
    const hPeriod = findCol(hHeaders, ["PeriodKey", "Period Key", "PERIODKEY"]);
    const hType = findCol(hHeaders, ["Type", "TYPE"]);
    const hAmount = findCol(hHeaders, ["Amount", "AMOUNT"]);
    if (hEmp > -1 && hPeriod > -1 && hType > -1 && hAmount > -1) {
      for (let r = 1; r < hVals.length; r++) {
        const e = norm(hVals[r][hEmp]);
        const p = String(hVals[r][hPeriod] || "").trim();
        const t = norm(hVals[r][hType]);
        const a = toNum(hVals[r][hAmount]);
        if (e === empIdU && p === periodKey && t === "BASIC PAY" && a !== 0) {
          hasBasicPayInHistorySamePart = true;
          break;
        }
      }
    }
  }

  // ---- PAYROLL COMPUTATION RESULT (actual row) ----
  let actualBasic = null;
  const pcSh =
  activeSS.getSheetByName("BRIGHTSHIFT, CTZAR, INTERNAL, LIVEMEUP, MCI, RED CIRCLE, STATIQ, VIBE, WISEPOPS - 2026-01-A") ||
  activeSS.getSheetByName("Payroll computation") ||
  activeSS.getSheets().slice().reverse().find(s => String(s.getName() || '').includes(periodKey)) ||
  null;

  if (pcSh && pcSh.getLastRow() >= 2) {
    const pcVals = pcSh.getDataRange().getValues();
    const pcHeaders = pcVals[0] || [];
    const pcEmp = findCol(pcHeaders, ["Employee ID", "Emp ID"]);
    const pcBasic = findCol(pcHeaders, ["Basic Pay", "BASIC PAY"]);
    if (pcEmp > -1 && pcBasic > -1) {
      const pcRow = findRowByEmpId(pcVals, empIdU, pcEmp);
      if (pcRow) actualBasic = pcRow.row[pcBasic];
    }
  }

  // ---- LOG ----
  Logger.log("====================================");
  Logger.log("[DEBUG_EMP_BASIC_SSS] " + empIdU + " | period=" + periodKey + " | part=" + partLabel);
  Logger.log("PayBasis=" + payBasis + " | isDailyPayBasis=" + isDailyPayBasis);
  Logger.log("Master Basic Pay=" + rawBasic + " | Computed Basic Pay=" + (idxCompBasic > -1 ? computedBasic : "(no col)"));
  Logger.log("Resolved BASIC PAY mode=" + mode + " (override=" + ovMode + ", base=" + baseMode + ")");
  Logger.log("Attendance DaysWorked=" + (daysWorked === null ? "(not found)" : daysWorked));
  Logger.log("History has BASIC PAY same PeriodKey=" + hasBasicPayInHistorySamePart);
  Logger.log("Expected BASIC PAY if NOT DAILY=" + expectedNonDaily);
  Logger.log("Actual BASIC PAY in Payroll Computation=" + (actualBasic === null ? "(not found)" : actualBasic));
  Logger.log("NOTE: If PayBasis=DAILY and DaysWorked>0 but Actual BASIC PAY=0, then your DAILY basicForRun logic is not being applied (check PAY BASIS value read + attendance empId match).");
  Logger.log("====================================");
}


// SSS base must include: BASIC PAY, ABSENCE, TARDINESS, SALARY ADJUSTMENT (plus anything mapped as Basic Pay Related)
function _isSssBaseComponent_(name, catLower) {
  const up = _normHdr_(name);
  if (catLower === 'basic pay related') return true;
  return (
    up === 'BASIC PAY' ||
    up === 'ABSENCE' ||
    up === 'TARDINESS' ||
    up === 'SALARY ADJUSTMENT'
  );
}

// PhilHealth base: BASIC PAY related EXCEPT Absence/Tardiness (your rule)
function _isPhilHealthBaseComponent_(name, catLower) {
  const up = _normHdr_(name);
  if (up === 'BASIC PAY') return true;

  // include mapped basic-pay-related but exclude Absence/Tardiness via your existing rule
  if (catLower === 'basic pay related' && !_isUnworkedTime_(name)) return true;

  // explicitly include Salary Adjustment even if mapping is off
  if (up === 'SALARY ADJUSTMENT') return true;

  return false;
}


function debugAbsTardLoad(empId) {
  const cfg = _readSettings_();
  const inputsSS = SpreadsheetApp.openById(cfg.INPUTS_SS_ID);

  const sh = inputsSS.getSheetByName('Absences_Tardiness');
  if (!sh) throw new Error('Missing sheet: Absences_Tardiness');

  const headers = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0].map(h => String(h || '').trim());

  const idxEmpId = _findHeaderFuzzy_(headers, ['Employee ID','Emp ID','EmployeeID']);
  const idxType  = _findHeaderFuzzy_(headers, [
    'Type',
    'Type (Absence/Tardiness)',
    'Type(Absence/Tardiness)',
    'Type (Absence / Tardiness)',
    'Type(Absence / Tardiness)',
    'Type Absence/Tardiness'
  ]);
  const idxAmt   = _findHeaderFuzzy_(headers, ['Amount','Amt','Total','Computed Amount','Net Amount']);

  Logger.log('[ABS/TAR][HEADERS] idxEmpId=%s idxType=%s idxAmt=%s', idxEmpId, idxType, idxAmt);
  Logger.log('[ABS/TAR][HEADERS] %s', JSON.stringify(headers));

  const rows = _loadAbsencesTardinessDirect_(inputsSS);
  const mine = rows.filter(r => String(r.empId||'').trim() === String(empId||'').trim());

  Logger.log('[ABS/TAR][ROWS] total=%s mine=%s', rows.length, mine.length);
  Logger.log('[ABS/TAR][MINE] %s', JSON.stringify(mine, null, 2));

  return mine;
}
